[{"title":"About me","path":"/2025/09/27/About-me/","content":"About me 搭建一个知识类的博客是我一直想做的事情，刚好现在也完成了上一个","tags":["Start"],"categories":["碎碎念"]},{"path":"/about/index.html","content":"个人介绍赞助列表大事记牢骚留言WxW无名小卒，为生活奔波 近日喜欢的诗作 我咽下一枚铁做的月亮许立志我咽下一枚铁做的月亮他们把它叫做螺丝我咽下这工业的废水，失业的订单那些低于机台的青春早早夭亡我咽下奔波，咽下流离失所咽下人行天桥，咽下长满水锈的生活我再咽不下了所有我曾经咽下的现在都从喉咙汹涌而出在祖国的领土上铺成一首耻辱的诗诗词节选 在听的音乐Echo 抢食异乡人 在玩的游戏我的世界 我用的设备 Macbook Pro M1 IQUNIX OG80 Razer Basilisk V3 X HyperSpeed Redmi k50 HUAWEI Free Buds 5 HUAWEI Watch GT 4 参与项目 shadcn-vue-admin Vue3 仪表盘模板 shadcn-vue Vue3 组件库 vue-devui Vue3 组件库 licht React 组件库 sable admin 中后台管理前端脚手架 SableChat UI React"},{"path":"/about/sao.html","content":"发不完牢骚，漂泊不定的人 2024 年 3 月 5 日最近每晚都睡不好，每天半夜都会惊醒一次。梦境和生活开始变得极为相似。我大概是病了吧2024 年 1 月 6 日 14:08喝点酒，感受着心脏强力的跳动，活着的感觉真好！！！2023 年 12 月 31 日 20:41新的一年快要来了，但是我看不到前方有什么希望。不知为何！2023，对所有事情都保持悲观状态。2023 年 11 月 25 日 14:26心理问题有点严重哦，要看看老庄哲学来学点超然物外的精神了！虚则静，静则定，定则从容。2023 年 11 月 19 日 20:25家里的催婚越来越严重了 如果为了结婚而结婚，这又有什么意义呢？2023 年 10 月 24 日 19:33面试出来，秋风拂面，感觉真舒服啊。恍惚间回到了 19 年，在学校中真的是初生牛犊不怕虎。现在的我却有着越来越多担心的事了。2023 年 10 月 22 日 01:24突然刷到了禁止直播带货的新闻。重心真的转到实体产业了？回家种地好像真的有出路了"},{"path":"/about/sponsor.html","content":"赞助者们 感谢各位的赞助 2022 年 11 月 02 日赞助者金额暂无0"},{"path":"/about/timeline.html","content":"大事记 2024 年 09月29我是极度不自信的一个人。但是在和几位前辈聊天后，他们都说我的技术水平还算可以。哈哈哈😄2024 年 09月20再次入京又快一年了，来时拿了多少钱，现在还是多少钱。这一年的时光像是不存在似的！2024 年 3月已经有三个月没法工资了，租的房子又要拆迁了。还得找房子2023 年 10 月重返北京，生活还需继续2023 年 7 月来大理了，出来逛逛。话说大理是真不错啊！找到一份远程的工作，感觉还不错哦！2023 年 5 月目标：成都。出发，追寻新的生活。来成都几天，找到工作了。今年的面试不好约啊。2023 年 4 月科三科四一把过，驾照拿到了，可以考虑出发了。从我上学以来，三年级就在外住校了，在家待半年的时间还是寥寥无几（印象中只有这次）。在家待的时间长了，我怕我再没勇气离开他们，离开这温暖的家。2023 年 3 月科二考过了。陪老爹去太原心血管病医院看病，住了 15 天。这应该是我和我爸独处最长的时间了。手术成功，一切顺利2023 年 2 月准备出发，但是都说考个驾照再走，工作了就不好抽时间来考试了。在大同报了个驾校。科一考过了。2023 年 1 月终于能在家过个年了，整个月都洋溢着幸福。老姐出嫁了，老爹在外打工。家里过年时显得有点冷清。2022 年 12 月疫情放开，全家都阳了一次。2022 年 11 月第一次参与开源项目，虽然只是对文档的修改。但是很兴奋经历了两年的疫情，认真思考后，从公司离职。目标：山西，回家。回家的时候还在封城，幸好听老姐的话早回几天，不然就等到 12 月全国解封了。房东人很好，走时没通暖气，把我的暖气费退掉了。"},{"title":"收藏","path":"/bookmark/index.html","content":"…"},{"title":"探索","path":"/explore/index.html","content":"…"},{"path":"/friends/index.html","content":"留言赛博好友 各位大佬的博客 峰华前端工程师SunShy三只棒棒糖xaoxuu大鱼资源网 来自GitHub的朋友 可以去友链自助添加"},{"title":"sable系列产品计划","path":"/notes/其他.html","content":"sable admin 中后台管理多级菜单 icon 组件 coupon 优惠劵 css 组件 全局 loading 历史菜单 + keep-alive 外部链接 数据可视化集成 错误页面/登录页面优化 全局暗黑模式 手机端适配 文档集成，使用单仓库 -- vitepress 怎么让用户的数据处理不会影响全局数据呢？使用浏览器数据库在进入系统时进行数据填充？？？ sable admin 后端使用技术：nestjs + mysql 目的： 提供给 sable video 使用 练习使用 nestjs 进行后端系统的搭建 sable video 前台视频点播网站 - web 端使用技术： nuxt3 功能实现：实现用户登录，评论，视频观看，帖子发布等功能 样式设计：使用 figma 进行绘制，学习 UI 设计 目的： 练习使用 nuxt 进行前端展示页面的开发 为专栏的 nuxt 入门录制实战视频 探索 nuxt 进阶使用场景 webrtcwebgl"},{"title":"常用网址导航","path":"/notes/index.html","content":"站长工具 百度统计网站访问次数统计谷歌统计谷歌网站统计 开发者 版本号规则0.0.1不兼容版本.功能更新版本.bug 修复版本^ element ui proTable postcss 插件 如何使用及 postcss 实现"},{"title":"常用网址导航","path":"/notes/好文章或视频.html","content":"2023 视频文章推荐为什么有些人看起来不努力，却进步飞快？【正确打开 2023】 有的人忙着翻身，有的人急着认命 一小时读完《Vue.js 设计与实现》 要钱不要命"},{"title":"二叉树遍历","path":"/wiki/frontNotes/ds_二叉树遍历.html","content":"什么是二叉树？ 前序遍历中左右 递归var preorderTraversal = function (root) = const result = [] if (root === null) return result const order = (node) = result.push(node) if(node.left !== null) order(node.left) if(node.right !== null) order(node.right) order(root) return result 9 6 8 迭代var preorderTraversal = function(root) = const result = [] if (root === null) return result const stack = [] stack.push(root) while(stack.length 0) const current = stack.pop() result.push(current.val) if (current.right !== null) stack.push(current.right) if (current.left !== null) stack.push(current.left) return result 中序遍历左中右 递归var preorderTraversal = function(root) = const result = [] if (root === null) return result const order = (node) = if (node.left !== null) order(node.left) result.push(node.val) if (node.right !== null) order(node.right) order(root) return result 迭代var preorderTraversal = function(root) = const resultult = [] if(root === null) return resultult const stack = [] let temp = root while(temp !== null) stack.push(temp) temp = temp.left while(stack.length) const current = stack.pop() resultult.push(current.val) if (current.right !== null) let temp2 = current.right while(temp2 !== null) stack.push(temp2) temp2 = temp2.left return resultult 后序遍历层序遍历"},{"title":"JS 事件循环（EventLoop）","path":"/wiki/frontNotes/js_EventLoop.html","content":"浏览器的进程和线程进程：每个应用至少有一个进程，进程之间相互独立。线程：一个进程中包括多个线程（线程用来运行代码）。一个进程中至少有一个线程，随进程创建的线程称为主线程。如果程序需要同时执行多块代码，需要创建多个线程。 浏览器有哪些进程和线程？浏览器是一个多进程多线程的应用程序。 当浏览器启动后，会自动启动多个进程。浏览器有哪些进程呢？ 浏览器进程负责进行主界面展示（浏览器界面）、用户交互、子进程管理（其他进程都是由其产生） 网络进程负责加载网络资源 渲染进程（一个标签页对应一个渲染进程）渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。默认情况下，浏览器会为每个标签页启动新的渲染进程，保证不同标签页之间互不影响。 渲染主线程是如何工作的？渲染主线程是浏览器中最繁忙的线程，需要它处理的包括但不限于： 解析 HTML 解析 CSS 计算样式 布局 处理图层 每秒把页面绘制 60 次（FPS） 执行全局 JS 代码 执行事件处理函数 执行计时器的回调函数 …… 思考为什么不用多个线程处理这些事？ 要处理这么多任务，主线程遇到了一个难题：如何调度任务？ 比如： 正在执行一个 JS 函数，执行到一半时用户点击了按钮，要立即去执行点击事件的处理函数吗？ 正在执行一个 JS 函数，执行到一半时某个计时器到达了时间，要立即执行该计时器的回调函数吗？ 浏览器进程通知“用户点击了按钮”，与此同时，一个计时器也到达了时间，要先处理哪一个呢？ 渲染主线程说：排队，都去排队！！！ ![临时占位](.截屏 2023-10-14 17.42.50.png) 在最开始的时候，渲染主线程会进入一个无限循环while(true)... for(;;)... 每次进入循环时会判断是否有任务存在。如果有，就取出一个任务执行，执行完成后进入下一次循环；如果没有，就进入休眠状态 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会添加到消息队列末尾。在添加新任务时，如果主线程是休眠状态，这将会唤醒主线程继续循环拿去任务。 整个过程叫做事件循环（消息循环）。 何为异步代码在执行过程中，会遇到一些无法立即处理的任务，如： 计时器完成后需要执行的任务： setTimeout setInterval 网络通信完成后需要执行的任务： XHR fetch 用户操作后要执行的任务：addEventListener 如果让渲染主线程等待这些任务的时机到达，就会导致主线程长期处于阻塞状态，从而导致浏览器卡死 ![Alt text](.截屏 2023-10-14 17.54.33.png) 渲染主线程承担着极其重要的恶工作，无论如何都不能阻塞！ 因此，浏览器选择异步来解决这个问题![Alt text](.截屏 2023-10-14 18.02.01.png) 使用异步的方式，渲染主线程永不阻塞 面试题：如何理解 js 异步JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。而渲染主线程承担着诸多工作，渲染页面、执行 HTML、CSS、JS 等都在其中运行。 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中很多其他任务无法执行。这样依赖，一方面会导致繁忙的主线程白白消耗时间，另一方面导致页面无法及时更新，给用户造成卡死的现象。 所以，浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束该任务的执行，转而执行后续代码，当其他线程完成对应的任务时，将事先传递的回调函数包装成任务加入到消息队列末尾，排队等待主线程调度执行。 在这种异步模式下，浏览器用不阻塞，从而最大限度保证了单线程的流畅运行。 JS 为什么会阻碍渲染html head/head body h1wxw/h1 buttonchange name/button script const h1 = document.querySelector(h1) const btn = document.querySelector(button) function delay(duration) const start = Date.now() while (Date.now() - start duration) btn.onclick = () = h1.textContext = !!! delay(3000) /script /body/html 任务有优先级吗任务没有优先级，在消息队列中先进先出 但是消息队列是有优先级的 根据 W3C 的最新解释： 每个任务都有一个任务类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取任务执行。 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行 随着浏览器复杂度的提升，W3C 不再使用宏队列的说法。 在 chrome 的实现中，至少包含了下面的队列： 延时队列：用于存放计时器到达后的回调事件，优先级中 交互队列：用于存放用户操作后产生的事件处理任务，优先级高 微队列：用于存放需要最快执行的任务，优先级最高 添加到微任务的最主要方式是使用 Promise、MutationObserver // 立即把一个函数添加到微队列Promise.resolve().then(函数内容) 面试题：简述一下 JS 的事件循环事件循环又叫消息循环，是浏览器主线程的工作方式。 在 Chrome 的源码中，他会开启一个不会结束的 for 循环，每次循环从事件循环队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务添加到任务队列末尾即可。 过去把事件循环队列简单分为宏队列和微队列，这种说法已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列里，不同任务可以属于不同的队列。不同任务队列有不同的优先级，再每次事件循环中，由浏览器自行决定取哪一个队列的任务，但浏览器必须有一个微任务队列，微任务队列的任务一定具有最高的优先级，必须优先调度执行。 面试题：JS 计时器能做到精确计时吗？为什么？不行，因为： 计算机硬件没有原子钟，无法做到准确计时 操作系统的计时函数本就有少量的偏差，由于 JS 的计时器最终调用的是操作系统的计时函数，也就携带了这些偏差 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4ms 的最少事件，咋样在计时器少于 4ms 时又带来了偏差 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，这又带来了些许偏差"},{"title":"JavaScript","path":"/wiki/frontNotes/js_index.html","content":"练习项目推荐https://github.com/Asabeneh/30-Days-Of-JavaScripthttps://github.com/Asabeneh/30-Days-Of-JavaScript JavaScript 基础"},{"title":"DOM","path":"/wiki/frontNotes/js_dom.html","content":"dom"},{"title":"JS 闭包 (Closure) 和 回调函数（callback）","path":"/wiki/frontNotes/js_闭包.html","content":"什么是闭包呢？在 JS 中当一个函数被创建的时候，闭包就形成了。 当一个函数能够直接访问外部作用域的条件下，形成闭包。 一个函数能够访问外部的词法作用域就是闭包 function test() var a = 1 var b = 2 function c() console.log(a, b) c() // 在内部调用 return cconst t = test()t() // 在外部调用，需要返回一个函数 有下面一段代码，函数 t2 是一个闭包吗？ function t2() console.log(123)function t() var a = 1 return test2() 不是，因为它不能访问 t 函数范围内的词法作用域 闭包的作用变量私有化 function calculator(initialNumber) let num = Number(initialNumber) || 0 function changeNumber(value) num += value // 闭包（获取了num） function add(value) changeNumber(value) // 闭包（获取了changeNumber函数） function minus(value) changeNumber(-value) // 闭包（获取了changeNumber函数） function value() return num // 闭包（获取了num） return add, minus, value const cal = calculator(10)console.log(cal.value()) 函数柯里化 function add(a, b, c) return function (b) return function (c) return a + b + c add(1)(2)(3) 每个闭包都绑定了块级作用的变量 https://www.bilibili.com/video/BV1ch4y1L7cU/?p=2vd_source=6e32730b05dc719c9f21598867bef69d const arr = []function getNumber() for (var a = 0; a 5; a++) arr[a] = a console.log(a) getNumber() 回调函数一段函数执行完成后要调用的函数，一般作为另一个函数的参数传递 function request(cb) console.log(请求开始) cb() console.log(请求结束)function callback() console.log(回调函数)request(callback)"},{"title":"浏览器渲染原理","path":"/wiki/frontNotes/js_浏览器渲染原理.html","content":"什么是渲染？ 将 HTML 字符串绘制为屏幕上的像素点的过程叫渲染（render） 浏览器是如何渲染页面的当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。 整个渲染流程分为多个阶段，分别是：HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、绘制页面。 每个阶段都有明显的输入输出，上个阶段的输出会称为下一个阶段的输入。 这样，整个渲染流程就形成了一套组织严密的生产流水线。 渲染的第一步是 解析 HTML (Parse HTML)解析过程中遇到 CSS 解析 CSS、遇到 JS 执行 JS。为了提高解析效率，浏览器在解析开始前，会启动一个预解析的流程，率先下载 HTML 中的外部 CSS 文件和 JS 文件。 如果主线程解析到 link 位置，此时外部的 CSS 文件还是没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。 如果主线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 渲染的根本原因。 第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。 渲染的第二步是 样式计算主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它的最终的样式，称之为 Computed Style。 在这一过程中，很多预设值会变成绝对值，比如 red 会变成rgb(255,0,0)；相对单位会变成绝对单位，比如 em 会变成 px 这一步完成后，会得到一棵带有样式的 DOM 树。 接下来是 布局布局完成后会得到布局树。 布局阶段会依次遍历 DOM 树中的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。 大部分的时候，DOM 树和布局树并非一一对应。 比如 display:none 的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中并不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。含有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。 下一步是 分层主线程会使用一套复杂的策略对整个布局树中进行分层。 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过 will-change 属性更大程度的影响分层结果。 再下一步是 绘制主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。 再下一步是 分块完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将会由合成线程完成。 合成线程首先对每个图层进行分块，将其划分为更多的小区域。 他会从线程池中拿取多个线程来完成分块工作。 再下一步是 光栅化分块完成后，进入光栅化阶段。 合成线程会将信息交给 GPU 进程，以极高的速度完成光栅化。 GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。 光栅化的结果，就是一块一块的位图。 再下一步是 绘制最后一个阶段就是绘制了。 合成线程拿到的每个层、每个块的位图后，生成一个个指引（quad）信息。 指引会标识出每个位图应该绘制到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。 变形会发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因。 合成后会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。 什么是 reflowreflow 的本质就是重新计算 layout 树。 当进行了会影响布局树的操作后，需要重新计算布局树，会引发 reflow。 为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。 也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。 浏览器在反复权衡下，最终决定获取属性立即 reflow。 什么是 repaintrepaint 的本质就是重新根据分层信息计算了绘制指令。 当改动了可见样式后，就需要重新计算，会引发 repaint。 由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。"},{"title":"浏览器输入URL后发生了什么","path":"/wiki/frontNotes/js_浏览器输入URL后发生了什么.html","content":"http://www.bilibili.com/space/xxxx.html URL 是由 访问协议 http 服务器名称：域名 www.bilibili.com 资源的路径名 目录名 /space/ 文件名 xxxx.html DNS 查询为什么要有 DNS？ 每个服务器的地址其实是一个 IP 地址，IP 不是很好记忆，衍生出了域名来辅助我们记忆。DNS 可以通过域名来查找对应的 IP 地址 DNS 查询顺序如下，若其中一步成功则直接跳转到建立连接部分： 浏览器自身 DNS 操作系统 DNS 本地 hosts 文件 向域名服务器发送请求查找顺序如下： 客户端- 本地 DNS 服务器 - 根域名服务器 客户端- 本地 DNS 服务器 - 顶级域名服务器 客户端- 本地 DNS 服务器 - 权威域名服务器 发送网络请求OSI 七层网络模型 解析页面"},{"title":"面试题","path":"/wiki/frontNotes/js_面试题.html","content":"this闭包深度克隆递归 const cache = new WekaMap()function deepClone(value) if (typeof value !== object || value === null) return value const cached = cache.get(value) if (cached) return cached const result = Array.isArray(value) ? [] : // 保持原形一致 Object.setPrototypeOf(result, Object.getPrototypeOf(value)) cache.set(value, result) for (const key in value) // 剔除原型链上的内容 if (value.hasOwnProperty(key)) result[key] = deepClone(value[key]) return result JSON 转换 无法处理循环引用 function deepClone(value) return JSON.parse(JSON.stringify(value)) 标签页通信 当消息包含函数、Symbol 等不可序列化的值时，就会报无法克隆的 DOM 异常。 function deepClone(value) return new Promise((resolve) = const port1, port2 = new MessageChannel() port1.postMessage(value) post2.onmessage = (msg) = resolve(msg.data) ) 性能优化 CDN 引入 SPA 路由懒加载 图片懒加载 图片压缩 使用 webp 格式图片 相同类型包替换，dayjs 替换 momentjs 打包优化 代码切割，将不同的代码分包 开启 gzip 压缩"},{"title":"两数之和","path":"/wiki/frontNotes/leetcode_两数之和.html","content":"二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。n 将在 [1, 10000]之间。nums 的每个元素都将在 [-9999, 9999]之间。 解function search(nums: number[], target: number): number let right = nums.length - 1 let left = 0 while (left = right) let middle = Math.floor(left + (right - left) / 2) if (nums[middle] === target) return middle else if (nums[middle] target) left = middle + 1 else if (nums[middle] target) right = middle - 1 return -1"},{"title":"面试题","path":"/wiki/frontNotes/ms_面试题.html","content":"vue 都有哪些生命周期vue2 中有 beforeCreate,created, beforeMount,mounted, beforeUpdate, updated, beforeDestroy, destroyed vue3 中有 onBeforeMount, onMounted, onUpdate, onUpdated, onUnmount,onUnmounted都会在 setup 中同步调用 vue 双向绑定的原理是什么vue2 中使用 Object.defineProperty 来劫持每个数据的 getter 和 setter，在数据发生变化时进行响应的处理。 vue3 中使用 Proxy 来解决 Object.defineProperty 的一些问题 vue3 响应式数据原理是什么？vue3 使用了 Proxy 来实现响应式数据，放弃了 vue2 中使用 Object.defineProperty，主要是有一下几点考虑： Object.defineProperty 无法监听到数组下标的变化，导致数组通过下标添加或修改时无法响应 Object.defineProperty 只能劫持对象的属性，从而需要对每个对象进行遍历，如果属性值还是对象，就需要进行深度遍历。Proxy 可以劫持整个对象，并返回一个新对象 Proxy 不仅可以代理对象，还可以代理数组。甚至可以代理动态新增的属性 ?? Proxy 只会代理对象的第一层，vue3 是如何处理这个问题呢？判断当前的 Reflect.get 返回值是否为 Object，如果是就通过 reactive 方法进行代理，这样就做到了深度监听 ?? v-model 的双向绑定原理是什么v-model 的本质是 :value 和 updatedValue 的集合 vue2 和 vue3 渲染器的 diff 算法有什么不同呢？为什么 vue3 的性能会很好呢？为什么 vue3 的表格有时会很卡呢？有什么解决方法？vue 组建参数传递vue 路由怎么实现呢？vuex 是什么，如何使用呢？什么场景下会使用它v-if 和 v-show 的区别如何让 css 只在当前组建中起作用使用 scoped，使用 scoped 后，每个 css 会被添加一个唯一的动态属性。 scoped 如何实现样式穿透keep-alive 的实现原理是什么？相关的生命周期函数，什么场景下会使用？常用属性有哪些？怎么声明一个组件？如何实现全局组件注册？nextTick 有什么作用？实现原理是什么？SSR 的实现原理vue2 data 为什么必须是一个函数vue computed 的实现原理watch 和 computed 的区别是什么？都在场景下使用？"},{"title":"nuxt.config.ts 配置文件使用","path":"/wiki/frontNotes/nuxt_NuxtConfigTs.html","content":"alias 路径别名网站信息配置"},{"title":"初识Nuxt","path":"/wiki/frontNotes/nuxt_index.html","content":"官网网址 https://nuxt.comhttps://nuxt.com 为什么会有 Nuxt在了解为什么会出现 Nuxt 时，我们要先了解两个概念：spa 和 ssr spa： 单页应用，多用于客户端应用。使用 vue 或 React 开发的网站默认都是 spa。对 seo 不友好，搜索引擎收录率不好。 ssr： 在服务端渲染，渲染完成后返回给客户端，每个页面都有独立的 URL，对 seo 友好，搜索引擎收录率良好。 对于一些应用（官网、活动页等）需要做搜索引擎优化，所以出现了服务端渲染技术。React 的服务端渲染框架中的优胜者是 Next，vue 的服务端渲染的优胜者是 Nuxt。 初次安装使用我们可以使用 npx 直接使用 nuxi 初始化一个 Nuxt3 应用。 使用 npx 需要 npm 版本在 5.2 以上。 npx nuxi init nuxt3-learn 出现以下内容就是初始化成功了 我们可以根据提示 cd nuxt3-learn 进入项目并使用 pnpm i --shamefully-hoist 安装需要的依赖。安装完成后，使用 pnpm run dev 来启动项目，出现下面的图片说明项目启动成功。 我们可以进入http://localhost:3000来访问启动的服务，可以看到 Nuxt 的欢迎页面 目录结构创建项目后的默认目录结构|-- .nuxt/ // nuxt自动编译后的目录|-- node_modules/ // npm 依赖包目录|-- .gitignore // git忽略文件|-- app.vue // 项目入口文件|-- nuxt.config.ts // nuxt项目配置文件|-- package.json // 项目配置文件|-- pnpm-lock.yaml // pnpm 依赖锁定文件|-- README.md // 项目说明文件|-- tsconfig.json // ts配置文件 随着开发的进展，开发时需要自己创建的文件目录 需要自己创建的目录概览|-- pages // 页面目录|-- components // 组件目录|-- assets // 静态资源目录|-- public // 静态资源目录|-- layouts // 布局目录|-- composables // 在此目录下的文件会被nuxt自动引入 下一节我们会比较详细地讲解以上常用目录的使用方式"},{"title":"常用内置标签","path":"/wiki/frontNotes/nuxt_内置标签.html","content":"NuxtLinkNuxtLink 会被编译为 a 标签 template NuxtLink to=https://whbbit.cnwhbbit/NuxtLink !-- 编译后：a href=https://whbbit.cn rel=noopener noreferrerwhbbit/a -- NuxtLink to=/apiAPI/NuxtLink !-- 编译后：a href=/apiAPI/a --/template NuxtLink 包含有 target，rel，noRel 属性 template NuxtLink to=https://twitter.com/nuxt_js target=_blank Nuxt Twitter /NuxtLink !-- a href=https://twitter.com/nuxt_js target=_blank rel=noopener noreferrer.../a -- NuxtLink to=https://discord.nuxtjs.org target=_blank rel=noopener Nuxt Discord /NuxtLink !-- a href=https://discord.nuxtjs.org target=_blank rel=noopener.../a -- NuxtLink to=https://github.com/nuxt no-rel Nuxt GitHub /NuxtLink !-- a href=https://github.com/nuxt.../a -- NuxtLink to=/contact target=_blank Contact page opens in another tab /NuxtLink !-- a href=/contact target=_blank rel=noopener noreferrer.../a --/template 路由可以匹配 NuxtLink 的 to 属性时，NuxtLink 编译后会被追加router-link-exact-active类。可以使用 .router-link-exact-active 控制 NuxtLink 的高亮样式。 layout/default.vuetemplate nav NuxtLink to=/首页/NuxtLink NuxtLink to=/getstart新手入门/NuxtLink NuxtLink to=/apiAPI/NuxtLink NuxtLink to=/about关于/NuxtLink /nav main slot / /main/templatestyle .router-link-exact-active color: #12b488; /style NuxtLayoutNuxt 内置的布局标签，使用 name prop 来调用对应的布局 编写默认布局 layout/default.vuetemplate div default layout slot / /div/template 编写 docs 布局 layout/docs.vuetemplate div docs layout slot / /div/template 使用默认布局 app.vuetemplate NuxtLayoutapp.vue/NuxtLayout/template 使用 docs 布局 app.vuetemplate NuxtLayout name=docs app.vue /NuxtLayout/template ClientOnly 包裹只在客户端展示的代码片段 template ClientOnly/ClientOnly/template NuxtLoadingIndicator / 提供网页顶部加载效果提供网页顶部加载效果 示例layout/default.vuescript lang=ts setup/scripttemplate nav class=bg-gray-700 NuxtLoadingIndicator / div class=container m-auto flex w-full justify-between items-center img src=/images/cnodejs_light.svg alt= class=h-[30px] w-auto / div class=flex gap-4 py-3 justify-end NuxtLink to=/首页/NuxtLink NuxtLink to=/getstart新手入门/NuxtLink NuxtLink to=/apiAPI/NuxtLink NuxtLink to=/about关于/NuxtLink /div /div /nav div class=container m-auto mt-2 slot / /div/templatestyle scoped lang=scss a text-decoration: none; color: #fff; .router-link-exact-active color: #12b488; /style props color：加载条颜色 height：加载条高度，默认 3 duration：加载条持续时间，默认 2000ms throttle： 限制出现和隐藏，默认 200ms NuxtErrorBoundary 可以捕获错误并进行展示 NuxtWelcomeNuxt 欢迎界面，创建项目时的 app.vue 中存在 TeleportfajsdFDJAS 和 vue3 中的 Teleport 标签用法一致"},{"title":"常用目录使用概览","path":"/wiki/frontNotes/nuxt_常用目录使用概览.html","content":"pages 目录我们可以根据约定式路由来访问对应的界面 |-- pages/ |-- index.vue |-- user-[group]/ |-- [id].vue 静态资源composables 目录composables 目录下的文件会被自动引入 具名导出 composables/useFoo.tsepxort const useFoo = () = return useState(foo, () = bar) 匿名导出 composables/useFoo.tsexport default () = return useState(foo, () = bar) 在 .vue 文件中使用 app.vuetemplate divfoo/div/templatescript setup const foo = useFoo()/script layouts 目录|-- layout/ |-- default.vue |-- doc.vue layouts/default.vuetemplate div default layout slot / /div/template layouts/doc.vuetemplate div doc layout slot / /div/template components 目录|-- layout/ |-- default.vue |-- doc.vue layouts/default.vuetemplate div default layout slot / /div/template layouts/doc.vuetemplate div doc layout slot / /div/template"},{"title":"初识Nuxt","path":"/wiki/frontNotes/nuxt_技巧.html","content":"useFetch transform可以控制需要的数据，减少请求大小，加快页面加载速度 _Nuxt_"},{"title":"项目实战——博客项目","path":"/wiki/frontNotes/nuxt_实战.html","content":"实战部分我们使用 Nuxt3 实现一个博客项目 使用到的 Nuxt 模块@nuxtjs/tailwindcss：用户编写页面样式 https://nuxt.com/modules/tailwindcsshttps://nuxt.com/modules/tailwindcss @nuxt/content：用于解析 markdown 文件 https://nuxt.com/modules/contenthttps://nuxt.com/modules/content 项目初始化初始化博客项目 pnpm dlx nuxi init nuxt-blog cd nuxt-blog pnpm i 依赖安装 pnpm i @nuxtjs/tailwindcss @nuxt/content pnpm i -D sass 配置 nuxt.config.ts文件 export default defineNuxtConfig( modules: [@nuxtjs/tailwindcss, @nuxt/content, @nuxt/ui], highlight: theme: vitesse-dark, ,) 创建布局文件创建 content 文件夹——存放 markdown 文件"},{"title":"初识React","path":"/wiki/frontNotes/react_index.html","content":"https://beta.reactjs.org/https://beta.reactjs.org/"},{"title":"初识 TypeScript","path":"/wiki/frontNotes/ts_index.html","content":"https://www.typescriptlang.org/https://www.typescriptlang.org/ 为什么要学习 TypeScript 为大型系统而生 ts 是静态类型化的 js 的超集，在大型工程中有无可比拟的优势。 招聘市场需求 大量的前端团队都在使用 ts 进行系统的开发。 新框架几乎都在使用 ts 推荐课程我觉得学习 ts 最快的方法就是跟着别人的视频先大概了解一下 ts 到底是什么，能干什么事，大概的语法了解一下，深入部分可以自己去官方文档去查看。这里我推介一下我学习 ts 用到的部分视频资料网址。 付费教程： 后盾人网站 包含了装饰器等的使用，可以从多个角度了解 ts 在日常开发中的使用。在这个网站中甚至有 vue3、vue-router、js 基础、php 等全方面教程。可以全方位了解开发时前后端的流程。 https://www.houdunren.comhttps://www.houdunren.com 免费教程： 小满zs 的 ts 基础教程 https://www.bilibili.com/video/BV1wR4y1377K/?vd_source=6e32730b05dc719c9f21598867bef69dhttps://www.bilibili.com/video/BV1wR4y1377K/?vd_source=6e32730b05dc719c9f21598867bef69d 开发前的准备在开始使用 ts 前要有以下的准备工作： nodejs 8.0，最好是在 12 版本以上 包管理工具： npm、yarn 或 pnpm 其一 可以现在 typescript 官方训练场测试学习测试 ts 代码 https://www.typescriptlang.org/playhttps://www.typescriptlang.org/play 也可以在本地安装 typescript 进行项目开发 安装 ts 推荐使用 vite 创建 ts 项目，开箱即用。 通过 npm 全局安装 ts npm i -g typescript 创建环境手动创建创建 ts-learn 目录用于 ts 的学习 mkdir ts-learn cd ts-learn 在 ts-learn 目录下进行 node 项目初始化 npm init -y 进行 ts 的初始化工作 全局安装 ts 后会有 tsc 命令 tsc --init tsc 项目初始化后，会出现 tsconfig.json 文件，可以在 tsconfig.json 中开启或关闭某些设定。 使用 vite 创建更推介这种创建方式，省去很多对 tsc 的配置，可以让我们专注在 ts 的内容中 pnpm create vite 选择 Vanilla , typescript 即可创建好一个 typescript 的项目。"},{"title":"interface 和 type","path":"/wiki/frontNotes/ts_interface和type.html","content":"interface 和 abstract 抽象类想比 interface 中不能有具体代码实现。 类中实现 interface在类中要实现 interface，需要使用 implements interface name interface IAnimal name: string getName(): voidabstract class Animal constructor(public name: string) setName(name: string) this.name = name class Cat extends Animal implements IAnimal constructor(public name: string) super(name) public getName(): string return this.name const cat = new Cat(cat)cat.setName(dog)console.log(cat.getName()) interface 对对象的约束interface 对对象的约束，作用和 type 类似 [key: string]: any; 表示对象的键需要是字符串类型，值的累心不做约束 interface IUser name: string age: number site?: string info(): string [key: string]: anylet user: IUser = name: wxw, age: 25, sex: 男, info() return `$this.name $this.age` , 在函数中使用 interfaceinterface IUser name: string age: numberfunction setUser(user: IUser) return usersetUser( name: wxw, age: 25 ) interface 对函数的约束interface IGetUser (name: string): stringconst getUser: IGetUser = (name: string) = return nameconsole.log(getUser(W)) 在类中使用 interfaceinterface IUser name: string age: numberclass User _info: IUser constructor(user: IUser) this._info = user get info() return this._info const user = new User( name: whbbit, age: 25 )console.log(user.info) 数组中使用 interfaceinterface IUser name: string age: numberconst user1 = name: whbbit, age: 25 const user2 = name: wxw, age: 25 const users: IUser[] = [user1, user2] interface 结合 enumenum SexType BOY, GIRL,interface IUser name: string age: number sex: SexTypeconst user1 = name: whbbit, age: 25, sex: SexType.BOY const user2 = name: wxw, age: 25, sex: SexType.GIRL const users: IUser[] = [user1, user2] interface 的继承interface IVoice voice(): voidinterface IAnimal extends IVoice name: string getName(): void// 相当于// interface IAnimal // name: string;// getName(): void;// voice(): void;// interface 声明合并写一个同名 interface 就会实现 interface 的合并。 后面的 interface 和前面的 interface 中不能有同名参数 interface IAnimal name: string getName(): stringinterface IAnimal voice(): stringconst cat: IAnimal = getName() return this.name , name: cat, voice() return miao~ ,console.log(cat.getName())console.log(cat.voice()) type大多数情况下 type 和 interfere 使用相同 type TUser = name: string; age: 25 function getUser(user: TUser): TUser return userconst user: TUser = name: wxw, age: 25,console.log(getUser(user)) type 可以作为基本类型的别名使用，也可以申明联合类型 type IsAdmin = booleantype Sex = boy | girl type 和 interface 的区别 interface 同名会合并，type 同名会报错 interface 可以继承，type 使用 合并 type 可以使用 合并 interface 类型 type TName = name: stirng ;type TAge = age: number ;interface IMember = member: booleantype TUser = TName TAge IMember;"},{"title":"函数","path":"/wiki/frontNotes/ts_函数.html","content":"对函数进行声明 let func = () = whbbit.cn// ts会自动推断类型为 let func:() =string 明确类型赋值 let func: Function 对函数参数的类型限制function add(a: number, b: number) return a + badd(1, 2) 参数为可选参数时，可以使用 ? 进行限制，没有参数传参时，默认为 undefined function add(a: number, b: number, c?: number) console.log(c) // undefined return a + badd(1, 2) 设置默认参数值 有默认值时，? 需要去除 function add(a: number, b: number, c: number = 20) console.log(c) // 20 return a + badd(1, 2) 对函数返回值的类型限制ts 可以对函数返回值进行自动推断 let add = (a: number, b: number) = return a + b 也可以手动对返回值进行类型限制 let func = (a): void = console.log(`接收到了参数 $a`) function add(a: number, b: number): number return a + b 使用 type 对重复类型声明进行抽离let addUser = (user: name: string; age: number ): void = console.log(`添加用户$user`)addUser( name: whbbit, age: 25 )let updateUser = (user: name: string; age: number ): void = console.log(`编辑用户$user`)updateUser( name: whbbit1999, age: 25 ) 这时我们会发现，有重复的类型声明。我们可以使用 type 对重复的类型声明进行抽离 type userType = name: string; age: number let addUser = (user: userType): void = console.log(`添加用户$user`)addUser( name: whbbit, age: 25 )let updateUser = (user: userType): void = console.log(`编辑用户$user`)updateUser( name: whbbit1999, age: 25 ) 对函数结构的定义let func: (a:number, b: number) = number; // 这里是函数的结构// 这里是函数的实现func = (x: number, y:number) return x + y let addUser: (user: name: string; age: number ) = voidaddUser = (user: name: string; age: number ) = console.log(user)addUser( name: whbbit, age: 25 ) 可以使用 type 定义函数结构 type userType = name: string; age: number type addUserFunc = (user: userType) = voidlet addUser: addUserFuncaddUser = (user: userType) = console.log(user)addUser( name: whbbit, age: 25 ) 剩余参数的使用function sum(...args: number[]): number return args.reduce((s, n) = s + n, 0)console.log(sum(1, 2, 3, 4, 5)) function push(arr: any[], ...args: any[]): any[] arr.push(...args) return arrlet arr = push([], 1, 2, true, false)console.log(arr)"},{"title":"namespace 命名空间","path":"/wiki/frontNotes/ts_命名空间.html","content":"我们可以使用命名空间进行隔离，命名空间中的内容想让外部使用时，需要导出。类似于 es6 中的模块 namespace User export let username: string = whbbitconsole.log(User.username) 命名空间的嵌套想让外部使用时，需要对嵌套的命名空间进行导出 namespace User export let username: string = whbbit export namespace Member export let name = wxw console.log(User.Member.username)"},{"title":"基本数据类型","path":"/wiki/frontNotes/ts_基本数据类型.html","content":"包含了对断言、never、void 等类型的说明 基本类型定义数据类型，基本数据类型中包含 string number boolean 等 let name: string = whbbit // name 的值只能是字符串类型let age: number = 25 // age的值只能是数值类型let work: boolean = false // work的值只能是true/falselet stringArr: string[] // 数组里的值只能是字符串let obj1: object // obj1必须是一个对象let obj: name: string; age: number // obj这个对象中只能包含name和age属性，且类型必须是规定的类型 在 : 前添加 ? 表示这个值不是必填 let obj1: name: string; age: number; work: boolean = name: whbbit, aage: 25,console.log(obj1) // 编译时会有报错，Property work is missing in type name: string; age: number; but required in type name: string; age: number; work: boolean; .let obj: name: string; age: number; work?: boolean = name: whbbit, age: 25,console.log(obj) 类型自动推断在不写类型时，ts 会自动进行类型推断 let name = whbbit // 等同于 - let name: string = whbbit 类型组合使用 | 表示类型可以多选，符合 | 之前或者之后的类型即可 let a: string | number // 表示a可以是字符串也可以是一个数值a = whbbita = 20let b: string | number | booleanb = whbbitb = 20b = falselet arr: (string | number)[] = [] // 数组内容只能为字符串或数值类型let arr1: Arraystring | number = [] // 使用泛型 any在我们不知道是什么类型时，可以定义为 any 类型。对类型不做校验 let a: anya = whbbita = 10a = falsea = [whbbit]let arr: Array[any]let arr1: any[] 也可以对构造函数生成的实例进行类型限制。 不推介这样做，class 的类型推断和限制就没有了，不符合使用 ts 的场景 class Animal constructor() get = () = whbbit.cnconst cat: any = new Animal() 对配置文件改动，取消对 any 类型的自动推断 noImplicitAny: true unknownunknown 和 any 的区别 unknown 表示有类型但是不明确类型是什么，ts 会进行类型的判断 any 表示这个值没有类型，ts 不会进行类型的判断 let a: anylet a1: string = a // 不会进行报错，ts不做类型校验let b: unknownlet c: string = b // ts校验报错，类型不匹配 可以使用 as 断言来解决 let b: unknownlet c: string = b as string // 断言变量b一定是一个string类型的值 断言是什么? 怎么用?let a: string = 20let b: number = a as number // 会报错，不能对已经声明类型的值进行断言 怎么解决这种问题呢？ 我们可以先将 b 转换为 unknown 类型再断言 let a: string = 20let b: number = a as unknown as number voidvoid 可以是 null 或 undefined，多用于函数返回值的类型 let a: void = nulla = undefined nevernever 不是任何类型，在函数不能执行到结尾时进行类型推断 function err(): never throw new Error(err) void 和 never 的区别 void 常用作函数的返回值的推断，函数没有返回值时，可以将返回类型写为 void never 常用作 函数不能执行到末尾 时对函数类型的限制 function printString(content: any): void console.log(content)function throwError(err): never throw new Error(err) null undefinednull 和 undefined 代表的类型就是 js 中对应的 null 和 undefined let a: null = nulllet b: undefined = undefined 默认情况下 null 和 undefined 可以作为其他类型的值 let a: stringa = nulla = undefined// 这时不会报错 可以修改 tsconfig.json 文件中的配置让其不能作为其他类型的值 strictNullchecks: true"},{"title":"元组 tuple","path":"/wiki/frontNotes/ts_元组.html","content":"// 数组类型的限制， 我们无法做到对对应位置元素类型的限制let arr: (string | number)[] = [whbbit, wxw, 25] 元组可以对固定位置参数类型的限制 // 限制arr第一个元素是string类型，第二个元素是number类型，第三个元素是boolean类型let arr: [string, number, boolean] = [whbbit, 20, false]arr[0] = wxw // 类型正确，可以进行更改arr[0] = 10 // 这时就会报错"},{"title":"as 断言","path":"/wiki/frontNotes/ts_断言.html","content":"断言就是我说了算。 // 这里的element 默认类型是HTMLElement | null ，这里我们可以直接说明这个element一定存在并且为一个div标签const element = document.getElementById(el) as HTMLDivElement as const 断言let a: string = whbbita = whbbit.cnconst b = whbbit // 按照js语法，b的值不能被改变let c = whbbit as const // c的值可以改变，但是只能改变为whbbit// 写法等同于 let c: whbbit = whbbit 数组使用 as const 时，相当于声明一个元组。 const arr = [whbbit, 25] as const// 等同于 const arr: [whbbit, 25] = [whbbit, 25]let a: string = whbbitlet b: number = 25const arr1 = [a, b] as const// 等同于 const arr: [string, number] = [a, b] 对象使用 as const 时 let age: number = 20let c = true as constconst obj = name: whbbit, age, c, as const// 类型为 readonly name: whbbit, readonly age: number, readonly c: true 数组或对象使用 as const 时，如果内容是引入别处的变量时，就使用该变量的类型，如果是常量时，就使用该常量的值 as const 在解构中使用的便利性 function func() let a = whbbit let b = 25 return a, b as constlet a, b = func()// 这时ts可以准确的推断a的类型是string，b的类型是number。// 不使用as const 时，a和b的类型都是 string | numberconsole.log(a, b) 非空断言const el = document.querySelector(#app)// 类型为 HTMLElement | null 当我们知道 id app 的元素是一个 div 元素时，我们想让其类型明确为HTMLDivElement 以获得更好的类型提示 const el: HTMLDivElement = document.querySelector(#app)// 这时会报错 Type HTMLDivElement | null is not assignable to type HTMLDivElement. Type null is not assignable to type HTMLDivElement. 当我们清楚的知道这个元素一定不为空时，就可以使用非空断言 const el: HTMLDivElement = document.querySelector(#app)! 或者我们也可以直接为其断言 const el = document.querySelector(#app) as HTMLDivElement DOM 类型推断我们可以断言 DOM 类型， 事件类型等 const el = document.querySelector(#app) as HTMLDivElementel.addEventListener(click, (e: Event) = console.log(e.target))"},{"title":"模块使用","path":"/wiki/frontNotes/nuxt_模块.html","content":"集成 tailwindcss安装 tailwindcss pnpm i @nuxtjs/tailwindcss 在 nuxt.config.ts 文件中配置 nuxt.config.tsexport default defineNuxtConfig( modules: [@nuxtjs/tailwindcss],) 配置完成后，我们可以在 app.vue 文件中进行测试 app.vuetemplate div class=bg-gray-200 h-screen flex items-center justify-centerapp.vue/div/template 页面成为下面的样式就说明我们已经成功将 tailwindcss 集成到我们的项目中了"},{"title":"枚举类型","path":"/wiki/frontNotes/ts_枚举类型.html","content":"枚举的默认编号从 0 开始 enum SexType BOY, GIRL,console.log(SexType.BOY) // 0 可以自定义起始编号，后面的会自动 +1 enum SexType BOY = 1, GIRL,console.log(SexType.BOY, SexType.GIRL) // 1, 2 可以自定义值 enum Values TOKEN = token, SITE = whbbit.cn,"},{"title":"ts中的类","path":"/wiki/frontNotes/ts_类.html","content":"对参数进行约束定义一个普通的类，约束其接收的参数的类型 class User name: string age: number constructor(name: string, age: number) this.name = name this.age = age const user1 = new User(Whbbit, 25)const user2 = new User(wxw, 25)// 限制users数组的值只能是User类示例化的对象const users: User[] = [user1, user2] public 修饰符使用 public 修饰符表示这个函数，变量可以在函数外进行访问。默认为 public 在 js 中默认就可以在外部进行访问 class User public name: string public age: number constructor(name: string, age: number) this.name = name this.age = age public getName() return `name: $this.name, age: $this.age` const user1 = new User(whbbit, 25)user1.name = wxwconsole.log(user1.name)console.log(user1.getName()) protected 修饰符使用 protected 后，只能在类中调用。可以对方法和属性进行约束。 class User protected name: string protected age: number constructor(name: string, age: number) this.name = name this.age = age protected show() console.log(show) public getName() return `name: $this.name, age: $this.age` const user1 = new User(whbbit, 25)user1.name = wxw // ts 报错console.log(user1.name) // ts 报错user1.show() // ts 报错console.log(user1.getName()) // 正常运行 在父类中声明的受保护的方法或属性，在子类中可以调用。但在类外部不可调用 class Person protected name: string protected age: number protected show() console.log(show) class User extends Person constructor(name: string, age: number) super() this.name = name this.age = age public getInfo() return this.show() const user1 = new User(wxw, 25)user1.getInfo() private 私有属性在子类或类外部都不可访问。在父类中定义的私有方法子类不可使用，不可覆盖 class Person protected name: string; public age: number; private site: string; protected show() console.log(show， `site is $this.site`); class User extends Person constructor(name: string, age: number) super(); this.name = name; this.age = age; getSite() console.log(this.site); public getInfo() return this.show(); const user1 = new User(wxw, 25);user1.getInfo();console.log(user1.site); 在父类中定义的受保护的方法，在子类中可以使用，可以覆盖，但是权限只能降低为 public 或维持 protected。不能将其更改为private class Person protected name: string; public age: number; private site: string; protected show() console.log(show， `site is $this.site`); class User extends Person constructor(name: string, age: number) super(); this.name = name; this.age = age; getSite() console.log(this.site); private show() console.log(这里是子类覆盖掉的shou方法) public getInfo() return this.show(); const user1 = new User(wxw, 25);user1.show() readonly限定属性不能进行修改 class Axios readonly site: string = https://www.whbbit.cn/api constructor() public get(url: string) console.log(`请求地址是$url`) return [] const instance = new Axios()console.log(instance.site)instance.site = https://api.com // 报错：Cannot assign to site because it is a read-only property 但是在构造函数初始化时可以更改 class Axios readonly site: string = https://www.whbbit.cn/api constructor(site?: string) this.site = site || this.site public get(url: string) console.log(`请求地址是$this.site/$url`) return [] const instance = new Axios()instance.get(article) // 请求地址是https://www.whbbit.cn/api/articleconst instance1 = new Axios(https://www.whbbit.cn/docs)instance1.get(article) // 请求地址是https://www.whbbit.cn/docs/article readonly 前可以添加 public、protected、 private等修饰符 constructor 构造函数在构造函数中接收的参数前书写修饰符，ts 会自动帮我们进行初始化操作 class User constructor(public name: string, public: age: string) // 等同于 // public name: string // public age: number // constructor( name: string, age: number) // this.name = name // this.age = age // static 静态属性方法static 静态属性方法只能通过构造函数调用。 使用 static 修饰属性 class Axios static site: string = whbbit.cn constructor() const instance = new Axios()console.log(Axios.site)console.log(instance.site) // 报错 上面代码编译为 js 后的代码 use strictclass Axios constructor() Axios.site = whbbit.cnconst instance = new Axios()console.log(Axios.site)console.log(instance.site) // 报错 static 也可以修饰方法 class Axios static site: string = whbbit.cn constructor() public static getSite() return Axios.site const instance = new Axios()console.log(Axios.getSite()) get setclass User constructor(private _name: string) public get name(): string return this._name public set name(name: string) this._name = name const user = new User(wxw)console.log(user.name)console.log((user.name = whbbit))console.log(user.name) 使用访问器 getset 可以在设置或获取时进行处理 type articleType = title: string class Articles constructor(private _lists: articleType[] = []) get articles(): articleType[] return this._lists.map((article) = article.title = article.title + www.whbbit.cn return article ) set articles(articles: articleType[]) this._lists = articles const list = new Articles()list.articles = [ title: ts中的类 , title: ts断言 ]console.log(list.articles) 单例模式实现 将构造函数设置为私有 定义一个静态方法用来生成实例 定义一个静态属性，在静态方法中判断是否已经初始化，未初始化就进行初始化，已经初始化直接返回这个生成的实例 class Axios private static instance: Axios | null = null private constructor() console.log(构造函数方法) static make(): Axios if (Axios.instance === null) Axios.instance = new Axios() return Axios.instance const instance = Axios.make()console.log(instance) 抽象类// 抽象类abstract class Animal constructor(public name: string) abstract getName(): string setName(name: string) this.name = name // 派生类class Cat extends Animal constructor(public name: string) super(name) public getName(): string return this.name const cat = new Cat(cat)cat.setName(dog) 抽象类无法被实例化 派生类中需要实现抽象类中定义的方法"},{"title":"generics 泛型","path":"/wiki/frontNotes/ts_泛型.html","content":"什么是泛型可以理解为动态的类型，类型中可以接受参数。 我们要做一个输入什么就返回什么的函数，当我们将类型写死后，传递其他类型的数据就会在编译时报错类型错误。我们能不能做到在传递参数时声明一个类型，让我们声明的类型进行判断呢？ function returnSomething(inputSomething: string): string return inputSomethingreturnSomethingstring(wx)returnSomething(23) // 报错 这时我们可以使用泛型接受类型参数 function returnSomethingT(inputSomething: T): T return inputSomethingreturnSomethingstring(wx)returnSomethingnumber(2) 泛型的继承 extends有时我们需要一些特定类型的参数，里面包含一些相同的类型，我们可以用 extends 继承来约束可以传递的参数 function getLengthT extends length: number (arg: T): number return arg.lengthfunction getLengthT extends length: number (arg: T): number return arg.lengthgetLength(www)getLength([2, 3, 4])getLength(2) // 报错 类中使用我们可以使用泛型对函数的类型做限制，将类型的定义部分开放给用户。 class UserT constructor(private user: T) get(): T return this.user interface IUser name: string age: numberconst user = new UserIUser( age: 2, name: xxx )console.log(user.get()) interface 使用泛型interface IArticleB, C title: string isLock: B comments: C[]type CommentType = content: string const article: IArticleboolean, CommentType = title: 测试文章, isLock: false, comments: [ content: 测试评论 ],"},{"title":"结语","path":"/wiki/frontNotes/ts_结语.html","content":"看完这些，基本的 ts 项目就大概可以看懂了。如果你想要精进自己的 ts 技术，可以去玩一下 https://github.com/type-challenges/type-challengeshttps://github.com/type-challenges/type-challenges 也可以去挑战一下 ts 的类型体操，不过这个对于实际项目中没有什么作用。"},{"title":"TypeScript中的类型工具","path":"/wiki/frontNotes/ts_类型工具.html","content":"这部分内容不是很好懂，可以多练习几次 extends 的多种使用方式类型继承extends 可以表示必须包含后面的类型 function userT extends id: number; render: (x: number) = number (arr: T[]) console.log(arr)user([ id: 1 ]) extends 类型条件判断窄类型 extends 宽类型 ? xxx : xxx判断窄类型是否从属于宽类型，可以就为 true，否则为 false type a = name: string; age: number type b = name: string type c = b extends a ? true : falselet d: c = falsed = true // 报错 对泛型进行条件判断分配类型使用[]包裹表示完全比对 [T] extends [a] type a = string | undefinedtype bT = T extends a ? string : booleanconst c: bnumber = false // 这时number不在a的类型里，所以此时c类型为booleanconst d: bstring = d // string在a的类型中，此时d的类型为string Exclude 过滤从左侧联合类型中过滤掉右边的类型，保留左侧类型比右侧类型中多的类型 type a = number | booleantype b = number | string | booleantype c = Excludeb, a// 获得的新类型为 stringtype d = Excludea, b// 获得的新类型为 never Extract和 Exclude 作用相反。只保留右侧类型声明中的类型 type a = number | boolean | stringtype b = Extracta, number | boolean// 获得的新类型为 number | boolean Picktype PICKT,U extends keyof K = {[P in U]: T[P]} 在类型中提取某几个组成新类型 type User = name: string; age: number; site: string let user: PickUser, name | site = name: wxw, site: whbbit.cn // 获得的新类型为 name: string, site: string Partial将属性类型转为可选 type User = name: string; age: number; site: string const user: PartialUser = // 获得的新类型为 name?:string; age?:number; site?: string Record快速生成具有属性的类型 type User = Recordstring, string | number// 获得的新类型为 [x: string]: string | number keyofinfer"},{"title":"Decorators 装饰器","path":"/wiki/frontNotes/ts_装饰器.html","content":"代码来自后盾网 装饰器为 ts 提供了强大的代码复用功能 使用装饰器需要在 tsconfig.json 中修改 装饰器是试验性的功能，需要在配置文件中开启 tsconfig.jsonexperimentalDecorators: true,emitDecoratorMetadata: true 类装饰器 ClassDecorator相当于在原型对象上添加属性 类装饰器只有一个参数，是构造函数。 const moveDecorator: ClassDecorator = (target: Function) = console.log(target) target.prototype.getPosition = (): x: number; y: number = return x: 20, y: 20 @moveDecoratorclass Player @moveDecoratorclass Tank const player = new Player()console.log(player.getPosition()) 装饰器语法糖 @不使用语法糖，需要传递类到对应的函数中。使用语法糖不需要手动调用。 const moveDecorator: ClassDecorator = (target: Function) = console.log(target) target.prototype.getPosition = (): x: number; y: number = return x: 20, y: 20 // 不使用语法糖class Player moveDecorator(Player)// 使用语法糖@moveDecoratorclass Tank const player = new Player()console.log(player.getPosition()) 装饰器叠加可以使用多个装饰器 const moveDecorator: ClassDecorator = (target: Function) = target.prototype.getPosition = () = console.log(获取位置) const MusicDecorator: ClassDecorator = (target: Function) = target.prototype.playMusic = () = console.log(音乐播放) @moveDecoratorclass Player const player = new Player()player.getPosition()@MusicDecorator@moveDecoratorclass Tank const tank = new Tank()tank.playMusic()tank.getPosition() 实例：全局消息响应const MessageDecorator: ClassDecorator = (target: Function) = target.prototype.sendMessage = (message: string, type: success | error = success) = return message, type, @MessageDecoratorclass LoginController login() console.log(登录业务处理) setTimeout(() = this.sendMessage(登录成功) , 2000) new LoginController().login() 装饰器工厂根据不同的条件返回不同的装饰器 const MusicDecorator = (type: string): ClassDecorator = switch (type) case player: return (target: Function) = target.prototype.playMusic = () = console.log(play player music) case tank: return (target: Function) = target.prototype.playMusic = () = console.log(play tank music) default: return (target: Function) = target.prototype.playMusic = () = console.log(play other music) @MusicDecorator(player)class Player new Player().playMusic()@MusicDecorator(tank)class Tank new Tank().playMusic() 方法装饰器const ShowDecorator: MethodDecorator = (...args: any[]) = console.log(args) /** 打印参数： [0]: 如果是静态函数就是构造函数，如果是普通方法就是其原型对象 [1]: 使用装饰器的方法名称 [2]: 方法属性的描述 [ User: , show, value: [Function (anonymous)] // 函数的内容 writable: true, enumerable: false, configurable: true ] */class User @ShowDecorator public show() 可以使用函数装饰器更改函数的内容 const ShowDecorator: MethodDecorator = (...args: any[]) = console.log(args) args[2].value = () = console.log(ShowDecorator changed) class User @ShowDecorator public show() console.log(show function ) new User().show() // 打印 ShowDecorator changed，函数内容已经被更改 上面那样使用数组接收后调用不是很直观，我们可以使用变量名接收方法装饰器参数 const ShowDecorator: MethodDecorator = (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = ... ; const ShowDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = descriptor.value = () = console.log(ShowDecorator changed) class User @ShowDecorator public show() console.log(show function ) new User().show() // 打印 ShowDecorator changed，函数内容已经被更改 调用装饰器时，也可以更改静态方法的内容 const ShowDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = descriptor.value = () = console.log(ShowDecorator changed) class User @ShowDecorator public static show() console.log(show function ) User.show() // 打印 ShowDecorator changed，函数内容已经被更改 调用 writable = true 控制方法不能重新声明 const ShowDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = descriptor.value = () = console.log(ShowDecorator changed) descriptor.writable = falseclass User @ShowDecorator public static show() console.log(show function ) User.show() // 打印 ShowDecorator changed，函数内容已经被更改User.show = () = console.log(重写show方法)User.show() 示例：模拟代码高亮可以先使用变量将函数内容保存起来，在自定义操作后直接调用保存的函数 const HighlightDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value descriptor.value = () = return `div style=background: red;$method()/div` class User @HighlightDecorator public show() return js code new User().show() 示例：结合装饰器工厂实现延迟执行const SleepDecorator = (times: number = 2000): MethodDecorator = return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value descriptor.value = () = setTimeout(() = method() , times) class User @SleepDecorator(3000) public show() console.log(wxw) new User().show() 示例：全局异常处理const ErrorDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value descriptor.value = () = try method() catch (e) // 函数中抛出的错误在这里进行处理 console.log(%c异常处理, color: green;) console.log(`%c$e`, color: red) class User @ErrorDecorator find() throw new Error(出错了) new User().find() 示例：根据权限限制访问可以根据传入的权限数组进行判断用户是否有访问权限 type UserType = name: string; isLogin: boolean; permissions: string const user = name: wxw, isLogin: true, permissions: [admin, member],const AccessDecorator = (keys: string[]): MethodDecorator = return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value const validate = () = keys.every((k) = user.permissions.includes(k)) descriptor.value = () = // 控制用户登录并且有权限才可访问 if (user.isLogin validate() === true) console.log(验证通过) method() return else console.log(验证失败) return false class User @AccessDecorator([admin]) find() console.log(find function) new User().find() 属性装饰器接收的参数 args[0]: target 静态参数就是构造函数，普通参数就是其原型对象 args[1]: propertyKey 属性名称 args[2]: undefined const PropDecorator: PropertyDecorator = (target: Object, propertyKey: string | symbol) = console.log(target, propertyKey)class User public username: string 实例：使用属性装饰器动态改变对象属性将属性改为全部大写 const UpperDecorator: PropertyDecorator = (target: Object, propertyKey: string | symbol) = let value: string = undefined //在这里使用Object.defineProperty对原数据进行更改 Object.defineProperty(target, propertyKey, get() return value.toUpperCase() , set(v) value = v , )class Article @UpperDecorator public title: string | undefinedconst article = new Article()article.title = article titleconsole.log(article.title) 参数装饰器接收的参数 args[0]: target 静态参数就是构造函数，普通参数就是其原型对象 args[1]: propertyKey 属性名称 args[2]: parameterIndex 参数所在的位置，从 0 开始计数 const ParamDecorator: ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) = console.log(target, propertyKey, parameterIndex)class User show(id: number, @ParamDecorator user: name: string ) 装饰器执行顺序:参数装饰器 - 方法装饰器"},{"title":"初识Vue3","path":"/wiki/frontNotes/vue_index.html","content":"https://cn.vuejs.org/https://cn.vuejs.org/ 前端路由 多页面和单页面的区别： 多页面使用多个 HTML 切换页面内容向服务器请求新的 HTML 文件来切换新的内容 单页面使用单个 HTML，通过 JS 切换页面内容 多页面应用和路由多个 HTML 之间的跳转组成了多页面路由 单页面应用和路由单个 HTML 页面根据 js 切换页面内容 hash 和 history 模式的区别"},{"title":"凝聚态物理学习笔记！","path":"/wiki/ningjutai/index.html","content":"http://example.com/%3Cahref=https://zh.wikipedia.org/wiki/%E5%87%9D%E8%81%9A%E6%80%81%E7%89%A9%E7%90%86%E5%AD%A6>https://zh.wikipedia.org/wiki/%E5%87%9D%E8%81%9A%E6%80%81%E7%89%A9%E7%90%86%E5%AD%A6 为什么是 vscodevscode 是微软开源的免费的文本编辑器，被广泛地在前端工作中使用。它提供了丰富的插件供人们进行代码编写和文字工作。 可以满足我们平时的工作和学习，最吸引人的是它完全免费。 基础配置我们可以进行一些简单的配置来让 vscode 更加好用。在 settings.json 中可以做一些配置 editor.formatOnSave: true 上面这段配置表示在保存时进行代码格式化 editor.bracketPairColorization.enabled: true,editor.bracketPairColorization.independentColorPoolPerBracketType: true 上面这段配置表示开启括号对着色，可以让不同层级的括号展示不同的颜色。"},{"title":"设计","path":"/wiki/notes/design_index.html","content":"B 端设计主要内容 框架 排版 字体 色彩 控件 组件 icon B 端主要参数常用宽度 1440 1920 字体大小 min 12px base 14px 16px title 18px 常用布局 上下布局 左右布局 T 型布局 T 型布局常用参数 宽度 1440px 侧边栏 200 - 300px 顶栏 40 - 60px 最小颗粒度？8 * 8 px XYD Design 规范 来源：https://preline.co/ 内容层级关系 如何选择使用弹窗、抽屉或者跳转页面？https://www.bilibili.com/video/BV1Ve411M77i/?vd_source=6e32730b05dc719c9f21598867bef69d 原位编辑 - 气泡 - 弹窗 - 抽屉 - 页面跳转 复杂度 - 降低 独立性- 升高 草帽设计 移动端设计尺寸选择 ICON 绘制灵感 绘制灵感 和文字一起使用时，ICON 可以考虑从文字中提取 去除装饰，极简风格 保持线条宽度一致 使用基本几何形状拼接完成 系统 ICON 宽高 24*24 使用时需注意 居中问题 粗细问题 颜色感官一致 APCA https://www.myndex.com/APCA/ https://contrast.tools/"},{"title":"待办","path":"/wiki/sable/TODO.html","content":"O1 Sable Admin 1.0.0 正常 0% KR1 功能模块 新增功能内嵌其他网站设置界面全局Loading自定义权限指令，控制是否展示该元素标签页部分标签栏展示标签页内容缓存标签页动画标签页刷新等操作 正常 0% KR2 集成功能 ECharts示例权限管理代码提交校验，提交前检查 正常 0% KR3 monorepo 改造 正常 1% KR4 功能更改/优化 消息提示组件拖拽组件UnoCSS样式路由部分优化 正常 0%"},{"title":"快速开始","path":"/wiki/sable/index.html","content":"介绍运行环境配置 nodejs 版本需要在 14.x 以上 nodejs 是完全免费的，您不必为此支付任何资金 本项目使用 pnpm 作为包管理工具，建议使用 pnpm 进行依赖的安装及其他操作 前置知识 您需要了解 Vue3 的基础知识 ts 需要了解基础部分，您可以观看本站点的 TypeScript 基础 来对 ts 进行初步了解 需要会使用 git 进行代码拉取 如何加入 sable还在持续更新中，本项目欢迎您的参与。 本项目使用 MIT 开源协议，理论上您可以免费使用且不必担心版权问题。 代码获取与运行git clone git@github.com:Whbbit1999/sable.git 依赖安装 pnpm i 依赖安装后，可以使用以下命令启动项目 pnpm run dev 目录说明src 目录 srcapi 目录用来存放与后端交互的接口信息 srcassets 用来存放项目静态文件 srccomponents 目录放置自定义组件 srccomposables 放置 vue 可复用代码 srcenum 用来放置项目中的静态变量 srclayouts 用来放置项目布局文件 srcplugins 项目使用的插件的配置 srcrouter 路由及路由配置文件 srcstore pinia 公共数据 srcstyles 公共样式文件 srcutils 公共工具函数 srcviews 页面 其他目录 types 存放 ts 类型 vite 存放 vite 配置文件 public 项目公共静态资源 mock mock 数据接口"},{"title":"代码格式","path":"/wiki/sable/代码格式.html","content":"本项目集成了 eslint 、prettier 和 husky 对代码格式进行格式校验 代码校验使用 eslint 进行校验 pnpm run lint 代码格式化使用 prettier 自动格式化代码 pnpm run format 代码提交代码提交时需要按照commitlint来对提交信息进行格式化 type：commit 的类型； feat：新功能、新特性； fix: 修改 bug； perf：更改代码，以提高性能； refactor：代码重构（重构，在不影响代码内部行为、功能下的代码修改）； docs：文档修改； style：代码格式修改, 注意不是 css 修改（例如分号修改）； test：测试用例新增、修改； build：影响项目构建或依赖项修改； revert：恢复上一次提交； ci：持续集成相关文件修改； chore：其他修改（不在上述类型中的修改）； release：发布新版本； workflow：工作流相关文件修改。 # 示例1fix(global):修复checkbox不能复选的问题# 示例2 下面圆括号里的 common 为通用管理的名称fix(common): 修复字体过小的BUG，将通用管理下所有页面的默认字体大小修改为 14px# 示例3fix: value.length - values.length"},{"title":"单元测试","path":"/wiki/sable/单元测试.html","content":"本项目集成了 vitest 进行单元测试 编写测试文件任何使用*.test.[ts,js]或*.spec.[ts,js]的文件都可以被 vitest 进行测试 这里测试一下 env 函数是否会自动将.env文件中的变量进行类型转换 env.test.tsimport test, expect from vitestimport envs from ../envtest(env, () = expect(envs.VITE_ROUTE_AUTOLOAD).toBeTypeOf(boolean) expect(envs.VITE_BASE_URL).toBeTypeOf(string)) 测试pnpm test 查看测试覆盖率pnpm coverage"},{"title":"代码精简","path":"/wiki/sable/代码精简.html","content":"我们可以删除一些不需要的内容来完成对本系统体积的精简，这里我对每个模块需要删除的部分都列出来 视频播放组件删除依赖包 pnpm uninstall artplayer 删除 /src/components/Custom/VideoPlayer.vue rm -rf /src/components/Custom/VideoPlayer.vue 删除 /src/views/customComponents/player.vue rm -rf /src/views/customComponents/player.vue 删除 /router/modules/customComponents.ts 中的 videoPlayer 部分 path: videoPlayer, name: components.videoPlayer, component: () = import(@/views/customComponents/player.vue), meta: auth: true, menu: title: 视频播放器 , markdown 编辑器删除依赖包 删除 富文本编辑器删除依赖包 二维码组建删除依赖包 拖拽组建删除依赖包"},{"title":"使用 JSON 配置生成表格","path":"/wiki/sable/自定义表格.html","content":"基本用法 表格展示列默认为文本展示，可以设置为图片、标签、日期等展示方式。 可选值为： image | tags | date table.config.tsexport const UserTableField = makeColumn([ key: id, title: ID, width: 50 , key: name, title: 昵称, width: 100 , key: avatar, title: 头像, type: image, width: 100 , key: email, title: 邮箱 , key: tags, title: 标签, type: tags , key: created_at, title: 创建时间, type: date, width: 140 , key: updated_at, title: 更新时间, type: date, width: 140 ,] as RenderColumnType[]) 表格 action 操作列底层使用 h() 渲染 naive-ui 的按钮组件，可以自定义按钮的类型、大小、图标等属性。 其中 icon 可以使用安装好的 unocss 的 icon 组件，也可以使用 naive-ui 的 icon 组件。 使用 unocss icon 需使用 renderCustomIcon(系列名:图标名) 的形式，如 renderCustomIcon(carbon:edit) 系列名可参考 icones 使用 naive-ui icon 需要使用renderIcon(ICON组件)渲染，如 renderIcon(CashOutline)。 其余 props 可以参考 naive-ui 的按钮组件。 table.config.tsimport renderCustomIcon, renderIcon from @/utilsimport CashOutline from @vicons/ionicons5export const UserTableButton: TableButton[] = [ title: 编辑, command: edit, props: type: primary, quaternary: true, renderIcon: renderCustomIcon(carbon:edit), , , title: , command: disabled, props: type: warning, circle: true, quaternary: false, renderIcon: renderIcon(CashOutline), , , title: 删除, command: delete, props: type: error, quaternary: true, , ,] 默认配置pageSizesconfig/table.tsexport const pageSizes = [ label: 10 每页, value: 10 , label: 20 每页, value: 20 , label: 30 每页, value: 30 , label: 40 每页, value: 40 ,] props props 说明 类型 默认值 columns 表格列配置 RenderColumnType[] [] api 请求接口函数 () = Promiseany[] () = Promise.resolve([]) button 表格操作按钮配置 TableButton[] [] action 点击操作按钮触发的回调函数 (command: string, row: any) = void () = void 示例API 接口配置文件api/userApi.tsimport http from ../plugins/axiosexport async function userList(page = 1) return http.getIUserModel[]( url: `users?page=$page`, ) 表格配置文件config/table.tsimport renderCustomIcon, renderIcon from @/utilsimport CashOutline from @vicons/ionicons5export const UserTableField = makeColumn([ key: id, title: ID, width: 50 , key: name, title: 昵称, width: 100 , key: avatar, title: 头像, type: image, width: 100 , key: email, title: 邮箱 , key: tags, title: 标签, type: tags , key: created_at, title: 创建时间, type: date, width: 140 , key: updated_at, title: 更新时间, type: date, width: 140 ,] as RenderColumnType[])export const UserTableButton: TableButton[] = [ title: 编辑, command: edit, props: type: primary, quaternary: true, renderIcon: renderCustomIcon(carbon:edit), , , title: , command: disabled, props: type: warning, circle: true, quaternary: false, renderIcon: renderIcon(CashOutline), , , title: 删除, command: delete, props: type: error, quaternary: true, , ,] 主页面crud-table.vuescript setup lang=ts import userList from @/api/userApi import UserTableButton, UserTableField from @/config/table function handleActions(command: string, row: any) // TODO 点击操作后 if (command === edit) console.log(编辑, row) return if (command === delete) console.log(删除, row) return if (command === disabled) console.log(禁用, row) return /scripttemplate BasicTable :columns=UserTableField :api=userList :button=UserTableButton @action=handleActions //template 效果"},{"title":"布局设置","path":"/wiki/sable/布局设置.html","content":"布局文件在/src/layouts文件夹中，目前有 default 默认布局： SableAdmin 脚手架的主要布局，包含 左侧侧边栏、顶栏、底部 blank 空白布局：不需要左侧侧边栏的部分可以引入此布局 在路由配置文件中的使用一般一级路由为布局，下面是主布局和空白布局的示例 主布局 说明一般页面可以使用默认布局 import Layout from @/layouts/default/index.vueimport RouteRecordRaw from vue-routerexport default path: /editor, component: Layout, name: editor, meta: auth: true, menu: title: 编辑器, order: 2, showParentMenu: false, icon: ion:document, , type: layout, , children: [ path: base, name: editor.base, component: () = import(@/views/editor/base.vue), meta: menu: title: 富文本编辑器 , , path: markdown, name: editor.markdown, component: () = import(@/views/editor/markdown.vue), meta: permissions: [admin], menu: title: markdown编辑器 , , , ], as RouteRecordRaw 空白布局 说明错误页面或者不想使用主布局文件时使用 import BlankLayout from @/layouts/blank.vueimport RouteRecordRaw from vue-routerexport default path: /error, component: BlankLayout, name: error, meta: menu: show: true, title: 错误页面, order: 3, icon: ion:ios-close-circle, , type: layout, , children: [ path: 404, name: error.404, component: () = import(@/views/errors/404.vue), meta: menu: show: true, title: 404页面 , , path: 502, name: error.502, component: () = import(@/views/errors/502.vue), meta: menu: show: true, title: 502页面 , , ], as RouteRecordRaw"},{"title":"路由守卫","path":"/wiki/sable/路由守卫.html","content":"目前全局路由守卫在router/guards.ts文件中"},{"title":"路由设置","path":"/wiki/sable/路由设置.html","content":"路由设置文件在 /src/router/models/ 路由 meta 说明路由 meta 可以书写一些路由的属性，ts 配置文件在 /types/typings.d.ts import vue-routerdeclare module vue-router interface RouteMeta // 访问权限 auth?: boolean // 登录用户可访问 guest?: boolean // 游客可访问 permissions: string[] // 可访问权限 type: layout | menuItem // 菜单类型 // 和菜单相关 menu?: showParentMenu: boolean // 是否显示一级菜单， default = true title: string // 页面标题 icon: string // icon show?: boolean // 是否在菜单中显示 为false或不设置不在菜单中显示 default = true key?: string // 菜单唯一标识 order?: number // 菜单排序 keepAlive?: boolean // 是否可以缓存 showTag?: boolean // 是否在历史菜单中显示 default = true 自动引入在 /src/router/models/ 文件夹中放置的路由配置文件会被自动加载，无需在在别处引入 注意目前只支持文件类型，对文件夹的支持还未完成 外链本项目支持在路由侧展示外链，具体写法如下 该路由是外链时，path 字段即为该网址。该路由不会在历史菜单中显示！ 说明这里引入 Blank 空白布局是为了避免浏览器控制台中报错，你也可以引入任何一个视图文件来规避这个问题。 import Blank from @/layouts/blank.vueimport RouteRecordRaw from vue-routerexport default path: , component: () = import(@/layouts/default/index.vue), name: links, meta: menu: title: 外链, order: 99, showParentMenu: false, icon: ion:link , type: layout, , children: [ name: whbit, path: https://whbbit.cn, component: Blank, meta: menu: title: whbbit主页 , , name: vue, path: https://cn.vuejs.org/, component: Blank, meta: menu: title: vue官网, icon: logos:vue , , ], as RouteRecordRaw 多级路由适配多级路由适配已完成，可以根据路由配置文件自动生成多级菜单 说明只有一个子菜单时，会平铺到父级菜单中"},{"title":"参考系统","path":"/wiki/sable/项目优化.html","content":"Soybean Admin https://admin-docs.soybeanjs.cn/https://admin-docs.soybeanjs.cn/ 布局模式 左侧菜单模式 左侧菜单混合模式 顶部菜单模式 顶部菜单混合模式 系统主图颜色配置 菜单查询组件 图标选择器 Vben Admin https://doc.vvbin.cn/https://doc.vvbin.cn/ 系统锁屏 二维码组件 密码输入框 vue-element-plus-admin https://element-plus-admin-doc.cn/https://element-plus-admin-doc.cn/ JSON 编辑器 瀑布流"},{"title":"项目配置","path":"/wiki/sable/项目配置.html","content":"项目配置文件在 config 文件夹中，目前只有 config.ts 一个文件 export default menu: showChildrenRouteIcon: true, // 是否显示子路由图标 defaultRouteIcon: ion:book, // 子路由默认图标 , historyMenuMax: 10, // 历史菜单最大显示数量"},{"title":"辅助工具","path":"/wiki/sable/辅助工具.html","content":"本项目集成了 cli 工具，可以方便的创建对应的文件模块"},{"title":"mac软件","path":"/wiki/sites/mac软件.html","content":"MacWk精品mac软件下载MacBL马可菠萝 - 分享你喜欢的MAC应用Xclient精品MAC应用分享 mac 好用软件分享 鼠标平滑滚动- mos https://mos.caldis.me/https://mos.caldis.me/"},{"title":"网站收藏","path":"/wiki/sites/index.html","content":"这里包含有我收藏的一些好用的网站，具体分为以下几类： 网站维护数据统计类 电子书电子文档 开发相关资源 自媒体相关资源"},{"title":"其他","path":"/wiki/sites/其他.html","content":"在线简历制作https://www.mujicv.com/index.htmlhttps://www.mujicv.com/index.html"},{"title":"开发相关","path":"/wiki/sites/开发相关.html","content":"学习网站web.devhttps://web.dev/uiverse css案例https://uiverse.io/ GitHub 开源库离线IP地址定位库和IP定位数据管理框架https://github.com/lionsoul2014/ip2region编程学习路径https://roadmap.sh/markdown编辑器https://imzbf.github.io/md-editor-v3/docs视频播放插件 哔哩哔哩样式https://artplayer.org/document/ vue 组件库Element UIhttps://element.eleme.io/#/zh-CNElement Plushttps://element-plus.org/zh-CN/#/zh-CNAnt Design Vuehttps://antdv.com/components/overview-cnMaterial Design for Bootstrap 5 & Vue 3https://mdbootstrap.com/docs/vue/Vanthttps://vant-ui.github.io/vant/#/zh-CNVuetifyhttps://vuetifyjs.com/zh-Hans/Quasarhttps://quasar.dev/Naive UIhttps://www.naiveui.com/zh-CN/os-theme React 组件库MUIhttps://mui.com/zh/Ant Designhttps://ant.design/index-cnArco Designhttps://arco.designfluentuihttps://github.com/microsoft/fluentuidndkitreact 拖拽组件 cssCSS Loading效果https://loading.io/css/Tailwidcsshttps://tailwindcss.com/loadinghttps://cssloaders.github.io/daisyuihttps://daisyui.com/aceternityhttps://ui.aceternity.com/ 后端管理脚手架BuildAdminhttps://wonderful-code.gitee.io/Pure Adminhttps://yiming_chang.gitee.io/pure-admin-doc/DataV vue 支持 Vue3 + Vite 的 DataV 组件库https://datav-vue3.netlify.app/ 其他工具npmnpmmdnmdn字体下载编程字体下载网站百度翻译百度翻译谷歌翻译谷歌翻译Vue3项目初始模板antfu的Vue3项目初始模板vxe-table 高性能表格组件高性能表格，可以代替 antd-vue 的表格组建精灵图切图自动精灵图切图在线nginx配置在线nginx配置网站Puppeteer无头浏览器jsont 在线JSON验证和编辑在线JSON验证和编辑electron-vitehttps://cn.electron-vite.org/ 桌面端框架taurihttps://tauri.app/Wailshttps://wails.io/Electronhttps://www.electronjs.org/Nw.jshttps://nwjs.io/Flutter for Desktophttps://flutter.dev/multi-platform/desktop"},{"title":"站长工具","path":"/wiki/sites/站长工具.html","content":"百度统计网站访问次数统计谷歌统计谷歌网站统计"},{"title":"电子书/文档站点","path":"/wiki/sites/电子书.html","content":"Flutter实战·第二版https://book.flutterchina.club/Axioshttps://axios-http.com/Socket.IOhttps://socket.io/Rust 程序设计语言 中文版https://rustwiki.org/zh-CN/book/title-page.html语义化版本https://semver.org/lang/zh-CN/labuladong 的算法小抄https://github.com/labuladong/fucking-algorithmHTTPS的工作原理https://howhttps.works/zh/中医古籍http://www.mst1739.com/yidao/yuedu.php编程相关书籍https://github.com/justjavac/free-programming-books-zh_CN移动端开发啊https://github.com/hoosin/mobile-web-favorites程序员编程技艺https://github.com/julycoding/The-Art-Of-Programming-By-July-2nd腾讯前端代码编写规范http://alloyteam.github.io/CodeGuide/逐行剖析vuejs源码https://nlrx-wjc.github.io/Learn-Vue-Source-Code/算法通关手册（LeetCode）https://algo.itcharge.cn/"},{"title":"自媒体","path":"/wiki/sites/自媒体.html","content":"图片处理移除图片背景https://www.remove.bg/zh在线 pshttps://www.logosc.cn/online-ps免版权的高质量图库[unsplash]https://unsplash.com/矢量插画 unDrawhttps://undraw.co/illustrations头像生成https://ezshine.jnsii.com/cases/avatarbuilder/快速生成网站截图https://www.thum.io/ 颜色相关中国传统色http://zhongguose.com/色板materialuihttps://materialui.co/socialcolors/色板flatuicolorshttps://flatuicolors.com/palette/defo渐变色webgradientshttps://webgradients.com/渐变色webkulhttps://webkul.github.io/coolhue/colorhunthttps://colorhunt.co/颜色转换工具https://htmlcolorcodes.com/zh/colorbox色板https://colorbox.io/智能渐变工具https://mycolor.space/网页配色，可以直接预览效果https://palettemaker.com/ 设计相关dribbblehttps://dribbble.com/lordicon 动态iconhttps://lordicon.com/d.design 堆友https://d.design/yesicon快速查询ICON动态icon快速查询ICON配色生成https://randoma11y.com/ 音频相关日系音乐[魔王魂]https://maou.audio/category/bgm/freemusicarchivehttps://freemusicarchive.org/homesoundcloudhttps://soundcloud.com/lakeyinspired"},{"title":"vscode基础使用指南","path":"/wiki/vscode/index.html","content":"https://code.visualstudio.com/https://code.visualstudio.com/ 为什么是 vscodevscode 是微软开源的免费的文本编辑器，被广泛地在前端工作中使用。它提供了丰富的插件供人们进行代码编写和文字工作。 可以满足我们平时的工作和学习，最吸引人的是它完全免费。 基础配置我们可以进行一些简单的配置来让 vscode 更加好用。在 settings.json 中可以做一些配置 editor.formatOnSave: true 上面这段配置表示在保存时进行代码格式化 editor.bracketPairColorization.enabled: true,editor.bracketPairColorization.independentColorPoolPerBracketType: true 上面这段配置表示开启括号对着色，可以让不同层级的括号展示不同的颜色。"},{"title":"工具网站","path":"/wiki/vscode/工具网站.html","content":"vscode 代码片段生成 https://snippet-generator.app/?description=&tabtrigger=&snippet=&mode=vscodehttps://snippet-generator.app/?description=&tabtrigger=&snippet=&mode=vscode 二维码生成库https://qr-x.devtrice.dev/"},{"title":"编辑器美化","path":"/wiki/vscode/美化.html","content":"主题Vitesse Theme这个是 vue 团队成员 Anthony Fu 出品的主题，包含亮色和暗色两种主题。 https://marketplace.visualstudio.com/items?itemName=antfu.theme-vitessehttps://marketplace.visualstudio.com/items?itemName=antfu.theme-vitesse 下面是对应的图片预览 DevPro - High Contrast这个主题是高对比度中比较符合我心意的一款 https://marketplace.visualstudio.com/items?itemName=koprodev.theme-devpro-hchttps://marketplace.visualstudio.com/items?itemName=koprodev.theme-devpro-hc 文件图标file-iconshttps://marketplace.visualstudio.com/items?itemName=file-icons.file-iconshttps://marketplace.visualstudio.com/items?itemName=file-icons.file-icons Carbon Product Iconshttps://marketplace.visualstudio.com/items?itemName=antfu.icons-carbonhttps://marketplace.visualstudio.com/items?itemName=antfu.icons-carbon Catppuccin Icons for VSCode非常可爱的一款图标主题 https://marketplace.visualstudio.com/items?itemName=Catppuccin.catppuccin-vsc-iconshttps://marketplace.visualstudio.com/items?itemName=Catppuccin.catppuccin-vsc-icons"},{"title":"插件扩展","path":"/wiki/vscode/插件扩展.html","content":"这里包含了所有我使用的插件 通用插件WakaTime记录编码时间，可以比较准确地知道你一天都在哪些项目中工作了多长时间。 https://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatimehttps://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatime Error Lens在编辑器中显示当前行的错误信息 https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlenshttps://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens Better Comments提供 TODO 注释的高亮，支持自定义配置 https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-commentshttps://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments Code Runner提供多种编程语言的快速启动功能 https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runnerhttps://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner Docker提供 docker 语法提示和构建功能 https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-dockerhttps://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker Dyno File Utils快速创建文件 https://marketplace.visualstudio.com/items?itemName=dyno-nguyen.vscode-dynofileutilshttps://marketplace.visualstudio.com/items?itemName=dyno-nguyen.vscode-dynofileutils Git History可视化 git 时间线工具 https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistoryhttps://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory GitLens — Git superchargedvscode 中最好的 git 插件 https://marketplace.visualstudio.com/items?itemName=eamodio.gitlenshttps://marketplace.visualstudio.com/items?itemName=eamodio.gitlens Project Manager提供项目管理功能 https://marketplace.visualstudio.com/items?itemName=alefragnani.project-managerhttps://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager REST Client提供 restful 接口测试功能 https://marketplace.visualstudio.com/items?itemName=humao.rest-clienthttps://marketplace.visualstudio.com/items?itemName=humao.rest-client Tabnine AI Autocomplete for Javascript, Python, Typescript, PHP, Go, Java, Ruby more智能代码提示 https://marketplace.visualstudio.com/items?itemName=TabNine.tabnine-vscodehttps://marketplace.visualstudio.com/items?itemName=TabNine.tabnine-vscode 前端开发Live Server快速启动一个服务预览 html https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServerhttps://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer Auto Rename Tag提供同步修改对应标签的功能 https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-taghttps://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag DotENV.env 文件高亮 https://marketplace.visualstudio.com/items?itemName=mikestead.dotenvhttps://marketplace.visualstudio.com/items?itemName=mikestead.dotenv Element UI SnippetsElement UI 代码片段 https://marketplace.visualstudio.com/items?itemName=SS.element-ui-snippetshttps://marketplace.visualstudio.com/items?itemName=SS.element-ui-snippetshttps://marketplace.visualstudio.com/items?itemName=SS.element-ui-snippetshttps://marketplace.visualstudio.com/items?itemName=SS.element-ui-snippets ESLinthttps://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslinthttps://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint Prettier - Code formatterhttps://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscodehttps://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode Tailwind CSS IntelliSense提供 Tailwind CSS 的代码提示 https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcsshttps://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss vue2 插件开发 vue2 时，需要 Vetur 提供语法高亮和代码提示 https://marketplace.visualstudio.com/items?itemName=octref.veturhttps://marketplace.visualstudio.com/items?itemName=octref.vetur vue3 插件在使用 vue3 时，需要安装 volar 提供对 script setup 的语法高亮和代码提示 对应的插件有： 基础包 Vue Language Features (Volar) https://marketplace.visualstudio.com/items?itemName=Vue.volarhttps://marketplace.visualstudio.com/items?itemName=Vue.volar 对 ts 的扩展 TypeScript Vue Plugin (Volar) https://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-pluginhttps://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-plugin React 插件ES7+ React/Redux/React-Native snippets 提供 react 代码片段 https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippetshttps://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets JavaScript (ES6) code snippets可以根据对应的简写方式快速生成 es6 代码片段 https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippetshttps://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets vscode-styled-components提供 styled-components 语法高亮和提示 https://marketplace.visualstudio.com/items?itemName=styled-components.vscode-styled-componentshttps://marketplace.visualstudio.com/items?itemName=styled-components.vscode-styled-components svg提供 svg 预览和编辑功能 https://marketplace.visualstudio.com/items?itemName=jock.svghttps://marketplace.visualstudio.com/items?itemName=jock.svg Image preview在侧边栏预览当前引入的图片 https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-gutter-previewhttps://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-gutter-preview Import Cost查看当前引入 npm 包的大小 https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-costhttps://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost i18n Ally提供对 i18 的预览 https://marketplace.visualstudio.com/items?itemName=Lokalise.i18n-allyhttps://marketplace.visualstudio.com/items?itemName=Lokalise.i18n-ally Turbo Console Log使用快捷键ctrl options ls打印选中的值 服务器扩展有时我们需要连接服务器进行一些操作。我们可以下载对应的插件来直接操作服务器资源。下面的插件包含了 ftp 和 ssh 功能，可以直接连接服务器进行连接和文件上传。 Remote - SSHhttps://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-sshhttps://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh Remote - SSH: Editing Configuration Fileshttps://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh-edithttps://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh-edit Remote Explorerhttps://marketplace.visualstudio.com/items?itemName=ms-vscode.remote-explorerhttps://marketplace.visualstudio.com/items?itemName=ms-vscode.remote-explorer SFTPhttps://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftphttps://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp"},{"title":"配置项","path":"/wiki/vscode/配置.html","content":"保存时自动整理 importsettings.json 中加入配置项： “editor.codeActionsOnSave”: { “source.organizeImports”: true }, settings.json editor.codeActionsOnSave: source.organizeImports: true 可实现保存代码时（ctrl+s）自动整理页面所有 import 引用，包括删除未使用到的 import、多 import 归类整理、排序等。很好用。 使用连体字符我们平时在网上看别人视频时候会出现 = 连起来的样子，我们可以这样设置 settings.json editor.fontLigatures: true 必须配合支持连字效果的字体，这里推荐Fira code。 下面是配置好后的样式示例"},{"title":"NuxtUI示例","path":"/wiki/video-point/NuxtUI示例.html","content":"NuxtUI 是 Nuxt 团队出品的一套 UI 组件库。 从今天开始让我们一起来学习一下这套组件库要怎么使用吧。 环境搭建 – Nuxt3 环境搭建我们要先创建一个 Nuxt 项目 pnpm dlx nuxi@latest init nuxt-ui-template 进入项目并安装依赖 cd nuxt-ui-template pnpm i 安装 NuxtUI pnpm add @nuxt/ui 配置nuxt.config.ts nuxt.config.tsexport default defineNuxtConfig( modules: [@nuxt/ui],) 在 app.vue 中搞一个 button 组建看看先 app.vuetemplate div UButtonbutton/UButton /div/template 启动项目 pnpm run dev 如果出现了这个按钮，就说明我们成功配置了 NuxtUI。我们先看看 Nuxt 官方的几个项目来看下这个组件库有多好看吧。 实例预览voltaNuxtLabs组件配置 – 配置项配置我们可以创建一个 app.config.ts 作为 NuxtUI 的配置文件。可以配置组件的一些基本行为，像是按钮的圆角、颜色等。 我们这里配置一个经典的橙黑配色 app.config.tsexport default defineAppConfig( ui: primary: orange, gray: neutral, button: rounded: rounded-sm, , ,) 具体组件使用实战 – 我的世界资源站点具体实战部分我们跳转到下一个系列，我的世界资源站点"},{"title":"Stellar主题搭建个人站点","path":"/wiki/video-point/使用Stellar主题搭建个人站点.html","content":"参考文章 hexo 官网 https://hexo.io/zh-cn/node 官网 https://nodejs.org/zh-cngit 官网 https://git-scm.com/download/winStellar 主题主题文档 https://xaoxuu.com/wiki/stellar/彩虹猫图标 https://slackmojis.com/categories/25-blob-cats-emojis 前置知识markdown 基础可以参考markdown 基础进行观看。 这一节我们进行了 markdown 基础语法的学习，下一节我们就开始安装依赖搭建 搭建站点依赖安装 安装 nodejs访问 nodejs 官网 进行对应系统的下载。 下载 LTS长期维护版 版本即可 安装成功后可以在终端中使用node --version 和 npm --version 查看是否下载成功 安装 gitwindow 用户可以访问git 官网 进行安装mac 用户可以使用 homebrew 进行安装 brew install git 安装 hexo-cli安装 nodejs 后可以使用 npm 指令进行安装。 全局安装即可，可以省去配置环境变量的过程，对新手更加友好 npm i -g hexo-cli 到这一步，我们的环境已经搭建成功，下一节我们开始开始搭建个人站点 项目搭建上一节我们把所有依赖的环境都安装成功了，这一节我们开始使用 hexo 搭建个人站点 这节视频中，我们使用 my-site 作为我们的站点目录进行演示： 初始化项目hexo init my-site 启动项目 我们可以使用 npm 指令进行项目启动，也可以使用 hexo 进行启动。npm 指令可以在 package.json 文件中 scripts 中查看。这里我们使用 npm 指令启动项目。 npm run server 主题安装这里我们可以访问 Stellar 主题主题文档进行查看详细说明。或者跟着我的步骤操作 安装主题 npm i hexo-theme-stellar 更改主题在_config.yml中找到并修改 theme: stellar 我们再次启动项目，可以发现已经是 Stellar 的样子了。下一节我们进行站点配置，来个性化的定制各种页面。 站点配置配置文件一览Stellar 主题的配置文件我们可以去node_modules里查看。我们找到hexo-theme-stellar/_config.yml文件。这里就是 Stellar 主题支持的所有配置了。 Stellar主题配置 ######## Stellar info ########stellar: version: 1.19.0 homepage: https://xaoxuu.com/wiki/stellar/ repo: https://github.com/xaoxuu/hexo-theme-stellar cdn_css: # Use cdn links instead of /css/main.css cdn_js: # Use cdn links instead of /js/main.js######## head tags ########open_graph: enable: true twitter_id: # for open_graph meta######## Sidebar ########sidebar: logo: avatar: [config.avatar](/about/) # you can set avatar link in _config.yml or [https://xxx.png](/about/) title: [config.title](/) # you can set html tag like: [img no-lazy height=32px src=xxx/](/) menu: # post: [btn.blog](/) # wiki: [btn.wiki](/wiki/) # friends: [友链](/friends/) # about: [关于](/about/) # Sidebar widgets widgets: #### 自动生成的页面 #### # 主页 home: search, recent, timeline # for home # 博客索引页 blog_index: search_blog, recent, timeline # for categories/tags/archives # 文档索引页 wiki_index: search_docs, recent, timeline # for wiki # 其它（404） others: search, recent, timeline # for 404 and ... #### 手动创建的页面 #### # 文章内页 post: search_blog, toc, ghrepo, ghissues # for pages using layout:post # 文档内页 wiki: search, ghrepo, toc, ghissues, related # for pages using layout:wiki # 其它 layout:page 的页面 page: toc, search # for custom pages using layout:page######## Index ########post-index:# 近期发布 分类 标签 归档 and ... # 朋友文章: /friends/rss/######## Main ########breadcrumb: home: home # config.title / config.author / home or custom content######## Article ########article: # 如果没有指定封面，是否根据 tags 作为关键词搜索封面图片？ auto_cover: false # search from https://source.unsplash.com/ # 如果没有指定横幅，是否根据 tags 作为关键词搜索横幅图片？ auto_banner: false # search from https://source.unsplash.com/ # 如果没有指定 excerpt 和 description，将自动取多长的内容作为文章摘要？ auto_excerpt: 200 # 分类颜色 category_color: 探索号: #f44336 # 文章许可协议 license: 本文采用 [署名-非商业性使用-相同方式共享 4.0 国际](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。 # 分享 share: # [wechat, weibo, email, link] # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false max_count: 5search: service: local_search # local_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容######## Comments ########comments: service: # beaudar, utterances, giscus, twikoo, waline, artalk # beaudar # https://beaudar.lipk.org/ beaudar: repo: xxx/xxx issue-term: pathname issue-number: theme: preferred-color-scheme label: input-position: top # top/bottom 评论框位置 comment-order: desc # desc 排序 keep-theme: # true/false loading: false branch: main # utterances # https://utteranc.es/ utterances: repo: xxx/xxx issue-term: pathname issue-number: theme: preferred-color-scheme label: # giscus # https://giscus.app/zh-CN giscus: data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: lazy crossorigin: anonymous # Twikoo # https://twikoo.js.org/ twikoo: js: https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js # 建议锁定版本 envId: https://xxx # vercel函数 # Waline # https://waline.js.org/ waline: js: https://unpkg.com/@waline/client@2.14.1/dist/waline.js css: https://unpkg.com/@waline/client@2.14.1/dist/waline.css # Waline server address url, you should set this to your own link serverURL: # If false, comment count will only be displayed in post page, not in home page commentCount: true # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`. pageview: false # Custom emoji # emoji: # - https://unpkg.com/@waline/emojis@1.1.0/weibo # - https://unpkg.com/@waline/emojis@1.1.0/alus # - https://unpkg.com/@waline/emojis@1.1.0/bilibili # - https://unpkg.com/@waline/emojis@1.1.0/qq # - https://unpkg.com/@waline/emojis@1.1.0/tieba # - https://unpkg.com/@waline/emojis@1.1.0/tw-emoji # - https://unpkg.com/@waline/emojis@1.1.0/bmoji # 设置自己的图床服务，替换默认的 Base 64 编码嵌入（有体积大小限制），在评论中上传图片更加方便 # imageUploader: # 适配了兰空图床V1、V2版本 # 以兰空图床V1为例，下列填写内容为： # fileName: file # tokenName: Authorization # api: https://xxxxxx/api/v1/upload # token: Bearer xxxxxxxxxxxxxx # resp: data.links.url # 以兰空图床V2为例，下列填写内容为： # fileName: image # tokenName: token # api: https://xxxxxx/api/upload # token: xxxxxxxxxxxxxx # resp: data.url # fileName: # 根据版本二选一 # tokenName: # 根据版本二选一 # api: # 图床 api 地址 # token: # 图床验证 # resp: # 图片地址返回值的字段 # Artalk # https://artalk.js.org/ artalk: css: https://unpkg.com/artalk@2.4.3/dist/Artalk.css js: https://unpkg.com/artalk@2.4.3/dist/Artalk.js server: # 后端服务地址 placeholder: darkMode: auto######## Footer ########footer: social: # github: # icon: img src=https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/08a41b181ce68.svg/ # url: / # music: # icon: img src=https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/3845874.svg/ # url: / # unsplash: # icon: img src=https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/3616429.svg/ # url: / # comments: # icon: img src=https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/942ebbf1a4b91.svg/ # url: /about/#comments sitemap: # 博客: # - [近期](/) # - [分类](/) # - [标签](/) # - [归档](/) # 项目: # - [开源库](/) # 社交: # - [友链](/) # - [留言板](/) # 更多: # - [关于本站](/) # - [GitHub](/) content: | # 支持 Markdown 格式 本站由 [@anonymity](/) 使用 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar) 主题创建。 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。 # 主题用户越多，开发者维护和更新的积极性就越高，如果您喜欢本主题，请在适当的位置显示主题信息和仓库链接以表支持。######## Tag Plugins ########tag_plugins: # % ablock % / % note % note: default_color: # light, dark, red, orange, yellow, green, cyan, blue, purple, warning, error border: true # true / false # % checkbox % checkbox: interactive: false # enable interactive for user # % quot % quot: default: # 可以自行配置多种图标方案 prefix: https://bu.dusays.com/2022/10/24/63567d3e092ff.png suffix: https://bu.dusays.com/2022/10/24/63567d3e0ab55.png hashtag: prefix: https://bu.dusays.com/2022/10/24/63567d3e07da3.png # % emoji % emoji: default: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/$name.gif twemoji: https://gcore.jsdelivr.net/gh/twitter/twemoji/assets/svg/$name.svg qq: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/$name.gif aru: https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/$name.gif tieba: https://gcore.jsdelivr.net/gh/cdn-x/emoji/tieba/$name.png blobcat: https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/$name.png # % image % image: fancybox: false # true, false parse_markdown: true # 把 markdown 格式的图片解析成图片标签 # % timeline % timeline: max-height: 80vh # % mark % mark: default_color: dark # light, dark, red, orange, yellow, green, cyan, blue, purple, warning, error # % tag % tag: default_color: yellow # red, orange, yellow, green, cyan, blue, purple######## JS Plugins ########plugins: ## required plugins ## # jquery jquery: https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js # stellar api stellar: sites: /js/plugins/sites.js friends: /js/plugins/friends.js ghinfo: /js/plugins/ghinfo.js timeline: /js/plugins/timeline.js linkcard: /js/plugins/linkcard.js fcircle: /js/plugins/fcircle.js weibo: /js/plugins/weibo.js marked: https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js ## optional plugins ## # preload preload: enable: true service: flying_pages # instant_page, flying_pages instant_page: https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js flying_pages: https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js # image lazyload # https://www.npmjs.com/package/vanilla-lazyload lazyload: enable: true # [hexo clean hexo s] is required after changing this value. js: https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js transition: blur # blur, fade # https://scrollrevealjs.org/api/reveal.html scrollreveal: enable: #true js: https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js distance: 8px duration: 500 # ms interval: 100 # ms scale: 1 # 0.1~1 # https://fancyapps.com/docs/ui/fancybox/ # available for % image xxx % fancybox: enable: true js: https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js css: https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css # 可以处理评论区的图片（不支持 iframe 类评论系统）例如： # 使用twikoo评论可以写: .tk-content img:not([class*=emo]) # 使用waline评论可以写: #waline_container .vcontent img selector: .swiper-slide img # 多个选择器用英文逗号隔开 # swiper swiper: enable: true css: https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css js: https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js # 赫蹏 (Heti) - 专为中文网页内容设计的排版样式增强 # https://github.com/sivan/heti heti: enable: false # 此插件会和代码块冲突，仅适用于纯中文博主。 css: https://unpkg.com/heti@0.9.2/umd/heti.min.css js: https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js # MathJax # 需在Markdown文件开头加入mathjax: true # 推荐使用Pandoc: npm uninstall hexo-renderer-marked --save npm install hexo-renderer-pandoc --save mathjax: enable: false cdn: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML # Katex - The fastest math typesetting library for the web # https://katex.org/docs/autorender.html # https://github.com/KaTeX/KaTeX # 使用 hexo-renderer-markdown-it-plus 作为公式渲染器：npm uninstall hexo-renderer-marked --save npm install hexo-renderer-markdown-it-plus --save katex: enable: false min_css: link rel=stylesheet href=https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous min_js: script defer src=https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous/script auto_render_min_js: script defer src=https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymousonload=renderMathInElement(document.body);/script # Mermaid - markdwon to flow chart, seq chart, class chart ... # 需要安装 npm install --save hexo-filter-mermaid-diagrams # 使用时 需要在Markdown文件开头加入 mermaid: true # 使用示例： # ```mermaid # graph LR # A(Section A) --|option 1| B(Section A) # B --|option 2| C(Section C) # ``` mermaid: enable: false # js: https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js js: https://cdn.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js # Available themes: default | dark | forest | neutral # 推荐使用 dark 主题 在夜间模式下显示效果更好 theme: dark # 代码块复制按钮 copycode: enable: true js: /js/plugins/copycode.js default_text: Copy success_text: Copied # AI 摘要 # https://github.com/zhheo/Post-Abstract-AI tianli_gpt: enable: false field: post # all, post, wiki api: 5Q5mpqRK5DkwT1X9Gi5estyle: darkmode: auto # auto / always / false smooth_scroll: true # true / false font-size: root: 16px body: .9375rem # 15px code: 85% # 14px codeblock: 0.8125rem # 13px font-family: logo: system-ui, Microsoft Yahei, Segoe UI, -apple-system, Roboto, Ubuntu, Helvetica Neue, Arial, WenQuanYi Micro Hei, sans-serif body: system-ui, Microsoft Yahei, Segoe UI, -apple-system, Roboto, Ubuntu, Helvetica Neue, Arial, WenQuanYi Micro Hei, sans-serif code: Menlo, Monaco, Consolas, system-ui, Courier New, monospace, sans-serif codeblock: Menlo, Monaco, Consolas, system-ui, Courier New, monospace, sans-serif text-align: left border-radius: card: 12px block: 12px bar: 6px image: 6px color: # 动态颜色（会根据明暗主题重设明度值，只用关心色相和饱和度即可） background: hsl(212 16% 98%) # 浅色背景颜色 block: hsl(212 8% 95%) # 块背景颜色 code: hsl(14 100% 48%) # 行内代码颜色 text: hsl(0 0% 20%) # 文本颜色 # 主题色配置（不会根据明暗动态调整，请设置为通用的颜色） theme: hsl(192 98% 55%) # 主题色 accent: hsl(14 100% 57%) # 强调色 link: hsl(207 90% 54%) # 超链接颜色 button: hsl(192 98% 55%) # 按钮颜色 hover: hsl(14 100% 57%) # 按钮高亮颜色 animated_avatar: animate: auto # auto, always background: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp codeblock: scrollbar: 4px highlightjs_theme: https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/atom-one-dark.min.css loading: loading: 正在加载 error: 加载失败，请稍后重试。 gradient: # https://webgradients.com/ start: linear-gradient(to right, hsl(215, 95%, 64%), hsl(195, 95%, 60%), hsl(165, 95%, 56%), hsl(165, 95%, 56%), hsl(195 95% 60%), hsl(215, 95%, 64%)) search: linear-gradient(to right, #04F3FF, #08FFC6, #DDF730, #FFBD19, #FF1FE0, #C418FF, #04F3FF)default: avatar: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/3442075.svg link: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/link/8f277b4ee0ecd.svg cover: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/cover/76b86c0226ffd.svg image: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svgapi_host: ghapi: https://api.github.com ghraw: https://raw.githubusercontent.com gist: https://gist.github.com 各配置项功能说明我们自己在项目根目录中创建一个_config.stellar.yml文件用于项目配置。一般我们只需要更改 sidebar 和 footer 部分即可 _config.stellar.yml 文件配置我们可以去 node_modules/hexo-theme-stellar/_config.yml 找到啊 stellar 项目的原始配置文件，复制到我们创建的_config.stellar.yml文件中。然后在此基础上进行改动 一般我们需要改动的只有sidebar部分和footer部分。 sidebar 部分我们需要配置网站的侧边栏 sidebar: menu: post: [btn.blog](/) wiki: [专栏](/wiki/) notes: [导航](/notes/) more: [关于](/about/) 我们也可以在 sidebar 部分配置每个页面需要出现的小部件。自定义的小部件需要我们在 widgets.yml 文件中声明 sidebar: widgets: #### 自动生成的页面 #### # 主页 home: search, welcome, recent, ad, tagcloud, timeline # for home # 博客索引页 blog_index: search_blog, recent, ad, timeline # for categories/tags/archives # 文档索引页 wiki_index: search_docs, recent, ad, timeline # for wiki # 其它（404） others: search, welcome, recent, timeline # for 404 and ... #### 手动创建的页面 #### # 文章内页 post: toc, ghrepo, search, ghissues, ad # for pages using layout:post # 文档内页 wiki: search, ghrepo, toc, ad, ghissues, related # for pages using layout:wiki # 其它 layout:page 的页面 page: welcome, toc, ad # for custom pages using layout:page 当我们需要添加一个底部站点导航时，我们需要在footer部分添加sitemap footer: sitemap: 博客: - [近期](/) - [分类](/categories/) - [标签](/tags/) - [归档](/archives/) 专栏: - [vscode基础配置](/wiki/vscode/index.html) - [typescript基础](/wiki/typescript/index.html) 更多: - [友链](/) - [关于本站](/about/) - [文档站点](http://doc.whbbit.cn) - [GitHub](https://github.com/Whbbit1999) 自定义小部件在widgets.yml文件中，我们可以定义一些小组件。官方定义的我们直接粘贴就行。这里我说一下自定义小组件 ad: layout: markdown title: 可能是广告位吧🤨 content: | [![sable-admin-ad.jpg](/assets/sable-admin-ad.jpg)](https://github.com/Whbbit1999/sable) 创建独立页面在 widgets.yml 中创建对应的 widgets Notes: name: 笔记 title: 笔记 description: 一个隐藏项目：笔记 index: false # sidebar: [toc] tags: 知识库 sections: 日常问题解决方案: [100, 199] 移动端开发笔记: [200, 299] 前端学习笔记: [300, 399] 在线工具: [400, 499] 添加后，可以在_config.stellar.yml中添加对应的 sidebar sidebar: ... menu: ... notes: [笔记](/notes/) 创建对应的文件夹（文件夹名需要对应路径），这里需要创建对应的 notes 文件夹 如果你有 wiki 页面并且不想让它出现在 wiki 页面中时，可以在projects.yml中添加 Notes: index: false 接下来你就可以在对应的目录下书写对应的内容了。 添加友链需要注意将 actions 的权限更改为可以写入内容 高级功能自定义 js 脚本这里我们实现一个谷歌统计和百度统计脚本 use strict// 百度统计和google 统计hexo.extend.injector.register(body_end, function () return `script var _hmt = _hmt || []; (function() var hm = document.createElement(script); hm.src = https://hm.baidu.com/hm.js?31181a38d70c8faf2c5bed0d93cab07b; var s = document.getElementsByTagName(script)[0]; s.parentNode.insertBefore(hm, s); )(); /script script async=async src=https://www.googletagmanager.com/gtag/js?id=G-FTR5YKFFCM/script script window.dataLayer = window.dataLayer || []; function gtag()dataLayer.push(arguments); gtag(js, new Date()); gtag(config, G-FTR5YKFFCM); /script `) 使用 GitHub pages 部署博客使用 GitHub + vercel 部署使用 GitHub + GitHub Actions + 服务器进行本地化部署"},{"title":"我的世界资源站点实战","path":"/wiki/video-point/我的世界资源站点.html","content":"技术选型 前端前端使用 Nuxt3 进行项目开发 后端后端使用 nestjs 进行项目开发，数据库管理使用 Prisma 数据库数据库使用 postgresql 前端开发环境搭建后端开发环境搭建"},{"title":"为什么要做技术视频","path":"/wiki/video-point/index.html","content":"为什么要做技术视频？ 巩固自己学到的知识 在准备视频时需要熟悉各种知识 名声 可以在网上获得一些赞许 更好的工作机会 增加曝光，可以获得更好的工作机会或者拿到一些项目 方向主要做 JavaScript 生态的一些内容，包括： 原生三件套：JS、HTML、CSS vue 生态：vue、nuxt、uniapp react 生态：react、next nodejs：nodejs、express、nest electron 主要方向是项目实战。后端使用 nodejs ，数据库使用 mongodbmysqlpgsql ，前端使用 vuereact 等进行项目复刻。"}]