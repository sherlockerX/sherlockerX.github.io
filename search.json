[{"title":"翻译：在 Vue 中使用 URL 存储状态","path":"/2024/12/17/vue-Using-URL-to-store-state-in-Vue/","content":"受到 Lee Robinson 关于在 React Next.js 应用程序中使用 URL 存储状态的帖子的启发（您可以查看https://x.com/leeerob/status/1708280997488333078?s=20 ），我决定写这篇文章我将向您展示如何使用 URL 来保存状态。 通常，开发人员（包括我自己：D）使用 ref() 、 reactive() 甚至 computed() 来存储可以通过 URL 查询或参数轻松处理的状态。 来源： https://d186loudes4jlv.cloudfront.net/http/images/query_string_components.png 在本文中，我想向您展示如何在 Vue 应用程序中利用这个强大的浏览器原生功能 🚀 代码要在 Vue 应用程序中使用查询参数，最简单的方法是使用 Vue Router 的 push 方法： script lang=ts setup import useRouter from vue-router const push = useRouter()/script 稍后可以在发生某些事件（例如单击按钮）后在应用程序中使用此路由器方法，将状态保存到 URL 查询参数： const saveUserNameToQuery = (name: string) = push( query: username: name, , ) 要仅更改某些查询参数，同时将其余查询参数保持在相同状态，请使用以下命令： const currentRoute, push = useRouter()const updateQueryState = (parameter: string, value: string) = push( query: ...currentRoute.value.query, [parameter]: value, , ) 要在某些条件后重置查询参数，您可以使用以下方法： const resetQuery = () = push( query: , ) 您可以使用 Vue Router 做更多的事情，但我想展示这一点，因为我最近使用它来开发一项新功能和一个全新的项目。 https://router.vuejs.org/ 概括就是这样！您已成功学习如何使用 Vue Router 轻松修改 URL 状态并更新查询参数。这是一个非常有用的功能，我每天都在使用，强烈建议您尝试:)"},{"title":"翻译：Vue 可组合项的良好实践和设计模式","path":"/2024/12/15/vue-Good-practices-and-Design-Patterns-for-Vue-Composables/","content":"最近，我与 Vue Storefront 的团队就编写 Vue 可组合项的模式进行了一次精彩的讨论。就我们的系统而言，可组合项负责存储主要业务逻辑（如计算、操作、流程），因此它们是应用程序的关键部分。不幸的是，随着时间的推移，我们没有那么多时间来创建某种 Contract for writing Composables 因为我们的一些可组合项并不是真正的可组合项 😉 我真的很高兴现在我们有时间重构我们构建新可组合项的方法，以便它们可维护、易于测试且真正有用。 在本文中，我将总结我们创建的想法，并将它们与我在几篇文章中读到的良好实践和设计模式相结合。 所以本文将分为三个部分： 通用设计模式 我的建议 进一步阅读 享受并且让我知道您在项目中使用的模式和实践 🚀 通用设计模式我认为了解构建可组合项模式的最佳来源实际上是 Vue.js 文档，您可以在此处查看 基础可组合项Vue 文档显示了以下 useMouse 可组合项的示例： // mouse.jsimport ref, onMounted, onUnmounted from vue// by convention, composable function names start with useexport function useMouse() // state encapsulated and managed by the composable const x = ref(0) const y = ref(0) // a composable can update its managed state over time. function update(event) x.value = event.pageX y.value = event.pageY // a composable can also hook into its owner components // lifecycle to setup and teardown side effects. onMounted(() = window.addEventListener(mousemove, update)) onUnmounted(() = window.removeEventListener(mousemove, update)) // expose managed state as return value return x, y 你可以在组件中使用它，如下所示： script setup import useMouse from ./mouse.js const x, y = useMouse()/scripttemplateMouse position is at: x , y /template 异步可组合项为了获取数据，Vue 建议使用以下可组合结构： import ref, watchEffect, toValue from vueexport function useFetch(url) const data = ref(null) const error = ref(null) watchEffect(() = // reset state before fetching.. data.value = null error.value = null // toValue() unwraps potential refs or getters fetch(toValue(url)) .then((res) = res.json()) .then((json) = (data.value = json)) .catch((err) = (error.value = err)) ) return data, error 然后可以在组件中使用它，如下所示： script setup import useFetch from ./useFetch.ts const data, error = useFetch(...)/script 可组合项约定根据上面的示例，以下是所有可组合项都应遵循的约定： 可组合文件名应以 use 开头，例如 useSomeAmazingFeature.ts 它可以接受输入参数，这些参数可以是字符串等基本类型，也可以接受 refs 和 getter，但它需要使用 toValue 帮助器 可组合项应该返回一个 ref 值，该值可以在解构可组合项后访问，例如 const { x, y } = useMouse() 可组合项可以保存可以在应用程序中访问和修改的全局状态。 可组合性可能会导致副作用，例如添加窗口事件侦听器，但应在卸载组件时清除它们。 可组合项只能在 script setup 或 setup() 挂钩中调用。它们也应该在这些上下文中同步调用。在某些情况下，您还可以在生命周期挂钩中调用它们，例如 onMounted() 。 可组合项可以调用内部的其他可组合项。 可组合项应在内部包装某些逻辑，当过于复杂时，应将它们提取到单独的可组合项中以便于测试。 我的建议我已经为我的工作项目和开源项目构建了多个可组合项 - NuxtAlgolia、NuxtCloudinary、NuxtMedusa，因此基于这些，我想根据我的经验在上面的合同中添加一些要点。 有状态或和纯函数可组合项在代码标准化的某个时刻，您可能会得出这样的结论：您希望对可组合项中的状态保留做出决定。 最容易测试的函数是那些不存储任何状态的函数（即它们是简单的输入输出函数），例如负责将字节转换为人类可读值的可组合函数。它接受一个值并返回一个不同的值 - 它不存储任何状态。 不要误会我的意思，您不必做出决定 OR 。您可以完全保留有状态和无状态可组合项。但这应该是一个书面决定，以便以后更容易与他们合作 🙂 可组合项的单元测试我们希望使用 Vitest 为我们的前端应用程序实施单元测试。在后端工作时，进行单元测试代码覆盖率非常有用，因为您主要关注逻辑。然而，在前端，您通常使用视觉效果。 因此，我们认为对整个组件进行单元测试可能不是最好的想法，因为我们基本上将对框架本身进行单元测试（如果按下按钮，检查状态是否更改或模式是否打开）。 由于我们已将所有业务逻辑移至可组合项（基本上是 TypeScript 函数）内，因此它们很容易使用 Vitest 进行测试，并允许我们拥有更稳定的系统。 限制可组合项的范围不久前，在 VueStorefront 中，我们开发了自己的可组合方法（早在它们实际上像这样被调用之前）。在我们的方法中，我们使用可组合项来映射电子商务的业务领域，如下所示： const cart, load, addItem, removeItem, remove, ... = useCart() 这种方法绝对有用，因为它允许将域包装在一个函数中。在 useProduct 或 useCategory 等更简单的示例中，实现和维护相对简单。然而，正如您在 useCart 的示例中所看到的，当包装一个包含更多逻辑而不仅仅是数据获取的域时，这个可组合项正在发展成为一种非常难以开发和维护的形状。 此时，我开始为 Nuxt 生态系统做出贡献，其中引入了不同的方法。在这种新方法中，每个可组合项仅负责一件事。因此，我们的想法不是构建一个巨大的 useCart 可组合项，而是为每个功能构建可组合项，即 useAddToCart 、 useFetchCart 、 useRemovefromCart 等。 因此，维护和测试这些可组合项应该更容易 🙂 进一步阅读这将是我的研究的全部内容。如果您想了解有关此主题的更多信息，请务必查看以下文章： https://vuejs.org/guide/reusability/composables.html https://www.youtube.com/watch?v=bcZM3EogPJE https://vueschool.io/articles/vuejs-tutorials/what-is-a-vue-js-composable/ https://blog.logrocket.com/getting-started-vue-composables/ https://macopedia.com/blog/news/how-can-vue-3-composables-make-your-life-easier"},{"title":"翻译：编写更简洁的Vue.js代码的10个技巧","path":"/2024/12/15/vue-cleaner-vue-code/","content":"本文翻译至10 Tips to Write Cleaner Vue.js Code。 当从一个项目过渡到另一个项目时（例如换工作时），总有那么一段时间我需要适应新的项目流程和开发流程。 对于某些项目来说，有些东西是独一无二的，但是在 Vue 中，有些东西被认为是构建干净且可维护的基于 Vue 的项目的良好实践。 在本文中，我想列出这些最佳实践，以便您可以开始在 Vue 项目中使用它们:) 干净且可维护的代码是任何成功应用程序的支柱。Vue.js 凭借其直观的 API，可以轻松编写干净的代码，但总有改进的空间。这里有 10 个可操作的技巧，可以帮助您编写更简洁的 Vue.js 代码。 1. 明智的使用 Composition API将大型逻辑分解为更小的、可重用的可组合项，以保持模块化和可读性。 示例：不要将所有的逻辑都塞进 setup() 函数中，而是为不同的功能创建自定义钩子。 2. 遵循 Vue 的命名规定使用 PascalCase 作为组件文件名，并可以选择使用kebase-case作为模板使用。 示例：将您的组件命名为 UserProfile.vue 并将其作用于模板中的UserProfile / 或 user-profile / 3. 避免过度使用 Vuex 或 Pinia将 UI 状态（例如：弹窗的可见性）保留在组件本地，而不是在全局状态管理中。 示例： 使用 ref 或 reactive 进来表示临时状态。 4. 有效利用插槽使用具名插槽可以提高可重用组件的灵活性并可以清晰的表明使用情况。 示例：在 Card 组件创建一个带有 slot name=header / 的组件可以用于创建自定义头部。 5. 利用 scoped 限制 css 作用区域在style scoped标签上添加 scoped 使用作用域样式来防止 css 冲突。 示例：应用于特定组件的样式而不影响应用程序中其他部分的样式。 6. 编写可复用组件将 UI 元素分解为可重用的、集中的组件，避免过于通用的设计。 示例：创建一个支持不同样式的 props 的可配置 Button 组件，而不是对按钮进行硬编码。 7. 优雅的处理异步代码使用async/await进行 API 调用并使用一个『全局处理器』来处理错误。 示例： 创建一个useApicomposable 来封装 API 请求逻辑和错误处理逻辑。 8. 使用 Typescript 标记 Props 和 Emit 事件使用 Typescript 类型来清晰的定义 props 和 Emit 事件。 示例：在 Vue3 中可以使用defineProps 和 defineEmit 9. 添加自动格式化插件添加 ESLint 或者 Prettier 并使用特定的规则对您的代码进行格式化和质量检查，以增强代码质量和一致性。 示例：将 linting 集成到 CICD 中，并自动执行代码审查。 10. 在模板（template）中保持简单避免在 template 中放置复杂的逻辑，使用计算属性或者方法。 示例：将 v-if=list.filter(item = item.active).length 0的逻辑替换为计算属性。 总结通过遵循这些技巧，您将创建更易于维护、扩展和可调试的 Vue.js 应用程序。干净的代码不仅有利于当前的项目，也有利于未来可能维护该项目的开发人员。今天就开始做起，试试其中的一些做法。 保重，下次再见！ 一如既往的保持愉快的心情来编码吧！"},{"title":"Rsbuild创建项目","path":"/2024/12/08/rsbuild创建项目/","content":""},{"title":"组件设计 -- 父子组件调用时使用props还是ref？","path":"/2024/11/26/components-ref-or-props/","content":"关于组件设计的一点思考。 最近在和朋友讨论一个问题，感觉蛮有趣的。他写程序时间没我长，所以有一些问题会和我一起讨论，在这期间，常常会给我带来另一种角度来看待某个问题。 比如今天我们要讨论的一个组件要调用另一个组件的时候，我们该使用 props 传递让子组件来处理还是直接在父组件中通过 ref 调用子组件的函数。 毫无疑问的说，我是更加倾向于 props 传递，具体状态改变或者函数调用交于子组件处理的。 优缺点比较我们先来说明一下两者的优缺点： 通过 ref 调用子组件的方法 优点 可以直接调用子组件方法 方便直接控制子组件行为 缺点 耦合度高：父组件使用时强依赖于子组件暴露的方法 可维护性差：多次用到需要在不同的代码里维护想通的调用方式 可读性差 通过 props 传递 优点 耦合度低，只依赖于 props 的状态 可维护性强 可测试性高 缺点 灵活性差 可能需要传递大量的状态 思考下面我来说下我对于此观点的思考： 从代码耦合度方面考虑，props 传递明显是好于通过 ref 调用组件方法的； 从维护方面来看，通过 props 传递可以明确数据流向，容易理解； 从容易使用方面来看，通过 ref 调用组件方法是有好处的，但这仅限于对全部代码十分了解的情况下。二次开发和对组件重构时就需要做大量操作了。 我建议优先通过 props 传递，这样可以使组件更加容易维护和阅读。","tags":["思考"],"categories":["代码人生"]},{"title":"node-简易洋葱模型实现","path":"/2024/10/07/node-简易洋葱模型实现/","content":"就像我们睡觉一样，盖了三床被子，要从外面一层一层展开；躺进去后，再一层一层盖上一样。 koa 中的洋葱圈模型在koa中，中间件是洋葱圈模型。什么是洋葱圈模型呢？ 每一层都是一个中间件，先从外到里执行next前的处理，再由中心向外部执行next之后的处理。每一层都有两次执行时机。 我们先使用koa来看一下中间件执行的时机及过程 const Koa = require(koa)const app = new Koa()app.use((ctx, next) = console.log(中间件1 -- next之前) next() console.log(中间件1 -- next之后))app.use((ctx, next) = console.log(中间件2 -- next之前) next() console.log(中间件2 -- next之后))const port = 3000app.listen(port, () = console.log(`http://localhost:$port`)) 执行如图所示 打印结果如下 中间件1 -- next之前中间件2 -- next之前中间件2 -- next之后中间件1 -- next之后 简易的洋葱圈模型实现const createServer = require(node:http)class Koa handlers = [] ctx = use(handler) if (typeof handler !== function) throw new Error(middleware is must be a function) this.handlers.push(handler) _execute() if (this.handlers.length === 0) return const first = this.handlers.shift() first(this.ctx, () = this._execute() ) listen(port, callback) const app = createServer((req, res) = this._execute() res.writeHead(200, Content-type: application/json ) res.end( JSON.stringify( status: 200, message: hello my koa, ) ) ) app.listen(port, typeof callback === function ? callback : null) const app = new Koa()app.use((ctx, next) = console.log(中间件1 -- next之前) next() console.log(中间件1 -- next之后))app.use((ctx, next) = console.log(中间件2 -- next之前) next() console.log(中间件2 -- next之后))const port = 3000app.listen(port, () = console.log(`http://localhost:$port`))","tags":["node","JavaScript","koa"],"categories":["代码人生","JavaScript"]},{"title":"Nuxt报错解决","path":"/2024/09/09/nuxt3-server-error/","content":"nuxt error Error: HostnameIP does not match certificate’s altnames在 nuxt 项目中使用server 中对接口进行转发，接口中的地址使用是和后端同一内网的地址，所以是一个 ip 地址，在近期更新中遇到页面中数据缺失，查看 pm2 日志发现报错： cause: Error: HostnameIP does not match certificate’s altnames: IP: 192.168.xx.xxx is not in the cert’s list: 解决方案如下：在环境变量中添加 NODE_TLS_REJECT_UNAUTHORIZED: 0 由于生产环境中是以 pm2 启动，更改其配置文件ecosystem.config.js，在 env_production 字段添加 NODE_TLS_REJECT_UNAUTHORIZED: 0 [nuxt] [request error] [unhandled] [500] Cannot find package ‘deep-pick-omit’ imported from node版本需要高于16.20.x 不要使用cnpm，想要加速下载可以在 .npmrc 中配置 registry=https://registry.npmmirror.com/"},{"title":"mongodb快速使用","path":"/2024/08/01/mongodb快速使用/","content":"安装mongodb 官网mongodb 中文官网 node 实例: 使用 express 和 mongoose 实现简单的文章管理 API 初始化项目npm init -y 依赖安装npm i express@latest cors mongoose 数据建模import mongoose from mongooseconst Article = mongoose.model( Article, new mongoose.Schema( title: type: String , )) 增删改查 API 实现获取列表根据 id 获取详情创建文章编辑文章删除文章app.get(/articles, async (req, res) = const article = await Article.find() res.send( success: true, message: get article list, data: article, ))app.get(/articles/:id, async (req, res) = const id = req.params.id const article = await Article.findById(id) res.send( success: true, message: get article by id, data: article, ))app.post(/articles, async (req, res) = const body = req.body const article = await Article.create( title: body.title, ) res.send( success: true, message: create article, data: article, ))app.put(/articles/:id, async (req, res) = const id = req.params.id const body = req.body const article = await Article.findById(id) article.title = body.title await article.save() res.send( success: true, message: update article, data: article, ))app.delete(/articles/:id, async (req, res) = const id = req.params.id await Article.deleteOne( _id: id ) // 或者可以使用以下方法进行删除 // const article = await Article.findById(id) // await article.remove() res.send( success: true, message: delete article, )) 完整代码 main.jsimport express from expressimport mongoose from mongooseimport cors from corsconst app = express()app.use(express.json())app.use(cors())try await mongoose.connect(mongodb://127.0.0.1:27017/mongodb-test) catch (error) console.error(error:数据库连接失败 , error)const Article = mongoose.model( Article, new mongoose.Schema( title: type: String , ))app.get(/articles, async (req, res) = const article = await Article.find() res.send( success: true, message: get article list, data: article, ))app.get(/articles/:id, async (req, res) = const id = req.params.id const article = await Article.findById(id) res.send( success: true, message: get article by id, data: article, ))app.post(/articles, async (req, res) = const body = req.body const article = await Article.create( title: body.title, ) res.send( success: true, message: create article, data: article, ))app.put(/articles/:id, async (req, res) = const id = req.params.id const body = req.body const article = await Article.findById(id) article.title = body.title await article.save() res.send( success: true, message: update article, data: article, ))app.delete(/articles/:id, async (req, res) = const id = req.params.id await Article.deleteOne( _id: id ) res.send( success: true, message: delete article, ))const port = 3000app.listen(port, () = console.log(`http://localhost:$port`)) 查看运行情况可以使用 vscode 插件 rest client 来测试接口运行情况，以下是我本地接口测试文件。如果你要在本地测试，可以将 66ae4047563fa3933c1b38ba 改成真实的查询列表里的某一个文章的 id 即可 说明client 这个插件在我的博客里有介绍，可以移步 rest client 插件使用 了解其基础使用方法 测试代码 articles.http@uri=http://localhost:3000### 获取文章列表GET uri/articles### 创建文章POST uri/articlesContent-Type: application/json title: 添加文章标题### 根据id获取文章GET uri/articles/66ae4047563fa3933c1b38ba### 编辑文章PUT uri/articles/66ae4047563fa3933c1b38baContent-Type: application/json title: 编辑文章标题### 删除文章DELETE uri/articles/66ae4047563fa3933c1b38ba","tags":["mongodb","学习笔记"],"categories":["代码人生","数据库"]},{"title":"近况说明","path":"/2024/07/14/近况说明/","content":"好久没有写博客了，最近经历了很多事。总感觉近来大家的脾气都不太好，可能是因为经济下行的影响吧。 说下我最近的情况吧： 近期我经历了我人生中第二次裁员，虽然两个公司两次裁员每次我都没事，但是身边的朋友被裁，心里难免有些异样的感觉。 现在在的这家公司经营不善，已经三个月没法工资了。上周发工资时不知为何没有给我发，在我去沟通的时候，总能感觉领导处处在阴阳怪气。什么你怎么能吃饭钱都没有总总…… 在上周，把我招进公司的前辈离职了。公司在用人方面还是有很多欠缺，这时大家有目共睹的，在把人当做前端 leader 用的时候，连个名头都舍不得给，这让我难以理解。都说能做老板的头脑没有那么欠缺，但我总感觉这家公司的管理层太不专业了。 每每开会公司都在强调公司的困难，什么你们的工资对于公司来说就是九牛一毛，什么撑过这几月后就会好转等等……可是目前是什么情况，我想公司里的人都心知肚明，没有离开的缘由大概也是就业环境不好，公司员工年龄普遍偏大导致的罢。 就在昨天，我的老大哥突然被告知他也被裁员了，我靠。最近怎么都是这种事啊！！！ 近来我也在思考，我到底该怎么办？找工作？在这种情况下，我对自己本就不多的信心不支持我调整到去找工作的心态。继续留下？我也不甘心，面对此公司的说辞，我再不会相信他们了。 最近考虑准备条退路吧。 对了，近几个月，我迷上了八字命理。哈哈哈，人未到中年确已相信命运之说。我曾听人言：『多会你没有了斗志，就说明你已经老了』。 我一定会重新燃起斗志，继续奋斗。哥们好日子还没过过呢，我不甘心就这样了。 对了，今天新闻：特朗普被枪击了！"},{"title":"nuxt3获取静态图片公用方法","path":"/2024/06/20/nuxt3-获取静态图片公用方法/","content":"utils/getAssetsImage.ts // 动态获取图片export function getAssetsImage(src: string | undefined): string if (!src) return const assets = import.meta.glob(~/assets/image/**/*, eager: true, import: default ) return assets[`/assets/image/$src`] as stringexport function getAssetsIcon(src: string | undefined): string if (!src) return const assets = import.meta.glob(~/assets/icons/**/*, eager: true, import: default ) return assets[`/assets/icons/$src`] as string 使用 script setupimport getAssetsImage from ~/utils/getAssetsImage/scripttemplate img :src=getAssetsImage(card.bg) alt= //template"},{"title":"useAsyncData vs useFetch","path":"/2024/06/10/nuxt3-useAsyncData-vs-useFetch/","content":"nuxt 为我们提供了 useFetch 和 useAsyncData 我们应该用哪个呢？ 如何在数据变化后自动重新加载数据？在使用 useFetch 时，需要在数据变化后自动请求数据的时候，我们不应该在参数中进行解包 script lang=ts setup const page = ref(1) const data = await useFetch(/api/result, query: page: page.value, , method: POST, )/scripttemplate button @click=page++更改分页/button/template 上面这段代码相当于下面这段代码，在 page 变化时不会自动进行数据的重新加载。 script lang=ts setup const page = ref(1) const data = await useFetch(/api/result, query: page: 1, , method: POST, )/scripttemplate button @click=page++更改分页/button/template 我们我们如果需要在 page 变化时重新调用接口，我们不需要对 page 进行解包 script lang=ts setup const page = ref(1) const data = await useFetch(/api/result, query: page: page, , method: POST, )/scripttemplate button @click=page++更改分页/button/template 下面两段代码实现的效果是一致的，会在在 page 变化时重新请求数据 const page = ref(1)const data = await useFetch(/api/result, query: page: page, , method: POST,) const page = ref(1)const data = await useAsyncData(result, async () = $fetch( /api/result, query: page: page.value, , method: POST, , watch: [page], )) useFetch 近似等同于 useAsyncData + $fetch 什么时候会用到 useAsyncData？我们需要一次请求多个数据，比如我们需要请求用户信息和文章列表，我们可以使用 useAsyncData 来实现 const userInfo = await useAsyncData(userInfo, async () = const [user, articles] = await Promise.all([$fetch(/api/user), $fetch(/api/articles)]) return user, articles, ) 或者我们会有一些其他的第三方提供好的接口和方法，我们也可以使用 useAsyncData 来实现 // 这里模拟第三方提供好的请求方法import fetchData from other-apiconst data = await useAsyncData(otherData, async () = const result = await fetchData() return result) useAsyncData 和 useFetch 对返回值的处理有时我们需要的数据只是接口返回值的一部分，那么我们可以使用 transform 属性来处理返回值 const data = await useAsyncData(result, () = $fetch(/api/result), transform: (data) = // 在这里处理返回值 return id: data.id, name: data.name, ,) 如果返回值是多个数据，也可以使用 transform 函数来处理 const userInfo = await useAsyncData( userInfo, async () = const [user, articles] = await Promise.all([$fetch(/api/user), $fetch(/api/articles)]) return user, articles, , transform: (data) = return user: username: data.user.username, email: data.user.email, , articles: data.articles.map((article) = ( title: article.title, content: article.content, )), , ) 结论 $fetch 没有响应性 useAsyncData 可以配置 watch 属性在某些字段变更时具备响应性 useFetch 可以自动扫描方法内的响应式数据，并在数据变更时重新加载数据 我们一般情况下使用 useFetch，useFetch 为我们提供的自动重新加载数据会有更好的 DX，我们不在需要手动处理什么时候重新加载数据，只要保证参数中的数据是响应式的即可；如果你有特殊的情况，可以使用 useAsyncData 自己处理一些数据，而且结合 useAsyncData 提供的一些属性比如 watch 也可以尽可能的更加友好的处理一些数据的自动重新加载；$fetch 来自于 ofetch 它更像是 axios 之类 HTTP 请求库，需要手动对每次请求做出判断。 如果实在服务端使用，那么就只能使用 $fetch"},{"title":"code review  黑话摘录","path":"/2024/06/08/code-review-黑话摘录/","content":"最近在给 element plus 提交 pr 的时候看到一些莫名其妙的单词缩写。查阅后发现其是有功能的，现摘录如下。 以后在写代码 review 的时候，可以用一下，逼格拉满。 简写 含义 LGTM Looks good to me，表示认可这次 PR，同意 merge 合并代码到远程仓库 NACKNAK negative acknowledgement, i.e. disagree with change andor concept ASAP as soon as possible! 尽快 ACK acknowledgement, i.e. agreedaccepted change RFC request for comments, i.e. I think this is a good idea, lets discuss WIP Work In Progress 「进展中」，常见词汇，这里做为 Best Practice 单独提出来，主要针对改动较多的 PR，可以先提交部分，标题或 Tag 加上 WIP，表示尚未完成，这样别人可以先 review 已提交的部分 IIRC : if I recall correctly IANAL :“ I am not a lawyer ”, but I smell licensing issues IMO :（In my opinion），在我看来 TL;DR : Too Long; Didn’t Read 「太长懒得看」，README 文档常见。 AFAIKAFAICT as far as I know can tell PR Pull request「合并请求」 CR Code Review 「代码审查」 PTAL Please Take A Look. 你来瞅瞅？用来提示别人来看一下 TBR To Be Reviewed. 提示维护者进行 review TBD To Be Done(or DefinedDiscussedDecidedDetermined). 根据语境不同意义有所区别，但一般都是还没搞定的意思。 TBH To be honest 「老实说」 ATM at the moment 「现阶段」，"},{"title":"nuxt3 请求数据","path":"/2024/06/05/nuxt3-请求数据/","content":"问题描述在 nuxt3 中，我们通常使用 useFetch 来获取接口数据，一般情况下我们会在页面中这样使用 const data = await useFetch(/api/data) 这样使用的时候，如果接口返回很慢，会导致页面一直在加载状态。如果此时有页面跳转的话，我们会一直停留在之前的页面，直至请求完成，nuxt 才会跳转至新页面。 我们怎么操作才能有更好的用户体验呢？ 解决方案1. 显示加载状态数据加载会阻塞页面跳转，如果有页面跳转时，用户可能为认为页面卡死或者没有对页面进行操作 这时我们的解决方案可以是：显示一个加载状态，让用户可以感知当前页面正在加载数据。 我们可以使用内置的nuxt-loading-indicator标签，将其放置于 app.vue 组件中，这样在页面加载数据时，顶部会出现一个加载条。用户会感知到页面的变化，不至于误认为自己未进行操作或者以为页面卡死。 这样做的话，在接口没返回数据前，页面会一直停留在跳转之前的页面。可能会给用户留下系统很卡的感觉。我们可不可以再做一些优化呢？ 2. 为 useFetch 配置{lazy: true}我们可以为 useFetch 的配置{lazy: true}，可以实现数据懒加载。这样，在加载数据时，页面的跳转和渲染不会被阻塞。 const pending, data = await useFetch(/api/data, lazy: true ) 这时，useFetch 的返回值里会有一个 pending 属性，pending 表示数据是否还未加载完成。我们可以在 pending 为 true 时做一些操作。 这样依赖，用户可以在点击后直接进入要跳转的页面。至于在接口请求时要展示的内容，就有很多发挥空间了。 我们可以展示一个加载页？或许我们可以展示一个骨架屏。。。 3. 使用 useLazyFetch当然，nuxt3 也为我们提供了 useLazyFetch 这个函数，效果与手动配置 lazy: true 相同。 const pending, data = await useLazyFetch(/api/data) 注意： 这里是否有 await 都不影响数据的懒加载 后续我会通过一个 宝可梦图鉴 的项目，来讲述如何使用 useFetch 和 useLazyFetch 来优化数据请求的体验。"},{"title":"leetcode 两数之和","path":"/2024/05/18/leetcode-两数之和/","content":"题目描述简单 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。 你可以按任意顺序返回答案。 示例 1：输入：nums [2,7,11,15], target 9输出：[0,1]解释：因为 nums[0] + nums[1] 9 ，返回 [0, 1] 。 示例 2：输入：nums [3,2,4], target 6输出：[1,2] 示例 3：输入：nums [3,3], target 6输出：[0,1] 提示：2 nums.length 104-109 nums[i] 109-109 target 109只会存在一个有效答案 跳转至当前题目 leetcode 解题思路：利用 Map 存储数组中的元素和索引，遍历数组，对于每个元素，计算它的补数（target - nums[i]），如果 Map 中存在这个补数，则找到了两个元素的和，返回它们的索引；否则，将当前元素和它的索引存入 Map。 时间复杂度：O(n) 空间复杂度：O(n) 代码如下：const towSum = (nums, target) = const map = new Map() for (let i = 0; i nums.length; i++) const complement = target - nums[i] if (map.has(complement)) return [map.get(complement), i] else map.set(nums[i], i) return []","tags":["JavaScript","算法","leetcode"],"categories":["代码人生"]},{"title":"ECharts 在 vue2 中的实践","path":"/2024/04/16/chart-echarts在vue2中的实践/","content":"封装一个 ECharts 容器组件，在使用时可以直接传递一个 options 对象，在组件内部自动初始化基础配置和监听图表大小变化、图表数据变化后自动重新渲染。 封装 ECharts 容器组件监听图表大小变化使用了 ResizeObserver 函数监听容器大小变化，变化时调用 chart.resize() 重新渲染图表。 监听图表大小变化的代码 // 监听容器大小变化，实现图表自适应const resizeObserver = new ResizeObserver((entries) = console.log(entries, 容器大小变化) this.chart.resize())resizeObserver.observe(this.$refs.container) 容器组件完整代码 防抖节流函数 DebounceThrottle.js// 函数防抖function debounce(fn, wait = 500) let timeout = null return function () var args = arguments if (timeout !== null) clearTimeout(timeout) timeout = setTimeout(() = fn.apply(this, args) , wait) // 函数节流function throttle(fn, delay = 500) var lastTime var timer return function () var args = arguments // 记录当前函数触发的时间 var nowTime = Date.now() if (lastTime nowTime - lastTime delay) clearTimeout(timer) timer = setTimeout(() = // 记录上一次函数触发的时间 lastTime = nowTime , delay) else lastTime = nowTime fn.apply(this, args) export debounce, throttle ChartContainer.vuetemplate div class=container ref=container/div/templatescript import * as echarts from echarts import SVGRenderer, CanvasRenderer from echarts/renderers import debounce from ./utils/DebounceThrottle.js echarts.use([SVGRenderer, CanvasRenderer]) export default data() return chart: null, resizeObserver: null, , props: options: type: Object, default: () = , required: true, , render: type: String, default: canvas, required: false, validator(type) return [canvas, svg].includes(type) , , , watch: options: handler(newOptions) console.log(options update) this.chart.setOption(newOptions) , deep: true, , , methods: , mounted() this.chart = echarts.init(this.$refs.container, null, render: this.render, locale: ZH, useDirtyRect: true, ) this.chart.setOption(this.options) // 监听容器大小变化，实现图表自适应 if (window.ResizeObserver) this.resizeObserver = new ResizeObserver( debounce((entries) = console.log(entries, 容器大小变化) this.chart.resize() ) ) this.resizeObserver.observe(this.$refs.container) , beforeDestroy() console.log(销毁) if (this.chart) this.chart.dispose() if (window.ResizeObserver this.resizeObserver) this.resizeObserver.unobserve(this.$refs.container) , /scriptstyle lang=less scoped .container width: 100%; height: 100%; /style 使用 ECharts 容器组件组件内部监听外部传入数据变化，变化后使用 watch 更新 options。 圆环图表示例代码 template ChartContainer :options=options //templatescript import ChartContainer from ./ChartContainer.vue export default components: ChartContainer, , props: pData: type: Array, default: [], required: false, , , data() return options: , , watch: pData: handler() this.options = this.barChartOptions() , immediate: true, , , methods: barChartOptions() const data = this.pData.map((item) = return value: item.fieldCountNum, name: item.fieldName, ) return tooltip: trigger: item, , legend: top: bottom, left: center, , series: [ type: pie, radius: [35%, 60%], padAngle: 3, itemStyle: borderRadius: 5, , labelLine: show: true, , data, , ], , , /script"},{"title":"最近学习到的小知识","path":"/2024/04/13/sticky-最近学习到的小知识/","content":"h5 获取经纬度function getLocation() if (navigator.geolocation) navigator.geolocation.getCurrentPosition((res) = console.log(经度 + res.coords.longitude + 纬度 + res.coords.latitude) ) else alert(Geolocation is not supported by this browser.) nuxt3 ssg 报错问题处理可以在 nuxt.config.ts 中添加如下配置试试 nitro: routeRules: /*: cors: true, , , prerender: crawlLinks: true, failOnError: false, , externals: traceInclude: [], ,"},{"title":"十年之约","path":"/2024/03/31/十年之约/","content":"为什么加入十年之约？以及我写博客的动机。 缘起我最开始创建博客是在我大二的时候，那时候听说有一个个人技术博客在面试的时候是很有竞争力的。 不过知道如今，我也不知道一个技术博客对找工作有什么帮助，可能是可以让人感觉到我可能对这行比较热爱吧。 那时候就开始慢慢尝试着自己搭建博客，我记得最开始使用的就是 hexo，主题好像也是目前这个主题的作者开发的一个。开始的时候，我的博客内容就是在看技术视频的一些笔记整理。说实话，连我自己都不愿意看的那种 😁。后来随着时间的推移，博客文章的写作也慢慢停止了下来。 而后随着开始工作，我开始接触到一些我自己遇到的一些问题，每次都去网上查就显得很麻烦了。于是我又开始了写作。这时候，我开始对我工作中遇到的一些问题开始做一些整理，并且收集了一些我自己常用的一些网站，工具等等。 这就是我为什么要写博客的缘起与之后的一些经历。 十年之约在最开始使用 hexo 写博客的时候，就随便看了一些本主题整理的一些使用该主题的博客。我看到好多人的博客都有一个 “虫洞” 或者 “列车” 的链接，点击后便会跳转至一个加入十年之约的博客。我当时觉得很神奇，但是没什么具体的了解，只是觉得十年之约是一个很酷的项目。 随着 23 年下半年找工作加租房的经历，生活变得不是那么顺利后，我开始有些迷茫，我开始想要寻找一件可以让我放松下来，放松心情的事情。于是我开始了写作，我开始写一些技术文章，分享一些生活感悟，记录一些工作中遇到的一些问题。但是写一些东西总要有些束缚才能让自己坚持下来，我想起来之前看过的一个很酷的项目，我试着申请了一下，没想到在一周过后，便顺利的申请下来了。 未来我会坚持写作，坚持分享，坚持记录，坚持学习，坚持思考，坚持进步。我相信十年之约的项目一定会让我有所收获，我会继续努力，继续前进。 之后的文章可能不会只是技术博客，会更多的加入一下自己的生活感悟。人生已过 25 载，希望在十年之后再看这篇文章的时候，我自己不会觉得我这十年是在虚度光阴。"},{"title":"ts 命名空间","path":"/2024/03/17/ts-命名空间/","content":"我们可以使用命名空间进行隔离，命名空间中的内容想让外部使用时，需要导出。类似于 es6 中的模块 namespace User export let username: string = whbbitconsole.log(User.username) 命名空间的嵌套想让外部使用时，需要对嵌套的命名空间进行导出 namespace User export let username: string = whbbit export namespace Member export let name = wxw console.log(User.Member.username)"},{"title":"ts 装饰器","path":"/2024/03/17/ts-装饰器/","content":"代码来自后盾网 装饰器为 ts 提供了强大的代码复用功能 使用装饰器需要在 tsconfig.json 中修改 装饰器是试验性的功能，需要在配置文件中开启 tsconfig.jsonexperimentalDecorators: true,emitDecoratorMetadata: true 类装饰器 ClassDecorator相当于在原型对象上添加属性 类装饰器只有一个参数，是构造函数。 const moveDecorator: ClassDecorator = (target: Function) = console.log(target) target.prototype.getPosition = (): x: number; y: number = return x: 20, y: 20 @moveDecoratorclass Player @moveDecoratorclass Tank const player = new Player()console.log(player.getPosition()) 装饰器语法糖 @不使用语法糖，需要传递类到对应的函数中。使用语法糖不需要手动调用。 const moveDecorator: ClassDecorator = (target: Function) = console.log(target) target.prototype.getPosition = (): x: number; y: number = return x: 20, y: 20 // 不使用语法糖class Player moveDecorator(Player)// 使用语法糖@moveDecoratorclass Tank const player = new Player()console.log(player.getPosition()) 装饰器叠加可以使用多个装饰器 const moveDecorator: ClassDecorator = (target: Function) = target.prototype.getPosition = () = console.log(获取位置) const MusicDecorator: ClassDecorator = (target: Function) = target.prototype.playMusic = () = console.log(音乐播放) @moveDecoratorclass Player const player = new Player()player.getPosition()@MusicDecorator@moveDecoratorclass Tank const tank = new Tank()tank.playMusic()tank.getPosition() 实例：全局消息响应const MessageDecorator: ClassDecorator = (target: Function) = target.prototype.sendMessage = (message: string, type: success | error = success) = return message, type, @MessageDecoratorclass LoginController login() console.log(登录业务处理) setTimeout(() = this.sendMessage(登录成功) , 2000) new LoginController().login() 装饰器工厂根据不同的条件返回不同的装饰器 const MusicDecorator = (type: string): ClassDecorator = switch (type) case player: return (target: Function) = target.prototype.playMusic = () = console.log(play player music) case tank: return (target: Function) = target.prototype.playMusic = () = console.log(play tank music) default: return (target: Function) = target.prototype.playMusic = () = console.log(play other music) @MusicDecorator(player)class Player new Player().playMusic()@MusicDecorator(tank)class Tank new Tank().playMusic() 方法装饰器const ShowDecorator: MethodDecorator = (...args: any[]) = console.log(args) /** 打印参数： [0]: 如果是静态函数就是构造函数，如果是普通方法就是其原型对象 [1]: 使用装饰器的方法名称 [2]: 方法属性的描述 [ User: , show, value: [Function (anonymous)] // 函数的内容 writable: true, enumerable: false, configurable: true ] */class User @ShowDecorator public show() 可以使用函数装饰器更改函数的内容 const ShowDecorator: MethodDecorator = (...args: any[]) = console.log(args) args[2].value = () = console.log(ShowDecorator changed) class User @ShowDecorator public show() console.log(show function ) new User().show() // 打印 ShowDecorator changed，函数内容已经被更改 上面那样使用数组接收后调用不是很直观，我们可以使用变量名接收方法装饰器参数 const ShowDecorator: MethodDecorator = (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = ... ; const ShowDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = descriptor.value = () = console.log(ShowDecorator changed) class User @ShowDecorator public show() console.log(show function ) new User().show() // 打印 ShowDecorator changed，函数内容已经被更改 调用装饰器时，也可以更改静态方法的内容 const ShowDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = descriptor.value = () = console.log(ShowDecorator changed) class User @ShowDecorator public static show() console.log(show function ) User.show() // 打印 ShowDecorator changed，函数内容已经被更改 调用 writable = true 控制方法不能重新声明 const ShowDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = descriptor.value = () = console.log(ShowDecorator changed) descriptor.writable = falseclass User @ShowDecorator public static show() console.log(show function ) User.show() // 打印 ShowDecorator changed，函数内容已经被更改User.show = () = console.log(重写show方法)User.show() 示例：模拟代码高亮可以先使用变量将函数内容保存起来，在自定义操作后直接调用保存的函数 const HighlightDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value descriptor.value = () = return `div style=background: red;$method()/div` class User @HighlightDecorator public show() return js code new User().show() 示例：结合装饰器工厂实现延迟执行const SleepDecorator = (times: number = 2000): MethodDecorator = return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value descriptor.value = () = setTimeout(() = method() , times) class User @SleepDecorator(3000) public show() console.log(wxw) new User().show() 示例：全局异常处理const ErrorDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value descriptor.value = () = try method() catch (e) // 函数中抛出的错误在这里进行处理 console.log(%c异常处理, color: green;) console.log(`%c$e`, color: red) class User @ErrorDecorator find() throw new Error(出错了) new User().find() 示例：根据权限限制访问可以根据传入的权限数组进行判断用户是否有访问权限 type UserType = name: string; isLogin: boolean; permissions: string const user = name: wxw, isLogin: true, permissions: [admin, member],const AccessDecorator = (keys: string[]): MethodDecorator = return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value const validate = () = keys.every((k) = user.permissions.includes(k)) descriptor.value = () = // 控制用户登录并且有权限才可访问 if (user.isLogin validate() === true) console.log(验证通过) method() return else console.log(验证失败) return false class User @AccessDecorator([admin]) find() console.log(find function) new User().find() 属性装饰器接收的参数 args[0]: target 静态参数就是构造函数，普通参数就是其原型对象 args[1]: propertyKey 属性名称 args[2]: undefined const PropDecorator: PropertyDecorator = (target: Object, propertyKey: string | symbol) = console.log(target, propertyKey)class User public username: string 实例：使用属性装饰器动态改变对象属性将属性改为全部大写 const UpperDecorator: PropertyDecorator = (target: Object, propertyKey: string | symbol) = let value: string = undefined //在这里使用Object.defineProperty对原数据进行更改 Object.defineProperty(target, propertyKey, get() return value.toUpperCase() , set(v) value = v , )class Article @UpperDecorator public title: string | undefinedconst article = new Article()article.title = article titleconsole.log(article.title) 参数装饰器接收的参数 args[0]: target 静态参数就是构造函数，普通参数就是其原型对象 args[1]: propertyKey 属性名称 args[2]: parameterIndex 参数所在的位置，从 0 开始计数 const ParamDecorator: ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) = console.log(target, propertyKey, parameterIndex)class User show(id: number, @ParamDecorator user: name: string ) 装饰器执行顺序:参数装饰器 - 方法装饰器"},{"title":"ts-interface和type","path":"/2024/03/17/ts-interface和type/","content":"interface 和 abstract 抽象类想比 interface 中不能有具体代码实现。 类中实现 interface在类中要实现 interface，需要使用 implements interface name interface IAnimal name: string getName(): voidabstract class Animal constructor(public name: string) setName(name: string) this.name = name class Cat extends Animal implements IAnimal constructor(public name: string) super(name) public getName(): string return this.name const cat = new Cat(cat)cat.setName(dog)console.log(cat.getName()) interface 对对象的约束interface 对对象的约束，作用和 type 类似 [key: string]: any; 表示对象的键需要是字符串类型，值的累心不做约束 interface IUser name: string age: number site?: string info(): string [key: string]: anylet user: IUser = name: wxw, age: 25, sex: 男, info() return `$this.name $this.age` , 在函数中使用 interfaceinterface IUser name: string age: numberfunction setUser(user: IUser) return usersetUser( name: wxw, age: 25 ) interface 对函数的约束interface IGetUser (name: string): stringconst getUser: IGetUser = (name: string) = return nameconsole.log(getUser(W)) 在类中使用 interfaceinterface IUser name: string age: numberclass User _info: IUser constructor(user: IUser) this._info = user get info() return this._info const user = new User( name: whbbit, age: 25 )console.log(user.info) 数组中使用 interfaceinterface IUser name: string age: numberconst user1 = name: whbbit, age: 25 const user2 = name: wxw, age: 25 const users: IUser[] = [user1, user2] interface 结合 enumenum SexType BOY, GIRL,interface IUser name: string age: number sex: SexTypeconst user1 = name: whbbit, age: 25, sex: SexType.BOY const user2 = name: wxw, age: 25, sex: SexType.GIRL const users: IUser[] = [user1, user2] interface 的继承interface IVoice voice(): voidinterface IAnimal extends IVoice name: string getName(): void// 相当于// interface IAnimal // name: string;// getName(): void;// voice(): void;// interface 声明合并写一个同名 interface 就会实现 interface 的合并。 后面的 interface 和前面的 interface 中不能有同名参数 interface IAnimal name: string getName(): stringinterface IAnimal voice(): stringconst cat: IAnimal = getName() return this.name , name: cat, voice() return miao~ ,console.log(cat.getName())console.log(cat.voice()) type大多数情况下 type 和 interfere 使用相同 type TUser = name: string; age: 25 function getUser(user: TUser): TUser return userconst user: TUser = name: wxw, age: 25,console.log(getUser(user)) type 可以作为基本类型的别名使用，也可以申明联合类型 type IsAdmin = booleantype Sex = boy | girl type 和 interface 的区别 interface 同名会合并，type 同名会报错 interface 可以继承，type 使用 合并 type 可以使用 合并 interface 类型 type TName = name: stirng ;type TAge = age: number ;interface IMember = member: booleantype TUser = TName TAge IMember;"},{"title":"ts 元组","path":"/2024/03/17/ts-元组/","content":"// 数组类型的限制， 我们无法做到对对应位置元素类型的限制let arr: (string | number)[] = [whbbit, wxw, 25] 元组可以对固定位置参数类型的限制 // 限制arr第一个元素是string类型，第二个元素是number类型，第三个元素是boolean类型let arr: [string, number, boolean] = [whbbit, 20, false]arr[0] = wxw // 类型正确，可以进行更改arr[0] = 10 // 这时就会报错"},{"title":"ts 类","path":"/2024/03/17/ts-类/","content":"对参数进行约束定义一个普通的类，约束其接收的参数的类型 class User name: string age: number constructor(name: string, age: number) this.name = name this.age = age const user1 = new User(Whbbit, 25)const user2 = new User(wxw, 25)// 限制users数组的值只能是User类示例化的对象const users: User[] = [user1, user2] public 修饰符使用 public 修饰符表示这个函数，变量可以在函数外进行访问。默认为 public 在 js 中默认就可以在外部进行访问 class User public name: string public age: number constructor(name: string, age: number) this.name = name this.age = age public getName() return `name: $this.name, age: $this.age` const user1 = new User(whbbit, 25)user1.name = wxwconsole.log(user1.name)console.log(user1.getName()) protected 修饰符使用 protected 后，只能在类中调用。可以对方法和属性进行约束。 class User protected name: string protected age: number constructor(name: string, age: number) this.name = name this.age = age protected show() console.log(show) public getName() return `name: $this.name, age: $this.age` const user1 = new User(whbbit, 25)user1.name = wxw // ts 报错console.log(user1.name) // ts 报错user1.show() // ts 报错console.log(user1.getName()) // 正常运行 在父类中声明的受保护的方法或属性，在子类中可以调用。但在类外部不可调用 class Person protected name: string protected age: number protected show() console.log(show) class User extends Person constructor(name: string, age: number) super() this.name = name this.age = age public getInfo() return this.show() const user1 = new User(wxw, 25)user1.getInfo() private 私有属性在子类或类外部都不可访问。在父类中定义的私有方法子类不可使用，不可覆盖 class Person protected name: string; public age: number; private site: string; protected show() console.log(show， `site is $this.site`); class User extends Person constructor(name: string, age: number) super(); this.name = name; this.age = age; getSite() console.log(this.site); public getInfo() return this.show(); const user1 = new User(wxw, 25);user1.getInfo();console.log(user1.site); 在父类中定义的受保护的方法，在子类中可以使用，可以覆盖，但是权限只能降低为 public 或维持 protected。不能将其更改为private class Person protected name: string; public age: number; private site: string; protected show() console.log(show， `site is $this.site`); class User extends Person constructor(name: string, age: number) super(); this.name = name; this.age = age; getSite() console.log(this.site); private show() console.log(这里是子类覆盖掉的shou方法) public getInfo() return this.show(); const user1 = new User(wxw, 25);user1.show() readonly限定属性不能进行修改 class Axios readonly site: string = https://www.whbbit.cn/api constructor() public get(url: string) console.log(`请求地址是$url`) return [] const instance = new Axios()console.log(instance.site)instance.site = https://api.com // 报错：Cannot assign to site because it is a read-only property 但是在构造函数初始化时可以更改 class Axios readonly site: string = https://www.whbbit.cn/api constructor(site?: string) this.site = site || this.site public get(url: string) console.log(`请求地址是$this.site/$url`) return [] const instance = new Axios()instance.get(article) // 请求地址是https://www.whbbit.cn/api/articleconst instance1 = new Axios(https://www.whbbit.cn/docs)instance1.get(article) // 请求地址是https://www.whbbit.cn/docs/article readonly 前可以添加 public、protected、 private等修饰符 constructor 构造函数在构造函数中接收的参数前书写修饰符，ts 会自动帮我们进行初始化操作 class User constructor(public name: string, public: age: string) // 等同于 // public name: string // public age: number // constructor( name: string, age: number) // this.name = name // this.age = age // static 静态属性方法static 静态属性方法只能通过构造函数调用。 使用 static 修饰属性 class Axios static site: string = whbbit.cn constructor() const instance = new Axios()console.log(Axios.site)console.log(instance.site) // 报错 上面代码编译为 js 后的代码 use strictclass Axios constructor() Axios.site = whbbit.cnconst instance = new Axios()console.log(Axios.site)console.log(instance.site) // 报错 static 也可以修饰方法 class Axios static site: string = whbbit.cn constructor() public static getSite() return Axios.site const instance = new Axios()console.log(Axios.getSite()) get setclass User constructor(private _name: string) public get name(): string return this._name public set name(name: string) this._name = name const user = new User(wxw)console.log(user.name)console.log((user.name = whbbit))console.log(user.name) 使用访问器 getset 可以在设置或获取时进行处理 type articleType = title: string class Articles constructor(private _lists: articleType[] = []) get articles(): articleType[] return this._lists.map((article) = article.title = article.title + www.whbbit.cn return article ) set articles(articles: articleType[]) this._lists = articles const list = new Articles()list.articles = [ title: ts中的类 , title: ts断言 ]console.log(list.articles) 单例模式实现 将构造函数设置为私有 定义一个静态方法用来生成实例 定义一个静态属性，在静态方法中判断是否已经初始化，未初始化就进行初始化，已经初始化直接返回这个生成的实例 class Axios private static instance: Axios | null = null private constructor() console.log(构造函数方法) static make(): Axios if (Axios.instance === null) Axios.instance = new Axios() return Axios.instance const instance = Axios.make()console.log(instance) 抽象类// 抽象类abstract class Animal constructor(public name: string) abstract getName(): string setName(name: string) this.name = name // 派生类class Cat extends Animal constructor(public name: string) super(name) public getName(): string return this.name const cat = new Cat(cat)cat.setName(dog) 抽象类无法被实例化 派生类中需要实现抽象类中定义的方法"},{"title":"ts 泛型","path":"/2024/03/17/ts-泛型/","content":"什么是泛型可以理解为动态的类型，类型中可以接受参数。 我们要做一个输入什么就返回什么的函数，当我们将类型写死后，传递其他类型的数据就会在编译时报错类型错误。我们能不能做到在传递参数时声明一个类型，让我们声明的类型进行判断呢？ function returnSomething(inputSomething: string): string return inputSomethingreturnSomethingstring(wx)returnSomething(23) // 报错 这时我们可以使用泛型接受类型参数 function returnSomethingT(inputSomething: T): T return inputSomethingreturnSomethingstring(wx)returnSomethingnumber(2) 泛型的继承 extends有时我们需要一些特定类型的参数，里面包含一些相同的类型，我们可以用 extends 继承来约束可以传递的参数 function getLengthT extends length: number (arg: T): number return arg.lengthfunction getLengthT extends length: number (arg: T): number return arg.lengthgetLength(www)getLength([2, 3, 4])getLength(2) // 报错 类中使用我们可以使用泛型对函数的类型做限制，将类型的定义部分开放给用户。 class UserT constructor(private user: T) get(): T return this.user interface IUser name: string age: numberconst user = new UserIUser( age: 2, name: xxx )console.log(user.get()) interface 使用泛型interface IArticleB, C title: string isLock: B comments: C[]type CommentType = content: string const article: IArticleboolean, CommentType = title: 测试文章, isLock: false, comments: [ content: 测试评论 ],"},{"title":"ts 断言","path":"/2024/03/17/ts-断言/","content":"断言就是我说了算。 // 这里的element 默认类型是HTMLElement | null ，这里我们可以直接说明这个element一定存在并且为一个div标签const element = document.getElementById(el) as HTMLDivElement as const 断言let a: string = whbbita = whbbit.cnconst b = whbbit // 按照js语法，b的值不能被改变let c = whbbit as const // c的值可以改变，但是只能改变为whbbit// 写法等同于 let c: whbbit = whbbit 数组使用 as const 时，相当于声明一个元组。 const arr = [whbbit, 25] as const// 等同于 const arr: [whbbit, 25] = [whbbit, 25]let a: string = whbbitlet b: number = 25const arr1 = [a, b] as const// 等同于 const arr: [string, number] = [a, b] 对象使用 as const 时 let age: number = 20let c = true as constconst obj = name: whbbit, age, c, as const// 类型为 readonly name: whbbit, readonly age: number, readonly c: true 数组或对象使用 as const 时，如果内容是引入别处的变量时，就使用该变量的类型，如果是常量时，就使用该常量的值 as const 在解构中使用的便利性 function func() let a = whbbit let b = 25 return a, b as constlet a, b = func()// 这时ts可以准确的推断a的类型是string，b的类型是number。// 不使用as const 时，a和b的类型都是 string | numberconsole.log(a, b) 非空断言const el = document.querySelector(#app)// 类型为 HTMLElement | null 当我们知道 id app 的元素是一个 div 元素时，我们想让其类型明确为HTMLDivElement 以获得更好的类型提示 const el: HTMLDivElement = document.querySelector(#app)// 这时会报错 Type HTMLDivElement | null is not assignable to type HTMLDivElement. Type null is not assignable to type HTMLDivElement. 当我们清楚的知道这个元素一定不为空时，就可以使用非空断言 const el: HTMLDivElement = document.querySelector(#app)! 或者我们也可以直接为其断言 const el = document.querySelector(#app) as HTMLDivElement DOM 类型推断我们可以断言 DOM 类型， 事件类型等 const el = document.querySelector(#app) as HTMLDivElementel.addEventListener(click, (e: Event) = console.log(e.target))"},{"title":"ts 基本数据类型","path":"/2024/03/16/ts-基本数据类型/","content":"包含了对断言、never、void 等类型的说明 基本类型定义数据类型，基本数据类型中包含 string number boolean 等 let name: string = whbbit // name 的值只能是字符串类型let age: number = 25 // age的值只能是数值类型let work: boolean = false // work的值只能是true/falselet stringArr: string[] // 数组里的值只能是字符串let obj1: object // obj1必须是一个对象let obj: name: string; age: number // obj这个对象中只能包含name和age属性，且类型必须是规定的类型 在 : 前添加 ? 表示这个值不是必填 let obj1: name: string; age: number; work: boolean = name: whbbit, aage: 25,console.log(obj1) // 编译时会有报错，Property work is missing in type name: string; age: number; but required in type name: string; age: number; work: boolean; .let obj: name: string; age: number; work?: boolean = name: whbbit, age: 25,console.log(obj) 类型自动推断在不写类型时，ts 会自动进行类型推断 let name = whbbit // 等同于 - let name: string = whbbit 类型组合使用 | 表示类型可以多选，符合 | 之前或者之后的类型即可 let a: string | number // 表示a可以是字符串也可以是一个数值a = whbbita = 20let b: string | number | booleanb = whbbitb = 20b = falselet arr: (string | number)[] = [] // 数组内容只能为字符串或数值类型let arr1: Arraystring | number = [] // 使用泛型 any在我们不知道是什么类型时，可以定义为 any 类型。对类型不做校验 let a: anya = whbbita = 10a = falsea = [whbbit]let arr: Array[any]let arr1: any[] 也可以对构造函数生成的实例进行类型限制。 不推介这样做，class 的类型推断和限制就没有了，不符合使用 ts 的场景 class Animal constructor() get = () = whbbit.cnconst cat: any = new Animal() 对配置文件改动，取消对 any 类型的自动推断 noImplicitAny: true unknownunknown 和 any 的区别 unknown 表示有类型但是不明确类型是什么，ts 会进行类型的判断 any 表示这个值没有类型，ts 不会进行类型的判断 let a: anylet a1: string = a // 不会进行报错，ts不做类型校验let b: unknownlet c: string = b // ts校验报错，类型不匹配 可以使用 as 断言来解决 let b: unknownlet c: string = b as string // 断言变量b一定是一个string类型的值 断言是什么? 怎么用?let a: string = 20let b: number = a as number // 会报错，不能对已经声明类型的值进行断言 怎么解决这种问题呢？ 我们可以先将 b 转换为 unknown 类型再断言 let a: string = 20let b: number = a as unknown as number voidvoid 可以是 null 或 undefined，多用于函数返回值的类型 let a: void = nulla = undefined nevernever 不是任何类型，在函数不能执行到结尾时进行类型推断 function err(): never throw new Error(err) void 和 never 的区别 void 常用作函数的返回值的推断，函数没有返回值时，可以将返回类型写为 void never 常用作 函数不能执行到末尾 时对函数类型的限制 function printString(content: any): void console.log(content)function throwError(err): never throw new Error(err) null undefinednull 和 undefined 代表的类型就是 js 中对应的 null 和 undefined let a: null = nulllet b: undefined = undefined 默认情况下 null 和 undefined 可以作为其他类型的值 let a: stringa = nulla = undefined// 这时不会报错 可以修改 tsconfig.json 文件中的配置让其不能作为其他类型的值 strictNullchecks: true"},{"title":"事件循环 / EventLoop","path":"/2024/03/16/js-EventLoop/","content":"浏览器的进程和线程进程：每个应用至少有一个进程，进程之间相互独立。线程：一个进程中包括多个线程（线程用来运行代码）。一个进程中至少有一个线程，随进程创建的线程称为主线程。如果程序需要同时执行多块代码，需要创建多个线程。 浏览器有哪些进程和线程？浏览器是一个多进程多线程的应用程序。 当浏览器启动后，会自动启动多个进程。浏览器有哪些进程呢？ 浏览器进程负责进行主界面展示（浏览器界面）、用户交互、子进程管理（其他进程都是由其产生） 网络进程负责加载网络资源 渲染进程（一个标签页对应一个渲染进程）渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。默认情况下，浏览器会为每个标签页启动新的渲染进程，保证不同标签页之间互不影响。 渲染主线程是如何工作的？渲染主线程是浏览器中最繁忙的线程，需要它处理的包括但不限于： 解析 HTML 解析 CSS 计算样式 布局 处理图层 每秒把页面绘制 60 次（FPS） 执行全局 JS 代码 执行事件处理函数 执行计时器的回调函数 …… 思考为什么不用多个线程处理这些事？ 要处理这么多任务，主线程遇到了一个难题：如何调度任务？ 比如： 正在执行一个 JS 函数，执行到一半时用户点击了按钮，要立即去执行点击事件的处理函数吗？ 正在执行一个 JS 函数，执行到一半时某个计时器到达了时间，要立即执行该计时器的回调函数吗？ 浏览器进程通知“用户点击了按钮”，与此同时，一个计时器也到达了时间，要先处理哪一个呢？ 渲染主线程说：排队，都去排队！！！ ![临时占位](.截屏 2023-10-14 17.42.50.png) 在最开始的时候，渲染主线程会进入一个无限循环while(true)... for(;;)... 每次进入循环时会判断是否有任务存在。如果有，就取出一个任务执行，执行完成后进入下一次循环；如果没有，就进入休眠状态 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会添加到消息队列末尾。在添加新任务时，如果主线程是休眠状态，这将会唤醒主线程继续循环拿去任务。 整个过程叫做事件循环（消息循环）。 何为异步代码在执行过程中，会遇到一些无法立即处理的任务，如： 计时器完成后需要执行的任务： setTimeout setInterval 网络通信完成后需要执行的任务： XHR fetch 用户操作后要执行的任务：addEventListener 如果让渲染主线程等待这些任务的时机到达，就会导致主线程长期处于阻塞状态，从而导致浏览器卡死 ![Alt text](.截屏 2023-10-14 17.54.33.png) 渲染主线程承担着极其重要的恶工作，无论如何都不能阻塞！ 因此，浏览器选择异步来解决这个问题![Alt text](.截屏 2023-10-14 18.02.01.png) 使用异步的方式，渲染主线程永不阻塞 面试题：如何理解 js 异步JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。而渲染主线程承担着诸多工作，渲染页面、执行 HTML、CSS、JS 等都在其中运行。 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中很多其他任务无法执行。这样依赖，一方面会导致繁忙的主线程白白消耗时间，另一方面导致页面无法及时更新，给用户造成卡死的现象。 所以，浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束该任务的执行，转而执行后续代码，当其他线程完成对应的任务时，将事先传递的回调函数包装成任务加入到消息队列末尾，排队等待主线程调度执行。 在这种异步模式下，浏览器用不阻塞，从而最大限度保证了单线程的流畅运行。 JS 为什么会阻碍渲染html head/head body h1wxw/h1 buttonchange name/button script const h1 = document.querySelector(h1) const btn = document.querySelector(button) function delay(duration) const start = Date.now() while (Date.now() - start duration) btn.onclick = () = h1.textContext = !!! delay(3000) /script /body/html 任务有优先级吗任务没有优先级，在消息队列中先进先出 但是消息队列是有优先级的 根据 W3C 的最新解释： 每个任务都有一个任务类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取任务执行。 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行 随着浏览器复杂度的提升，W3C 不再使用宏队列的说法。 在 chrome 的实现中，至少包含了下面的队列： 延时队列：用于存放计时器到达后的回调事件，优先级中 交互队列：用于存放用户操作后产生的事件处理任务，优先级高 微队列：用于存放需要最快执行的任务，优先级最高 添加到微任务的最主要方式是使用 Promise、MutationObserver // 立即把一个函数添加到微队列Promise.resolve().then(函数内容) 面试题：简述一下 JS 的事件循环事件循环又叫消息循环，是浏览器主线程的工作方式。 在 Chrome 的源码中，他会开启一个不会结束的 for 循环，每次循环从事件循环队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务添加到任务队列末尾即可。 过去把事件循环队列简单分为宏队列和微队列，这种说法已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列里，不同任务可以属于不同的队列。不同任务队列有不同的优先级，再每次事件循环中，由浏览器自行决定取哪一个队列的任务，但浏览器必须有一个微任务队列，微任务队列的任务一定具有最高的优先级，必须优先调度执行。 面试题：JS 计时器能做到精确计时吗？为什么？不行，因为： 计算机硬件没有原子钟，无法做到准确计时 操作系统的计时函数本就有少量的偏差，由于 JS 的计时器最终调用的是操作系统的计时函数，也就携带了这些偏差 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4ms 的最少事件，咋样在计时器少于 4ms 时又带来了偏差 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，这又带来了些许偏差"},{"title":"浏览器渲染原理","path":"/2024/03/16/js-浏览器渲染原理/","content":"什么是渲染？ 将 HTML 字符串绘制为屏幕上的像素点的过程叫渲染（render） 浏览器是如何渲染页面的当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。 整个渲染流程分为多个阶段，分别是：HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、绘制页面。 每个阶段都有明显的输入输出，上个阶段的输出会称为下一个阶段的输入。 这样，整个渲染流程就形成了一套组织严密的生产流水线。 渲染的第一步是 解析 HTML (Parse HTML)解析过程中遇到 CSS 解析 CSS、遇到 JS 执行 JS。为了提高解析效率，浏览器在解析开始前，会启动一个预解析的流程，率先下载 HTML 中的外部 CSS 文件和 JS 文件。 如果主线程解析到 link 位置，此时外部的 CSS 文件还是没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。 如果主线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 渲染的根本原因。 第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。 渲染的第二步是 样式计算主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它的最终的样式，称之为 Computed Style。 在这一过程中，很多预设值会变成绝对值，比如 red 会变成rgb(255,0,0)；相对单位会变成绝对单位，比如 em 会变成 px 这一步完成后，会得到一棵带有样式的 DOM 树。 接下来是 布局布局完成后会得到布局树。 布局阶段会依次遍历 DOM 树中的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。 大部分的时候，DOM 树和布局树并非一一对应。 比如 display:none 的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中并不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。含有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。 下一步是 分层主线程会使用一套复杂的策略对整个布局树中进行分层。 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过 will-change 属性更大程度的影响分层结果。 再下一步是 绘制主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。 再下一步是 分块完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将会由合成线程完成。 合成线程首先对每个图层进行分块，将其划分为更多的小区域。 他会从线程池中拿取多个线程来完成分块工作。 再下一步是 光栅化分块完成后，进入光栅化阶段。 合成线程会将信息交给 GPU 进程，以极高的速度完成光栅化。 GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。 光栅化的结果，就是一块一块的位图。 再下一步是 绘制最后一个阶段就是绘制了。 合成线程拿到的每个层、每个块的位图后，生成一个个指引（quad）信息。 指引会标识出每个位图应该绘制到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。 变形会发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因。 合成后会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。 什么是 reflowreflow 的本质就是重新计算 layout 树。 当进行了会影响布局树的操作后，需要重新计算布局树，会引发 reflow。 为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。 也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。 浏览器在反复权衡下，最终决定获取属性立即 reflow。 什么是 repaintrepaint 的本质就是重新根据分层信息计算了绘制指令。 当改动了可见样式后，就需要重新计算，会引发 repaint。 由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。"},{"title":"浅尝histoire","path":"/2024/03/14/浅尝histoire/","content":"安装 histoire pnpm i -D histoire @histoire/plugin-vue 创建 histoire.config.ts 配置文件 import defineConfig from histoireimport HstVue from @histoire/plugin-vueexport default defineConfig( plugins: [HstVue()],) 添加启动命令 histoire dev 开发环境启动 histoire build 打包 histoire preview 打包并预览打包结果 scripts: story:dev: histoire dev, story:build: histoire build, story:preview: histoire preview 编写 story使用.story.vue 结尾的文件会被 histoire 自动识别为 story 组件，该文件中只需要再根节点使用 Story 标签即可 script lang=ts setupimport HelloWorld from ./HelloWorld.vue/scripttemplate Story HelloWorld msg=Hello Vue 3 + Vite / /Story/template"},{"title":"vue3权限指令","path":"/2024/03/09/vue3权限指令/","content":"自定义一个权限指令来动态显示、隐藏， 详细代码可查看sable。这里只列出了主要的代码 自定义权限指令permission.ts import type App from vueimport ref, watchEffect from vueimport storeToRefs from piniaimport usePermissionStore from @/store/usePermissionStore.ts// 按钮权限export function registerPermission(app: App) const permissions = storeToRefs(usePermissionStore()) app.directive(permission, created(el: HTMLButtonElement, binding) const value = binding const buttonPermission = Array.isArray(value) ? value : [value] const visible = ref(false) watchEffect(() = visible.value = hasIntersection(permissions, buttonPermission) el.style.display = visible.value ? : none ) , )function hasIntersection(permissions: Refstring[], arr2: string[]) const map = new Map() permissions.value.forEach((item) = map.set(item, true)) return arr2.some((item) = map.get(item)) 权限 storeusePermissionStore.ts import defineStore from piniaexport const usePermissionStore = defineStore(permission, state: () = ( permissions: [], ), getters: , actions: setPermissions(permissions: string[]) this.permissions = permissions , ,) 使用permission.vue script lang=ts setup import storeToRefs from pinia const userPermissionStore = usePermissionStore() const setPermissions = userPermissionStore const permissions = storeToRefs(userPermissionStore)/scripttemplate div 自定义指令 n-divider title-placement=left 根据权限列表来展示 /n-divider div n-space n-button @click=setPermissions([read]) 设置为只有阅读权限 /n-button n-button @click=setPermissions([read, write]) 设置为阅读和修改权限 /n-button /n-space /div div mt-4 权限列表： permissions n-button v-permission=read 阅读 /n-button n-button v-permission=write 写入 /n-button /div /div/templatestyle/style 效果"},{"title":"vue3批量注册自定义指令","path":"/2024/03/07/vue3批量注册自定义指令/","content":"自定义指令可以方便的复用一些需要操作 DOM 的逻辑 创建一个 directives 文件夹，用来存放自定义指令，目录结构如下： ├── index.ts└── permission.ts permission.ts import type Directive from vueimport ref, watchEffect from vuefunction hasIntersection(arr1: any[], arr2: any[]) const map = new Map() arr1.forEach((item) = map.set(item, true)) return arr2.some((item) = map.get(item))const userPermission = [read]export default created(el: HTMLButtonElement, binding) const value = binding const buttonPermission = Array.isArray(value) ? value : [value] const visible = ref(false) watchEffect(() = visible.value = hasIntersection(userPermission, buttonPermission) el.style.display = visible.value ? : none ) , as Directive index.ts import type App, Directive from vueimport permission from ./permissionconst directives = permission, as Recordstring, Directiveexport default install(app: App) Object.keys(directives).forEach((key) = console.log(key) app.directive(key, directives[key]) ) , 在 main.ts 中注册自定义指令 import createApp from vueimport App from ./App.vueimport directives from ./directivesfunction bootstrap() const app = createApp(App) app.use(directives) app.mount(#app)bootstrap() 在页面中使用 script setup lang=ts/scripttemplate div button v-permission=[read1]hidden/button button v-permission=[read]block/button /div/templatestyle scoped/style"},{"title":"minecraft-论坛开发计划","path":"/2024/02/25/minecraft-论坛开发计划/","content":"O1 我的世界论坛开发一期 正常 0% KR1 站点导航 正常 0% KR2 赞助名单 正常 0% KR3 网站设置 正常 0%"},{"title":"二叉树","path":"/2024/02/17/algorithm-二叉树/","content":"什么是二叉树？ 前序遍历中左右 递归var preorderTraversal = function (root) = const result = [] if (root === null) return result const order = (node) = result.push(node) if(node.left !== null) order(node.left) if(node.right !== null) order(node.right) order(root) return result 9 6 8 迭代var preorderTraversal = function(root) = const result = [] if (root === null) return result const stack = [] stack.push(root) while(stack.length 0) const current = stack.pop() result.push(current.val) if (current.right !== null) stack.push(current.right) if (current.left !== null) stack.push(current.left) return result 中序遍历左中右 递归var preorderTraversal = function(root) = const result = [] if (root === null) return result const order = (node) = if (node.left !== null) order(node.left) result.push(node.val) if (node.right !== null) order(node.right) order(root) return result 迭代var preorderTraversal = function(root) = const result = [] if(root === null) return result const stack = [] let temp = root while(temp !== null) stack.push(temp) temp = temp.left while(stack.length) const current = stack.pop() result.push(current.val) if (current.right !== null) let temp2 = current.right while(temp2 !== null) stack.push(temp2) temp2 = temp2.left return result 后序遍历层序遍历"},{"title":"vite插件","path":"/2024/02/14/vite-plugins/","content":"解析 xml 文件https://github.com/rollup/plugins/tree/master/packages/yaml/#readmehttps://github.com/rollup/plugins/tree/master/packages/yaml/#readme"},{"title":"RBAC权限控制简述","path":"/2024/02/04/nest-rbac权限控制/","content":"RBAC —— 基于角色的访问控制 RBAC 演化在系统权限设置时，我们一般可以设置一个权限表 permission ，用户声明系统中所有的权限 (基础)。我们可以给用户分配不同的权限，使用 user_permission 记录用户拥有的权限。其实这就可以实现基本的权限控制了。 但是，如果我们给每一个用户都手动去分配权限，那么后期如果有相同类型的用户想要同时取消或者设置一个相同的权限时，我们就需要对所有的用户进行修改。这时，我们引入一个角色的概念。 我们可以创建一个角色，给角色赋予权限，使用 role_permission 记录角色拥有的权限。角色创建好后，我们就可以给用户分配一个或多个角色，使用 user_role 记录用户拥有的角色。 后续我们如果要取消或新增某个权限时，只需要对角色进行操作，不必对每个用户进行更改了。 这就是 RBAC 权限控制的所有流程了。 权限的查找我们在查找用户是否有权限时，从用户自身查找，如果该用户本身拥有该权限，放行。如果用户没有该权限，查找用户角色拥有的权限，如果用户的一个角色拥有该权限，放行。否则就拒绝访问。"},{"title":"控制反转和依赖注入","path":"/2024/01/21/nest-控制反转和依赖注入/","content":"控制反转 IoCIoC（inversion of Control）即控制反转，是一种设计思想。IoC 意味着将你设计好的对象交给容器控制，而不是传统的在对象内部中直接控制。 依赖注入 DIDI（Dependency Injection）即依赖注入"},{"title":"restful风格设计","path":"/2024/01/20/nest-restful风格设计/","content":"为什么要使用 RESTful 架构？ RESTful 可以充分利用 HTTP 协议的各种功能，可以让接口设计更加清晰、简洁、富有层次，可维护性更好。 API 设计风格 请求 动词 + 宾语 动词：使用 HTTP 的 5 种方法，对应 CRUD 操作 宾语： URL 应该全部使用名词复数，可以有例外，比如搜索可以使用更加直观的 search 。 过滤信息（Filtering）： 如果记录数量很多，API 应该提供参数，过滤返回结果。 ?limit10 指定返回记录的数量 ?offset10 指定返回记录的开始位置。 示例：一个用户的操作 添加用户: GET /api/users 编辑用户(更新该用户全部数据): PUT /api/users/1 编辑用户(更新用户部分数据): PATCH /api/users/1 查询用户列表: GET /api/users 查询单个用户: GET /api/users/1 删除用户: DELETE /api/users/1 响应设计 HTTP 状态码使用客户端的每一次请求，服务器都必须给出回应。回应包括 HTTP 状态码和数据两部分。 使用 不同的 HTTP 状态码表示不同类型的响应。每一种状态码都有约定的解释，客户端只需查看状态码，就可以判断出发生了什么情况。 2xx 操作成功 3xx 重定向 4xx 客户端错误 403 无权限 5xx 服务器错误 服务端数据响应客户端请求时，要明确告诉服务器，接受 JSON 格式，请求的 HTTP 头的 ACCEPT 属性要设成 applicationjson 服务端响应的数据不应该是纯文本，而应该是一个 JSON 对象。服务器回应的 HTTP 头的 Content-Type 属性要设为 applicationjson 错误处理 如果状态码是 4xx，就应该向用户返回出错信息。一般来说，返回的信息中将 error 作为键名，出错信息作为键值即可。 error: Invalid API key 认证 RESTful API 应该是无状态，每个请求应该带有一些认证凭证。推荐使用 JWT 认证，并且使用 SSL Hypermedia 即返回结果中提供链接，连向其他 API 方法，使得用户不查文档，也知道下一步应该做什么"},{"title":"为您的stellar添加medium-zoom","path":"/2024/01/14/为您的stellar添加medium-zoom/","content":"Stellar 提供的图片组件是很强大的，为什么我不使用呢？有时候我需要将 markdown 文件在各平台中都发布一次，使用 Stellar 自定义的图片组件其他平台不识别。发布时还得手动改 为什么要添加这个插件呢？Stellar 提供的图片预览真的很不错，但是为了与其他平台进行兼容，不得不使用原生的 markdown 使用方式。我又想使用图片预览，就添加了这个插件 效果示例： 点击下面的图片查看效果 插件添加直接创建一个 zoom-img.js 文件，写入以下内容 use strict// inject fonthexo.extend.injector.register(head_end, () = return ` style .medium-zoom-overlay z-index: 20; .medium-zoom-image z-index: 21; /style link href=https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/style.min.css rel=stylesheet script src=https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js/script `)hexo.extend.injector.register(body_end, function () return ` script mediumZoom(.l_body img, background: var(--site-bg) ) /script `) 使用：按照正常 markdown 图片书写方式 ![暗色主题](/assets/wiki/vscode/110247187-f1eb6780-7fa5-11eb-9258-620309e20961.png)"},{"title":"给你的vitepress添加图片预览功能","path":"/2024/01/06/给你的vitepress添加图片预览功能/","content":"这次我们在 vitepress 中添加图片预览功能！转载至：https://github.com/vuejs/vitepress/issues/854 安装 medium-zoom npm i medium-zoom 在 vitepress 主题配置文件中配置 .vitepress/theme/index.js// .vitepress/theme/index.jsimport DefaultTheme from vitepress/themeimport onMounted from vueimport mediumZoom from medium-zoomimport ./index.cssexport default ...DefaultTheme, setup() onMounted(() = mediumZoom([data-zoomable], background: var(--vp-c-bg) ) ) , 添加 css 样式 /* .vitepress/theme/index.css */.medium-zoom-overlay z-index: 20;.medium-zoom-image z-index: 21; 在 markdown 中使用 ![](path/to/file.jpg)data-zoomable 如果您想在不显式添加{data-zoomable}的情况下为所有图像启用此功能，您可以将该 mediumZoom 调用更改为： mediumZoom(.main img, background: var(--vp-c-bg) )","tags":["vitepress","转载"]},{"title":"pm2部署Nuxt3","path":"/2023/12/05/nuxt3-pm2部署Nuxt3/","content":"使用 pnpm run build 打包，默认会在项目根目录中生成一个 .output 文件夹。 .output 目录包含该项目打包后所需的全部内容，无需像 Nuxt2 将整个文件夹拷贝到对应目录中 将 .output 文件上传至服务器中，这里假设为 portal 文件夹中 进入对应目录中，配置 ecosystem.config.js 文件 cd portal touch ecosystem.config.js ecosystem.config.jsmodule.exports = apps: [ name: test-portal, exec_mode: fork, instances: 1, interpreter: /opt/homebrew/bin/node, // 这里需要换成服务器中或者本地高版本Node bin目录 script: .output/server/index.mjs, ignore_watch: [node_modules, public, logs], // 不用监听的文件 merge_logs: true, // 设置追加日志而不是新建日志 log_date_format: YYYY-MM-DD HH:mm:ss, // 指定日志文件的时间格式 min_uptime: 60s, // 应用运行少于时间被认为是异常启动 max_restarts: 30, // 最大异常重启次数 restart_delay: 60, // 异常重启情况下，延时重启时间 env_production: NODE_ENV: production, PORT: 3000, , , ], 编写 start-nuxt.sh 脚本 touch start-nuxt.sh #!/bin/bashecho pm2 startingpm2 start ecosystem.config.js --env productionecho pm2 started portal 目录文件结构 ├── ecosystem.config.js├── .output└── start-nuxt.sh 启动 sh start-nuxt.sh 停止服务 pm2 stop test-portal 可能遇到的问题使用 pm2 部署 Nuxt3 应用时报错 [nuxt] [request error] [unhandled] [500] The requested module vue does not provide an export named unref 可能是由于本地 Node 版本过低导致，升级至 18.x 或最新版本即可 如果本地有多个 node 版本，并使用 nvm 控制版本切换。可以按照下面的步骤进行更改: 可以使用 nvm use [node 版本] 切换 node 版本 which node 查看当前使用 node 版本的 bin 目录 修改 ecosystem.config.js 的 interpreter 这时，pm2 exec_mode 只能使用 fork 模式，并且只能由单核运行。"},{"title":"再观 ReLIFE 有感","path":"/2023/10/21/再看ReLIFE/","content":"如果你有能力回到过去，你会如何重来一次？ 海崎新太（27 岁）在作为新毕业生进入的公司工作了 3 个月就辞职了。之后他的就职活动也不顺利。双亲寄来的生活费也中断了，不得已只好回到乡下。能够倾听他烦恼的朋友和女友全都没有……穷途末路的海崎面前出现了一位神秘人物·夜明了。夜明向海崎提出，要他参加以尼特为对象的社会复归程序“ReLIFE”。其内容是，利用神秘的秘药，仅仅让外表回复年轻，并在一年内以高中生的身份去读高中——。 （来自哔哩哔哩番剧简介） 本身的画风、配音都很棒。尤其是动漫的选题：如果在现实世界中过的不如意可以回到过去，你会如何重新来过呢？ 恋爱、校园番的老套路：开学，心动，烟火大会都在其中，随着故事的展开，男主切实的从一个成年人的角度慢慢融入活力满满的高三生活。这些中又伴随着互相救赎，在发生事情后要勇敢面对。 如果当初我也能这样勇敢一些就好了，不用现在后悔，青春就是应该不留遗憾。 我们每个人的青春中又有多少遗憾呢？当时害羞不敢表达的青涩的爱，记忆中的那一张张笑脸，自习课中耳边的歌声…… 当然，我们不可能回到过去。过去的已经过去，未来的还未到来。珍惜当下，认真过好每一天，认真对待身边的每个人，每件事。尽自己最大的努力来完成每件自己喜欢的或者不喜欢的事。","tags":["观影体验"],"categories":["生活剪影","观后感"]},{"title":"🔗 在JavaScript中获取Fetch HTTP响应的状态码(翻译)","path":"/2023/10/13/在JavaScript中获取Fetch-HTTP响应的状态码-翻译/","content":"本文说明了如何获取 Fetch HTTP 响应的状态码 获取 Fetch HTTP 响应的状态码访问响应对象上的 status 属性以获取使用 fetch 方法发出的 HTTP 请求的状态代码。 response.status属性包含响应的 HTTP 状态代码，例如 200 表示成功响应或 500 表示服务器错误 async function makeRequest() try const response = await fetch(https://randomuser.me/api/) console.log(response.status: , response.status) // 👉️ 200 console.log(response) catch (err) console.log(err) makeRequest() 我们等待调用 fetch 方法的响应并将结果分配给响应变量。 要获取 HTTP 响应的状态代码，请访问响应对象的 status 属性。 使用 Promise.then() 而不是 async/wait这是一个使用 .then() 和 .catch() 而不是 async/wait 的示例。 function makeRequest() fetch(https://randomuser.me/api/) .then((response) = console.log(response.status: , response.status) // 👉️ 200 console.log(response) ) .catch((err) = console.log(err) )makeRequest() 响应对象上的 status 属性将仅为 HTTP 响应填充。 如果服务器根本没有响应，您遇到 CORS 错误或拼写错误的 URL，您将收到网络错误。 网络错误将运行 catch() 函数，并且不会填充 status 属性，因为它不是服务器 HTTP 响应。 使用 fetch 时处理错误的完整示例这是使用 fetch 处理请求和错误的完整示例。 async function makeRequest() try const response = await fetch(https://randomuser.me/api/) console.log(status code: , response.status) // 👉️ 200 if (!response.ok) console.log(response) throw new Error(`Error! status: $response.status`) const result = await response.json() return result catch (err) console.log(err) makeRequest() 我们使用 response.ok 属性来检查服务器是否以 200-299 范围内的状态响应。 说明如果服务器的 HTTP 响应成功（200-299），response.ok 属性的值将为 true，否则，它的值将为 false。 Fetch 本身不会拒绝 HTTP 请求的 Promise 响应，因此我们必须检查 ok 属性是否设置为 false。 如果 ok 属性设置为 false，则请求不成功，我们必须自己抛出错误。 如果有网络错误，例如 CORS 错误或与创建 HTTP 请求相关的错误，Promise 将自动被拒绝，并且我们的 catch 块将被触发。 如前所述，如果存在网络错误，则不会填充 status 属性，因为错误不是来自服务器 HTTP 响应。 我还写了一篇关于如何获取 Axios HTTP 错误的状态代码的文章。 资料您可以通过查看以下教程来了解有关相关主题的更多信息： ReferenceError: fetch is not defined in NodeJs TypeError: Failed to fetch and CORS in JavaScript [Solved] Fetch API cannot load localhost. URL scheme is not supported fetch() returns empty Response Body in JavaScript [Solved] How to get the MIME type of a File in JavaScript Node.js Chrome: How to Copy an Object or Array from the Console tab TypeError: Failed to execute ‘fetch’ on ‘Window’ [Solved] How to POST Form Data using the JavaScript Fetch API","tags":["JavaScript","Fetch"],"categories":["代码人生","文章翻译"]},{"title":"markdown基础","path":"/2023/08/30/markdown基础/","content":"markdown 是一种轻量级的文本标记语言，提供一系列简单的标记使我们可以专注于内容进行创作。 标题一般我们可以使用#{1~6}来表示 1~6 级的标题 书写 # 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 示例 一级标题二级标题三级标题四级标题五级标题六级标题段落及文本特殊格式每行文本都是一个段落，分段时我们需要使用两个以上空格加上一个回车，或者使用两个以上回车进行分段。 加粗 使用__或者**将文本包裹可以实现 粗体 **加粗** 斜体 使用_或者*将文本包裹可以实现 斜体 _斜体_ 分隔线 使用三个以上的-或者*可以实现分隔线 删除线 使用~~将文本包裹可以实现 删除线 下划线 使用u/u将文本包裹可以实现 下划线 列表无序列表使用-开头 书写- 起床- 吃饭- 睡觉- 玩游戏 示例 起床 吃饭 睡觉 玩游戏 有序列表使用数字开头 书写1. 起床2. 吃饭3. 睡觉 示例 起床 吃饭 睡觉 块引用块书写 这里是引用 示例 这里是引用 代码块书写```javascriptconst a = 20``` 示例const a = 20 链接和图片链接使用[标题](链接地址)表示 whbbit 博客 图片使用 Stellar 会自动编译格式，markdown 图片引入就是链接引用前添加一个! 表格表格第一行表示表头，第二行表示对齐方式。后面每一行就是表格的一行 对齐方式默认是左对齐 :---右对齐 ---:居中对齐 :---: 书写| 作者 | 书名 || :----- | :--- || 刘慈欣 | 三体 | 示例 作者 书名 刘慈欣 三体"},{"title":"对接下来生活的一些思考","path":"/2023/06/18/对接下来生活的一些思考/","content":"真的只有打工这一条路吗？显然不是的，但是勇气从来是我缺乏的气质。 今天看了学长最新拍摄的视频，感慨良多。不知不觉间他从一个月入几千的打工仔变成了月入十几万的老板。而我也从一个不知道干什么好的大专生进入了编程这行。 我是在他程序员找工作时关注的他，从他自学找工作到离职干自媒体，总能感觉到了他学习能力很强，对世界有自己的理解，而且对事情有一些自己的想法并且能付诸现实。他总是有着我没有的勇气去做一些平常人看来不务正业的事。 这几年看着学长从开始时回村不被他人理解，到后面视频里随口说出的月入十几万轻轻松松。这不排除可能有一部分是对于他自己商业上的考虑，但确实能感到他这几年物质方面的变化。 就像他自己说的，人生 20-30 这十几年好像真的是值得思考的一段时间。这期间没有太大的经济压力，可以趁机做一些尝试。 我想，是不是可以尝试一下？我有没有足够的勇气来干这件事？开始做事后会不会坚持下来呢？？？","tags":["思考"],"categories":["生活剪影","悄悄话"]},{"title":"世界各地手机区号","path":"/2023/06/14/世界各地手机区号/","content":"这时一份可以直接用于 ant design select 的世界各地手机区号的 options，已经做了去重工作 export const PhonePrefixOptions = [ label: 中国大陆, value: +86 , label: 香港, value: +852 , label: 澳门, value: +853 , label: 台湾, value: +886 , label: 韩国, value: +82 , label: 日本, value: +81 , label: 美国/加拿大, value: +1 , // label: 加拿大, value: +1 , // label: 波多黎各(美), value: +1 , label: 英国, value: +44 , label: 新加坡, value: +65 , label: 马来西亚, value: +60 , label: 泰国, value: +66 , label: 越南, value: +84 , label: 菲律宾, value: +63 , label: 印度尼西亚, value: +62 , label: 意大利, value: +39 , label: 俄罗斯/哈萨克斯坦, value: +7 , // label: 哈萨克斯坦, value: +7 , label: 新西兰, value: +64 , label: 荷兰, value: +31 , label: 瑞典, value: +46 , label: 澳大利亚, value: +61 , // label: 圣诞岛, value: +61 , // label: 科科斯岛, value: +61 , label: 乌克兰, value: +380 , label: 法国, value: +33 , label: 德国, value: +49 , label: 阿富汗, value: +93 , label: 阿尔巴尼亚, value: +355 , label: 阿尔及利亚, value: +213 , label: 东萨摩亚(美), value: +1684 , label: 安道尔, value: +376 , label: 安哥拉, value: +244 , label: 安圭拉岛(英), value: +1264 , label: 安提瓜和巴布达, value: +1268 , label: 阿根廷, value: +54 , label: 亚美尼亚, value: +374 , label: 阿鲁巴岛, value: +297 , label: 奥地利, value: +43 , label: 阿塞拜疆, value: +994 , label: 巴林, value: +973 , label: 孟加拉国, value: +880 , label: 巴巴多斯, value: +1246 , label: 白俄罗斯, value: +375 , label: 比利时, value: +32 , label: 伯利兹, value: +501 , label: 贝宁, value: +229 , label: 百慕大群岛(英), value: +1441 , label: 不丹, value: +975 , label: 玻利维亚, value: +591 , label: 波斯尼亚和黑塞哥维那, value: +387 , label: 博茨瓦纳, value: +267 , label: 巴西, value: +55 , label: 保加利亚, value: +359 , label: 布基纳法索, value: +226 , label: 布隆迪, value: +257 , label: 喀麦隆, value: +237 , label: 佛得角, value: +238 , label: 开曼群岛(英), value: +1345 , label: 中非, value: +236 , label: 乍得, value: +235 , label: 智利, value: +56 , label: 哥伦比亚, value: +57 , label: 科摩罗, value: +269 , label: 刚果, value: +242 , label: 科克群岛(新), value: +682 , label: 哥斯达黎加, value: +506 , label: 克罗地亚, value: +385 , label: 古巴, value: +53 , label: 塞浦路斯, value: +357 , label: 捷克, value: +420 , label: 丹麦, value: +45 , label: 吉布提, value: +253 , label: 多米尼克国, value: +1767 , label: 多米尼加共和国, value: +1809 , label: 厄瓜多尔, value: +593 , label: 埃及, value: +20 , label: 萨尔瓦多, value: +503 , label: 赤道几内亚, value: +240 , label: 厄立特里亚, value: +291 , label: 爱沙尼亚, value: +372 , label: 埃塞俄比亚, value: +251 , label: 福克兰群岛, value: +500 , label: 法罗群岛(丹), value: +298 , label: 斐济, value: +679 , label: 芬兰, value: +358 , label: 法属波里尼西亚, value: +689 , label: 加蓬, value: +241 , label: 冈比亚, value: +220 , label: 格鲁吉亚, value: +995 , label: 加纳, value: +233 , label: 直布罗陀(英), value: +350 , label: 希腊, value: +30 , label: 格陵兰岛, value: +299 , label: 格林纳达, value: +1473 , label: 瓜德罗普岛(法), value: +590 , label: 关岛(美), value: +1671 , label: 危地马拉, value: +502 , label: 几内亚, value: +224 , label: 几内亚比绍, value: +245 , label: 圭亚那, value: +592 , label: 海地, value: +509 , label: 洪都拉斯, value: +504 , label: 匈牙利, value: +36 , label: 冰岛, value: +354 , label: 印度, value: +91 , label: 伊郎, value: +98 , label: 伊拉克, value: +964 , label: 爱尔兰, value: +353 , label: 以色列, value: +972 , label: 科特迪瓦, value: +225 , label: 牙买加, value: +1876 , label: 约旦, value: +962 , label: 柬埔塞, value: +855 , label: 肯尼亚, value: +254 , label: 基里巴斯, value: +686 , label: 科威特, value: +965 , label: 吉尔吉斯斯坦, value: +996 , label: 老挝, value: +856 , label: 拉脱维亚, value: +371 , label: 黎巴嫩, value: +961 , label: 莱索托, value: +266 , label: 利比里亚, value: +231 , label: 利比亚, value: +218 , label: 列支敦士登, value: +423 , label: 立陶宛, value: +370 , label: 卢森堡, value: +352 , label: 马其顿, value: +389 , label: 马达加斯加, value: +261 , label: 马拉维, value: +265 , label: 马尔代夫, value: +960 , label: 马里, value: +223 , label: 马耳他, value: +356 , label: 马绍尔群岛, value: +692 , label: 马提尼克(法), value: +596 , label: 毛里塔尼亚, value: +222 , label: 毛里求斯, value: +230 , label: 马约特岛, value: +262 , label: 墨西哥, value: +52 , label: 密克罗尼西亚(美), value: +691 , label: 摩纳哥, value: +377 , label: 蒙古, value: +976 , label: 蒙特塞拉特岛(英), value: +1664 , label: 摩洛哥, value: +212 , label: 莫桑比克, value: +258 , label: 缅甸, value: +95 , label: 纳米比亚, value: +264 , label: 瑙鲁, value: +674 , label: 尼泊尔, value: +977 , label: 荷属安的列斯群岛, value: +599 , label: 新喀里多尼亚群岛(法), value: +687 , label: 尼加拉瓜, value: +505 , label: 尼日尔, value: +227 , label: 尼日利亚, value: +234 , label: 纽埃岛(新), value: +683 , label: 诺福克岛(澳), value: +672 , label: 朝鲜, value: +850 , label: 马里亚纳群岛, value: +1670 , label: 挪威, value: +47 , label: 阿曼, value: +968 , label: 巴基斯坦, value: +92 , label: 帕劳(美), value: +680 , label: 巴拿马, value: +507 , label: 巴布亚新几内亚, value: +675 , label: 巴拉圭, value: +595 , label: 秘鲁, value: +51 , label: 波兰, value: +48 , label: 葡萄牙, value: +351 , label: 卡塔尔, value: +974 , label: 摩尔多瓦, value: +373 , label: 留尼汪岛, value: +262 , label: 罗马尼亚, value: +40 , label: 卢旺达, value: +250 , label: 阿森松(英), value: +247 , label: 圣赫勒拿, value: +290 , label: 圣克里斯托弗和尼维斯, value: +1869 , label: 圣卢西亚, value: +1758 , label: 圣皮埃尔岛及密克隆岛, value: +508 , label: 圣文森特岛(英), value: +1784 , label: 西萨摩亚, value: +685 , label: 圣马力诺, value: +378 , label: 圣多美和普林西比, value: +239 , label: 沙特阿拉伯, value: +966 , label: 塞内加尔, value: +221 , label: 塞舌尔, value: +248 , label: 塞拉利昂, value: +232 , label: 斯洛伐克, value: +421 , label: 斯洛文尼亚, value: +386 , label: 所罗门群岛, value: +677 , label: 索马里, value: +252 , label: 南非, value: +27 , label: 西班牙, value: +34 , label: 斯里兰卡, value: +94 , label: 苏丹, value: +249 , label: 苏里南, value: +597 , label: 斯威士兰, value: +268 , label: 瑞士, value: +41 , label: 叙利亚, value: +963 , label: 塔吉克斯坦, value: +992 , label: 巴哈马国, value: +1242 , label: 梵蒂冈, value: +14397 , label: 多哥, value: +228 , label: 汤加, value: +676 , label: 特立尼达和多巴哥, value: +1868 , label: 突尼斯, value: +216 , label: 土耳其, value: +90 , label: 土库曼斯坦, value: +993 , label: 特克斯和凯科斯群岛(英), value: +1649 , label: 图瓦卢, value: +688 , label: 乌干达, value: +256 , label: 坦桑尼亚, value: +255 , label: 乌拉圭, value: +598 , label: 乌兹别克斯坦, value: +998 , label: 瓦努阿图, value: +678 , label: 委内瑞拉, value: +58 , label: 维尔京群岛(英), value: +1340 , label: 也门, value: +967 , label: 南斯拉夫, value: +381 , label: 赞比亚, value: +260 , label: 桑给巴尔, value: +259 , label: 津巴布韦, value: +263 ,]","tags":["react","ant-design"],"categories":["代码人生","前端技术"]},{"title":"我与前端那些事","path":"/2023/05/13/video-我与前端那些事/","content":"我与前端那些事，以及分享一下我学习的资源。 我为什么学了前端 在我上大学的时候（2017 年），第一次接触到编程是军训的时候有培训机构来我们学校宣讲，讲的就是 H5 在当前的发展和使用。这时候还不知道我与前端这么有缘，在三年的学习中我们先后学习了 HTML+CSS+JavaScript， C，Java，C#，vb。但是令我印象最深的还是我们有教 Java 的老师布置的一次课程：在慕课网上仿照一个页面用 HTML5+CSS 复刻出来。平常 Java 做的项目都是在控制台输入一些东西，或者是做一些简单的系统，第一次做出一个可以展示的漂亮的页面的时候我很兴奋。 C#的话，我们学习的时候一直都是在把组建拖出来组成一些页面，交互效果不好。所以我也没太大兴趣。在校期间被学校学习的 Jsp 搞吐了（各种嵌套），所以对后端的印象不是很好。后面我就专搞前端去了。 怎么学习前端 在这个时代，我们学习一项技能完全可以在网上找到任何资料。自制力不强的同学，可以组个小队一起互相监督学习。 培训班的话我感觉没有必要。 学完的东西一定要及时变成可以展示的东西，这样你的成就感就会很强，有及时的正反馈会让学习变得更加轻松。 推荐 up 主 这里我列举一下我学习前端看的一些视频和博主，供您参考 后盾人教程 HTML 系列课程 CSS 系列课程 JS 系列课程 向军大叔的免费视频或者付费视频（很便宜，最多的也就 50 块左右）都是精品。 全栈之巅 Nodejs + Vue 相关项目视频 全栈之巅的视频各个都是精华，比很多付费课程讲的都好。你在这里可以学到很多架构的思想，不只局限于前端这一领域。而且代码风格优雅，百看不厌。 峰华前端工程师 React 完全指南 Vue 3.x 全家桶 完全指南+实战 React 即时通信 UI 开发实战课程 看峰华的视频会掌握很多公司实际会使用的技术，学习到很多组件封装的思想。而且视频节奏快，没有废话。 推荐书籍 我不怎么看书，所以就推荐几本我看过的 JavaScript 忍者秘籍","tags":["视频脚本","前端学习"],"categories":["自媒体","视频脚本"]},{"title":"出发","path":"/2023/04/30/出发/","content":"自 22 年 11 月离职至今已半年有余，是时候出去看看了。 这半年内经历了疫情整体放开后的感染。在上学到现在最长时间的停留在家，我终于找到了家最初的样子。 父亲的心脏问题也告一段落，我的驾照也考好了。 再呆在家就没什么必要了，一来是身上钱不多了，二来也是时候再出去闯闯了。","categories":["生活剪影","悄悄话"]},{"title":"macos使用","path":"/2023/04/17/macos使用/","content":"关闭指定端口查看对应端口的详细信息 lsof -i:[host] 找到对应的 pid，使用 kill 关闭 kill -9 [pid]"},{"title":"mysql 学习笔记","path":"/2023/04/07/mysql-学习笔记/","content":"数据维护修改表名ALERT TABLE stu RENAME stus;--- orRENAME TABLE stus to stu; 修改字符集---CREATE table stu_bak SELECT * FROM stu;ALERT table stu_bak charset utf8;ALERT table stu charset gbk; 多表关联一对多多对一多对多","categories":["代码人生","数据库"]},{"title":"Flutter 抓虫记","path":"/2023/04/06/flutter-开发问题/","content":"本新手使用 flutter 时遇到的一些问题合集 使用真机调试时，一直处于 Running Gradle task assembleDebug... 状态 是不是没有安装手机对应的安卓版本呢？安装后试一下","tags":["flutter"],"categories":["代码人生","前端技术"]},{"title":"screen使用","path":"/2023/03/31/screen使用/","content":"对于 使用 frp 将本地 mc 服务器映射到公网 文章中使用 screen 的说明和 screen 的简单使用 创建 screen 窗口并命名 screen -S 名称 查看 screen 列表 screen -list screen -ls 恢复 screen 会话 screen -r 从 screen 会话中脱离 ctrl + a d"},{"title":"使用frp将本地mc服务器映射到公网","path":"/2023/03/31/使用frp将本地mc服务器映射到公网/","content":"最近买了一个迷你主机，想着用来搭建一个 minecraft 服务器用来和朋友们一起联机，搭建好了才发现好像没什么玩 minecraft 的朋友了。 我这里使用的都是 Ubuntu 系统，就按这个来操作吧 两端都需要的操作安装 frp从 GitHub 下载 frp wget https://github.com/fatedier/frp/releases/download/v0.48.0/frp_0.48.0_linux_amd64.tar.gz 解压到本地 tar -zxvf frp_0.48.0_linux_amd64.tar.gz 将解压后的文件夹复制一份出来并重命名来操作 cp -r frp_0.48.0_linux_amd64 frp 安装 screensudo apt install screen 服务端操作（公网云服务）进入 frp 目录并编辑 frps.ini 文件 [common]bind_port = 7000vhost_http_port = 8080 创建 screen 并且启动 frp # 新建一个screen窗口并且命名为 minecraft-frpscreen -S minecraft-frp # 启动frpcd frpsudo ./frps -c frps.ini 记得在云服务防火墙中开启 7000 和 25565 端口 本地服务端操作进入 frp 目录并更改 frpc.ini 文件 [common]server_addr = 云服务器公网ipserver_port = 7000[minecraft]type = tcplocal_ip = 127.0.0.1local_port = 25565remote_port = 25565 本地 Ubuntu 服务器开启对应端口 sudo ufw allow 7000sudo ufw allow 25565 创建 screen 并且启动 frp # 新建一个screen窗口并且命名为 minecraft-client-frpscreen -S minecraft-client-frp # 启动frpcd frpsudo ./frpc -c frpc.ini 结语在做完上面的操作后，就可以使用公网 ip 来链接 mc 服务器了。如果你有域名，也可以使用使用域名解析到对应的 ip。 叫上你的伙伴一起来玩吧！！！"},{"title":"医院见闻录","path":"/2023/03/31/医院见闻录/","content":"医院，真的是长见识的地方。 三月份考完驾驶证后，和父亲一起去太原查一下之前晕倒的原因。在这里，我经历了很多。"},{"title":"linux工具","path":"/2023/03/29/linux工具/","content":"使用命令行工具 htop 查看系统占用 安装： sudo apt install htop 效果：","categories":["代码人生","Linux/运维"]},{"title":"gitlab搭建","path":"/2023/03/29/gitlab搭建/","content":"这两天买了一个零刻的小主机用来练习 linux 系统的使用，顺便搭建一个 gitlab 仓库，用来学习 gitlab 的自动集成。 安装环境和 gitlab安装 ssh 用于远程连接 安装 gitlab wget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/bionic/gitlab-ce_15.4.3-ce.0_amd64.deb/download.deb​sudo dpkg -i gitlab-ce_15.4.3-ce.0_amd64.deb 安装成功后 gitlab 的 logo 和名字会出现在命令行中 登录安装完成后我们需要进入 /etc/gitlab/initial_root_password 查看初始密码 sudo vim /etc/gitlab/initial_root_password 初始用户是 root"},{"title":"degit -- 拉取项目（不包含提交记录）","path":"/2023/03/28/degit/","content":"使用开源项目进行代码拉取时，我们不想要之前的提交记录该怎么办呢？ npm： https://www.npmjs.com/package/degit?activeTab=readmehttps://www.npmjs.com/package/degit?activeTab=readme 简单使用 在使用时，我们需要先在本地全局安装 npm install -g degit 安装成功后，我们可以使用命令安装项目 degit [用户名/仓库] [本地项目名称] 这里我们使用 degit 安装 sable admin 来测试一下 degit Whbbit1999/sable.git sableAdmin 进入项目我们可以发现，这时我们没有对应的 git 提交记录了。我们可以开心的进行二次开发了 cd sableAdmin"},{"title":"js拾遗--map","path":"/2023/03/01/js拾遗--map/","content":"map 函数的第二个参数map 可以传递第二个参数，第二个参数的值会赋值给当前 this const lesson = name: 课程, lessons: [js, ts, vue], show() return this.lessons.map(function (lesson) return this.name + - + lesson , this) ,console.log(lesson.show()) 当然，我们可以使用箭头函数 箭头函数的 this 就是函数执行上下文 - 父级作用域的 this const lesson = name: 课程, lessons: [js, ts, vue], show() return this.lessons.map((lesson) = this.name + - + lesson) ,console.log(lesson.show())","tags":["js"],"categories":["代码人生","前端技术"]},{"title":"大同博物馆游览留念","path":"/2023/02/11/大同博物馆游览留念/","content":"2023 年 2 月 1 日，随老姐去大同游玩。经历了三年的疫情生活，山西今年在春节和元宵的庆祝活动中规模空前，去哪里都是人山人海，好热闹。第一天的大同古城墙、社火表演（有踩高跷、舞狮、杂技之类），我们还逛了大同古城步行街。 大同古城一角 在 2023 年 2 月 2 日返家前，我们去大同博物馆参观了一下。博物馆里的北魏墓葬出土文物、原始人遗迹、恐龙等都很好看。下面是我在博物馆里拍的一些照片（共计 76 张）。 备注我的服务器配置很低，图片加载可能有些慢，你也可以去我的哔哩哔哩专栏中去看 图片太大了，服务器有点撑不住了，先下线了。","tags":["照片","游览"],"categories":["生活剪影"]},{"title":"react useCallback使用","path":"/2023/02/09/react-useCallback使用/","content":"近日在写 React 轮播图组件时遇到自动轮播的问题，在多方请教后，使用 useCallback 解决 轮播图组建需要自动轮播，我想到了使用 setTimeout 来解决 setInterval 可能越来越快的问题。心里想着：这我还不轻松拿下？一番奋战后于是就有了以下代码 const Swiper: React.FCSwiperProps = (props) = const autoplay, duration, = props; const [currentIndex, setCurrentIndex] = useStatenumber(0); const [timer, setTimer] = useStatenumber(); const childrenLength = React.Children.count(children); function next() if (currentIndex childrenLength - 2) setCurrentIndex(0); else setCurrentIndex(currentIndex + 1); function prev() if (currentIndex = 0) setCurrentIndex(childrenLength - 1); else setCurrentIndex(currentIndex - 1); // TODO autoplay function autoPlay() if (autoplay) Array(React.Children.count(children)) .fill(0) .forEach(() = return new Promise((resolve) = const timerId = setTimeout(() = next(); , duration); setTimer(timerId); resolve(true); ); ); useEffect(() = autoPlay(); // error return () = if (autoplay) clearTimeout(timer); ; , [timer, currentIndex, autoplay]); return ( ...组建内容 );;Swiper.defaultProps = ...;export default Swiper; 报错Warning: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn’t have a dependency array, or one of the dependencies changes on every render 这时会报错且页面不能加载（报错详情见上文）。在我询问了群里的大佬后，得知有一个 useCallback 貌似可以解决我的问题。 于是按着大佬的思路，我做了如下改造: 使用 useCallback 将 next 和 autoPlay 进行了一次包装。 > 为什么要使用 useCallback 将 next 函数也进行改造呢？ > 警告不使用 useCallback 将 next 进行包裹会有如下报错： Warning: Maximum update depth exceeded. This can happen when a component calls setState inside useEffect, but useEffect either doesn’t have a dependency array, or one of the dependencies changes on every render const next = useCallback(() = if (currentIndex childrenLength - 2) setCurrentIndex(0); else setCurrentIndex(currentIndex + 1); , [currentIndex, childrenLength]); useEffect(() = // autoPlay(); // error const autoPlay = useCallback(() = const timer = setTimeout(() = next(); autoPlay(); , duration); return () = if (autoplay) clearTimeout(timer); ; , [timer, currentIndex, autoplay]); , [duration, next, autoplay]); useEffect(() = if (autoplay) autoPlay(); , [autoplay, autoPlay]); 嘿嘿，有问题不能自己死磕，还是得问问！","tags":["react"],"categories":["代码人生","前端技术"]},{"title":"驾照考试记录","path":"/2023/02/08/驾照考试记录/","content":"要考驾驶证了，但是我好像什么都不懂。用这篇文章记录一下学习驾照的经历。 说明这里都是网上搜罗和我自己整理的的各种科目一考试秘籍 科目一缩写 记忆单词可以方便的记忆缩写 W - warning 警告、预警A - auto 自动T - traffic 交通B - braking 制动、刹车T - time 实时L - lane\t道路B - blind\t盲F - front\t前方S - sign\t标志M - message\t信息S - stability\t稳定（找P也行） 预警warm信息massage盲blind自动autonomous标志sign控制control稳定stability制动brake电子electric系统system道路lane 道路有关 L 车道偏离预警 L(离)DW 自动变道复制 ALC 预警 W 车道偏离预警 L(离)DW 自动有关 A 开头 自适应巡航 ACC 自动变道辅助 ALC 前照灯系统 AFS 电子有关 E 巡航有关 CC 定速巡航 CCS 自适应巡航 ACC 扣分 扣1分扣3分扣6分扣9分扣12分（一）驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路以外的道路上行驶超过规定时速百分之十以上未达到百分之二十的； （二）驾驶机动车不按规定会车，或者在高速公路、城市快速路以外的道路上不按规定倒车、掉头的； （三）驾驶机动车不按规定使用灯光的； （四）驾驶机动车违反禁令标志、禁止标线指示的； （五）驾驶机动车载货长度、宽度、高度超过规定的； （六）驾驶载货汽车载物超过最大允许总质量未达到百分之三十的； （七）驾驶未按规定定期进行安全技术检验的公路客运汽车、旅游客运汽车、危险物品运输车辆以外的机动车上道路行驶的； （八）驾驶擅自改变已登记的结构、构造或者特征的载货汽车上道路行驶的 （九）驾驶机动车在道路上行驶时，机动车驾驶人未按规定系安全带的； （十）驾驶摩托车，不戴安全头盔的。（一）驾驶校车、公路客运汽车、旅游客运汽车、7 座以上载客汽车以外的其他载客汽车载人超过核定人数百分之二十以上未达到百分之五十的； （二）驾驶校车、中型以上载客载货汽车、危险物品运输车辆以外的机动车在高速公路、城市快速路以外的道路上行驶超过规定时速百分之二十以上未达到百分之五十的； （三）驾驶机动车在高速公路或者城市快速路上不按规定车道行驶的； （四）驾驶机动车不按规定超车、让行，或者在高速公路、城市快速路以外的道路上逆行的； （五）驾驶机动车遇前方机动车停车排队或者缓慢行驶时，借道超车或者占用对面车道、穿插等候车辆的； （六）驾驶机动车有拨打、接听手持电话等妨碍安全驾驶的行为的； （七）驾驶机动车行经人行横道不按规定减速、停车、避让行人的； （八）驾驶机动车不按规定避让校车的； （九）驾驶载货汽车载物超过最大允许总质量百分之三十以上未达到百分之五十的，或者违反规定载客的； （十）驾驶不按规定安装机动车号牌的机动车上道路行驶的； （十一）在道路上车辆发生故障、事故停车后，不按规定使用灯光或者设置警告标志的； （十二）驾驶未按规定定期进行安全技术检验的公路客运汽车、旅游客运汽车、危险物品运输车辆上道路行驶的； （十三）驾驶校车上道路行驶前，未对校车车况是否符合安全技术要求进行检查，或者驾驶存在安全隐患的校车上道路行驶的； （十四）连续驾驶载货汽车超过 4 小时未停车休息或者停车休息时间少于 20 分钟的； （十五）驾驶机动车在高速公路上行驶低于规定最低时速的。（一）驾驶校车、公路客运汽车、旅游客运汽车载人超过核定人数未达到百分之二十，或者驾驶 7 座以上载客汽车载人超过核定人数百分之二十以上未达到百分之五十，或者驾驶其他载客汽车载人超过核定人数百分之五十以上未达到百分之百的； （二）驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路上行驶超过规定时速未达到百分之二十，或者在高速公路、城市快速路以外的道路上行驶超过规定时速百分之二十以上未达到百分之五十的； （三）驾驶校车、中型以上载客载货汽车、危险物品运输车辆以外的机动车在高速公路、城市快速路上行驶超过规定时速百分之二十以上未达到百分之五十，或者在高速公路、城市快速路以外的道路上行驶超过规定时速百分之五十以上的； （四）驾驶载货汽车载物超过最大允许总质量百分之五十以上的； （五）驾驶机动车载运爆炸物品、易燃易爆化学物品以及剧毒、放射性等危险物品，未按指定的时间、路线、速度行驶或者未悬挂警示标志并采取必要的安全措施的； （六）驾驶机动车运载超限的不可解体的物品，未按指定的时间、路线、速度行驶或者未悬挂警示标志的； （七）驾驶机动车运输危险化学品，未经批准进入危险化学品运输车辆限制通行的区域的； （八）驾驶机动车不按交通信号灯指示通行的； （九）机动车驾驶证被暂扣或者扣留期间驾驶机动车的； （十）造成致人轻微伤或者财产损失的交通事故后逃逸，尚不构成犯罪的； （十一）驾驶机动车在高速公路或者城市快速路上违法占用应急车道行驶的。（一）驾驶 7 座以上载客汽车载人超过核定人数百分之五十以上未达到百分之百的； （二）驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路以外的道路上行驶超过规定时速百分之五十以上的； （三）驾驶机动车在高速公路或者城市快速路上违法停车的； （四）驾驶未悬挂机动车号牌或者故意遮挡、污损机动车号牌的机动车上道路行驶的； （五）驾驶与准驾车型不符的机动车的； （六）未取得校车驾驶资格驾驶校车的； （七）连续驾驶中型以上载客汽车、危险物品运输车辆超过 4 小时未停车休息或者停车休息时间少于 20 分钟的。（一）饮酒后驾驶机动车的； （二）造成致人轻伤以上或者死亡的交通事故后逃逸，尚不构成犯罪的； （三）使用伪造、变造的机动车号牌、行驶证、驾驶证、校车标牌或者使用其他机动车号牌、行驶证的； （四）驾驶校车、公路客运汽车、旅游客运汽车载人超过核定人数百分之二十以上，或者驾驶其他载客汽车载人超过核定人数百分之百以上的； （五）驾驶校车、中型以上载客载货汽车、危险物品运输车辆在高速公路、城市快速路上行驶超过规定时速百分之二十以上，或者驾驶其他机动车在高速公路、城市快速路上行驶超过规定时速百分之五十以上的； （六）驾驶机动车在高速公路、城市快速路上倒车、逆行、穿越中央分隔带掉头的； （七）代替实际机动车驾驶人接受交通违法行为处罚和记分牟取经济利益的。 超速扣分 条件 超速 扣分 非高速 10%-20% 1 高速，非校车、载货、危险运输 10%-20% 3 高速，校车、载货、危险运输 20% 6 非高速，校车、载货、危险运输 20%-50% 6 超员超载扣分 车型 超员 扣分 普通车 100% 12 50%-100% 6 20%-50% 3 7 坐以上 100% 12 50%-100% 9 20%-50% 6 校车、旅游车、公路客运 100% 12 20%以上 12 20%以下 6 超载 扣分 50% 6 30%-50%，违反规定载客 3 30%以下 1 红高蓝低黄建议 转弯让真行。右转让左转，本车让所有车 实线不能跨越 时间相关题目 假 1 吊 2 撤 3 毒 3 醉 5 犯罪逃 终生 【年份计算】 驾驶 4 小时，休息 20 分钟 实习期 1 年，有效期 6 年 10 年和长期 换证提前 90 天，信息变换 30 天，损毁无法辨认 30 天，报废提前 2 个月 年龄：小 18 轻 20 重 22 速度题急弯路、上陡坡、下陡坡、急转弯、涉水路、复杂交通，不超过 30kmh （没有道路中心线）城 3 公 4，（有道路中心线）城 5 公 7 车距问题高速路上： 261 能见度200米，速度不能超过 60km/h，车距不能 100m 145 能见度100米，速度不能超过 40km/h，车距不能 50m 520 能见度50米， 速度不能超过 20km/h，应尽快离开高速 口 5 站 3 灯光问题夜间在视线较差的路口转弯时，应该在离路口 30-100 米时关闭远光灯，开启近光灯和转向灯，进入路口前降低车速，不断变换远、近光灯，确保安全通过。 扣款问题 考试中一年，取得后三年，假一吊二撤三醉五逃终生 机动车驾驶人在实习期内单独上高速行驶扣 20-200 处二百元以上五百元以下罚款： （一）机动车驾驶证被依法扣押、扣留或者暂扣期间，采用隐瞒、欺骗手段补领机动车驾驶证的； （二）机动车驾驶人身体条件发生变化不适合驾驶机动车，仍驾驶机动车的； （三）逾期不参加审验仍驾驶机动车的。有第一款第一项、第二项规定情形之一的，由公安机关交通管理部门收回机动车驾驶证。 处二十元以上二百元以下罚款：（一）机动车驾驶人补换领机动车驾驶证后，继续使用原机动车驾驶证的；（二）在实习期内驾驶机动车不符合第七十七条规定的；（三）持有大型客车、重型牵引挂车、城市公交车、中型客车、大型货车驾驶证的驾驶人，未按照第八十一条规定申报变更信息的。 有第一款第一项规定情形的，由公安机关交通管理部门收回原机动车驾驶证。 申请人隐瞒有关情况或者提供虚假材料申领机动车驾驶证的，公安机关交通管理部门不予受理或者不予办理，处五百元以下罚款；申请人在一年内不得再次申领机动车驾驶证。 申请人在考试过程中有贿赂、舞弊行为的，取消考试资格，已经通过考试的其他科目成绩无效，公安机关交通管理部门处二千元以下罚款；申请人在一年内不得再次申领机动车驾驶证。 其他满分考试 满 12 分，小车参加满分教育，现场 2 天，一共 7 天 满 24 分，参加科目一、科目三 满 36 分，参加科目一、科目二、科目三 12 分只需学习，24 分则需参加道路考试，36 分那就又要参加场地，又要参加道路考试 累计 24 是对的，合格后需要 10 日内参加道路技能考试合格发证 牵挂驾驶车年龄，20 至 60！！！ 代 3 超 5 年不得考 身体证明六个月有效 更新的题是撞了没死扣 6 分，死了扣 12 分，逃跑都是没有罪的。 机动车登记应提交的 5 项证明、凭证：(一)机动车所有人的身份证明；(二)机动车来历证明；(三)机动车整车出厂合格证明或者进口机动车进口凭证；(四)车辆购置税的完税证明或免税凭证；(五)法律、行政法规规定应当在机动车登记时提交的其他证明、凭证。 高速超半扣光光，高速违停扣 9 分 扣 1 分的口诀：行灯会，禁检安。 超过规定时速 20%以上，未达 50%的 普通道路 3 分 高速 6 分 百分百 12 分 😁 超载百分百扣 12 借道超车扣三分 小型汽车驾驶人在一个记分周期内二次累积记分满 12 分或者累积记分满 24 分未满 36 分的，应当在道路交通安全法律、法规和相关知识考试合格后，在取得学习驾驶证明满三十日后预约科目三考试。考试不合格的，十日后预约重新考试。 考试预约时间，科二考过约科三，自动 20 手动 30 申请增驾轻 1 重 2 大 3 百分之二十至百分之五十，小型的，扣三分，座椅上的扣六， 撞了人没逃逸的，3 年以下，撞了人逃逸的 3 年以上，7 年以下，撞了人逃逸的导致人死亡的 7 年以上有期徒刑。 题目练习情况 速度题（58 题） 罚款题（48 题） 标志题（314 题） 记分题（55 题） 标线题（92 题） 灯光使用题（110 题） 高速公路题（125 题） 安全常识题（97 题） 道路通行原则题（127 题） 特殊天气题（44 题） 文明驾驶题（132 题） 易混标志题（72 题） 易混指示灯题（22 题） 意外事故处理题（68 题） 责任判定题（104 题） 驾驶证相关题（267 题） 现场急救题（35 题） 扣分罚款题（252 题） 仪表、指示灯题（123 题） 普通路段题（65 题） 特殊路段题（90 题） 交通信号灯题（83 题） 交警手势题（14 题） 机动车登记（47 题） 车辆功能英文缩写（15 题）"},{"title":"vue3自动引入图标","path":"/2023/02/05/vue3自动引入图标/","content":"使用插件自动引入 svg 图标 依赖安装pnpm i -D unplugin-icons vite-plugin-svg-icons @vitejs/plugin-vue 配置 vite.config.ts 文件import defineConfig from vite;import vue from @vitejs/plugin-vue;import path from path;import NaiveUiResolver from unplugin-vue-components/resolvers;import Components from unplugin-vue-components/vite;import resolve from path;import FileSystemIconLoader from unplugin-icons/loaders;import IconsResolver from unplugin-icons/resolver;import Icons from unplugin-icons/vite;import createSvgIconsPlugin from vite-plugin-svg-icons;// svg存放地址const customIconPath = resolve(process.cwd(), src/assets/svg);export default defineConfig( return plugins: [ vue(), Components( // auto import components 自动加载组件 resolvers: [ NaiveUiResolver(), IconsResolver( customCollections: [custom], componentPrefix: icon, ), ], dts: false, ), Icons( compiler: vue3, customCollections: custom: FileSystemIconLoader(customIconPath), , scale: 1, defaultClass: inline-block, ), createSvgIconsPlugin( iconDirs: [customIconPath], symbolId: icon-custom-[dir]-[name], inject: body-last, customDomId: __CUSTOM_SVG_ICON__, ), ], ;); 在这里我们为什么要使用 `process.cwd()`呢？ `__dirname和process.cwd()的区别`const resolve = require(path)const dirnamePath = resolve(__dirname, )console.log(dirnamePath)const pwdPath = resolve(process.cwd())console.log(pwdPath) 输出结果是： /Users/wangmou/workspace/whbbit-blog/wxw-blog/scripts/Users/wangmou/workspace/whbbit-blog/wxw-blog 我们可以看到，`__dirname` 是命令执行目录，`process.cwd()` 是执行命令的 js 所的在目录 使用假设 assetssvg 文件夹中包含 logo.svg 和 menu.svg 两个 svg 图标。我们可以直接使用 icon-custom-文件名 来使用 template icon-custom-logo / icon-custom-menu //template","tags":["vite使用"],"categories":["代码人生","前端技术"]},{"title":"stellar主题添加代码块复制功能","path":"/2023/01/31/stellar主题添加代码块复制功能/","content":"给 stellar 主题添加代码块复制功能 我们可以利用 hexo 的注入器来完成这个功能 项目根目录下新建一个 scripts 文件，添加codeCopy.js文件（文件名可以随意取）。添加如下代码 创建的 scripts 文件夹中的文件会被 hexo 自动加载 /scripts/codeCopy.jsuse strict// code block copyhexo.extend.injector.register(body_end, function () return ` style .highlight position: relative; .highlight .code .copy-btn position: absolute; top: 0; right: 0; padding: 4px 0.5rem; opacity: 0.25; font-weight: 700; color: var(--theme); cursor: pointer; transination: opacity 0.3s; .highlight .code .copy-btn:hover color: var(--text-code); opacity: 0.75; .highlight .code .copy-btn.success color: var(--swiper-theme-color); opacity: 0.75; /style script const codeElementArr = document.querySelectorAll(.code) codeElementArr.forEach(code = const codeBeforeWidth = window.getComputedStyle(code, ::before).width.split(px)[0] const codeBeforePadding = window.getComputedStyle(code, ::before).padding.split( ).pop().split(px)[0] // copy btn const codeCopyBtn = document.createElement(div) codeCopyBtn.classList.add(copy-btn) codeCopyBtn.style.right = Number(codeBeforeWidth) + Number(codeBeforePadding) * 2 + px codeCopyBtn.innerText = 复制代码 code.appendChild(codeCopyBtn) codeCopyBtn.addEventListener(click, async () = const currentCodeElement = code.children[0]?.innerText await copyCode(currentCodeElement) codeCopyBtn.innerText = 复制成功 codeCopyBtn.classList.add(success) setTimeout(() = codeCopyBtn.innerText = 复制代码 codeCopyBtn.classList.remove(success) ,1000) ) ) async function copyCode(currentCode) console.log(currentCode) console.log(复制代码) if (navigator.clipboard) try await navigator.clipboard.writeText(currentCode) catch (error) // 未获得用户许可 console.error(error) else console.error(当前浏览器不支持此api) /script `)","tags":["hexo"],"categories":["代码人生","静态站点"]},{"title":"使用Hexo Stellar 主题搭建一个独立博客站点","path":"/2023/01/31/使用Hexo-Stellar-主题搭建一个独立博客站点/","content":"如何使用 stellar 主题做一个自己的独立站点呢？ 介绍这里是使用stellar创建个人站点系列视频的文字部分，可以方便的粘贴一些配置项。 准备工作 安装 git 环境 https://git-scm.com/download/win 安装 nodejs 环境 https://nodejs.org/en/记得去官网下载，下载这个是免费的 安装 hexo-cli我们可以访问hexo 中文网按照提示安装 hexo-cli npm i -g hexo-cli 初始化项目hexo init stellar-blog cd stellar-blog 初次运行前，我们需要下载对应的依赖 npm i 依赖安装后，我们可以运行 npm run server 或者 hexo server 来启动 hexo 项目。运行成功后，我们可以看到一个网址，我们访问这个网址，如果出现了下面的这个页面，说明我们已经成功初始化了一个 hexo 博客。接下来我们就使用 hexo 提供的主题功能美化一下它吧。 主题配置进入stellar 主题官网，按照它的提示进行如下步骤： 安装主题 npm i hexo-theme-stellar 在 stellar-blog_config.yml 文件中找到并修改： theme: stellar 完成后，我们重新启动一下服务npm run server来看一下，发现网站已经变的和官网的页面差不多了，接下来来和我一起配置一下网站的其他内容吧。 配置网站基本信息在 stellar-blog_config.yml 文件夹中找到对应的选项修改为您站点的内容 title: 您的网站名称avatar: 您的头像链接favicon: 您的网站icon# 多语言language: - zh-CN _config.yml 只是进行一些基础的配置，关于 stellar 主题的配置，我们需要在根目录下创建 _config.stellar.yml _config.stellar.yml 文件配置我们可以去 node_modules/hexo-theme-stellar/_config.yml 找到啊 stellar 项目的原始配置文件，复制到我们创建的_config.stellar.yml文件中。然后在此基础上进行改动 一般我们需要改动的只有sidebar部分和footer部分。 sidebar 部分我们需要配置网站的侧边栏 sidebar: menu: post: [btn.blog](/) wiki: [专栏](/wiki/) notes: [导航](/notes/) more: [关于](/about/) 我们也可以在 sidebar 部分配置每个页面需要出现的小部件。自定义的小部件需要我们在 widgets.yml 文件中声明 sidebar: widgets: #### 自动生成的页面 #### # 主页 home: search, welcome, recent, ad, tagcloud, timeline # for home # 博客索引页 blog_index: search_blog, recent, ad, timeline # for categories/tags/archives # 文档索引页 wiki_index: search_docs, recent, ad, timeline # for wiki # 其它（404） others: search, welcome, recent, timeline # for 404 and ... #### 手动创建的页面 #### # 文章内页 post: toc, ghrepo, search, ghissues, ad # for pages using layout:post # 文档内页 wiki: search, ghrepo, toc, ad, ghissues, related # for pages using layout:wiki # 其它 layout:page 的页面 page: welcome, toc, ad # for custom pages using layout:page 当我们需要添加一个底部站点导航时，我们需要在footer部分添加sitemap footer: sitemap: 博客: - [近期](/) - [分类](/categories/) - [标签](/tags/) - [归档](/archives/) 专栏: - [vscode基础配置](/wiki/vscode/index.html) - [typescript基础](/wiki/typescript/index.html) 更多: - [友链](/) - [关于本站](/about/) - [文档站点](http://doc.whbbit.cn) - [GitHub](https://github.com/Whbbit1999) 自定义小部件在widgets.yml文件中，我们可以定义一些小组件。官方定义的我们直接粘贴就行。这里我说一下自定义小组件 ad: layout: markdown title: 可能是广告位吧🤨 content: | [![sable-admin-ad.jpg](/assets/sable-admin-ad.jpg)](https://github.com/Whbbit1999/sable) 创建独立页面在 widgets.yml 中创建对应的 widgets Notes: name: 笔记 title: 笔记 description: 一个隐藏项目：笔记 index: false # sidebar: [toc] tags: 知识库 sections: 日常问题解决方案: [100, 199] 移动端开发笔记: [200, 299] 前端学习笔记: [300, 399] 在线工具: [400, 499] 添加后，可以在_config.stellar.yml中添加对应的 sidebar sidebar: ... menu: ... notes: [笔记](/notes/) 创建对应的文件夹（文件夹名需要对应路径），这里需要创建对应的 notes 文件夹 如果你有 wiki 页面并且不想让它出现在 wiki 页面中时，可以在projects.yml中添加 Notes: index: false 接下来你就可以在对应的目录下书写对应的内容了。 添加友链需要注意将 actions 的权限更改为可以写入内容 使用 GitHub pages 托管静态网站进阶部分——使用 hexo 注入功能实现自定义功能代码块复制功能实现代码块复制功能 目前该主题已支持通过配置实现代码复制功能 注入谷歌统计和百度统计use strict// 百度统计和google 统计hexo.extend.injector.register(body_end, function () return `script var _hmt = _hmt || []; (function() var hm = document.createElement(script); hm.src = https://hm.baidu.com/hm.js?31181a38d70c8faf2c5bed0d93cab07b; var s = document.getElementsByTagName(script)[0]; s.parentNode.insertBefore(hm, s); )(); /script script async=async src=https://www.googletagmanager.com/gtag/js?id=G-FTR5YKFFCM/script script window.dataLayer = window.dataLayer || []; function gtag()dataLayer.push(arguments); gtag(js, new Date()); gtag(config, G-FTR5YKFFCM); /script `) 这些只是 stellar 主题的基础使用，更多进阶部分您可以访问 stellar 主题页面中的探索号进行查看 结语结合官方文档，您应该可以很轻松的使用 stellar 主题来搭建一个你自己的站点了。不妨先去试试！！！ 如果您遇到什么问题可以在本期视频下方或者文章下方评论，我们可以一起解决问题。","tags":["hexo"],"categories":["代码人生","静态站点"]},{"title":"GitHub status 获取GitHub项目信息","path":"/2023/01/22/GitHub-status-获取GitHub项目信息/","content":"美化一下 GitHub 主页。或者在其他项目中添加一些 GitHub 仓库的信息。 github-readme-stats你可以去这个仓库github-readme-stats，获取到你的 GitHub 账号中的信息，可以展示在你的 GitHub 主页或者其他项目当中。 下面是代码片段，你只需要把 username 改成您自己的 username 即可 ![Anurags GitHub stats](https://github-readme-stats.vercel.app/api?username=Whbbit1999theme=highcontrast) 下面是代码片段，你只需要把 username 改成您自己的 username 即可 ![Top Langs](https://github-readme-stats.vercel.app/api/top-langs/?username=Whbbit1999layout=compact)","categories":["代码人生","其他"]},{"title":"添加gpg签名","path":"/2023/01/16/添加gpg签名/","content":"最近在提交 vue-devui 组件库 pr 时，被要求添加 gpg 签名。之前对这部分没有任何了解，正好了解一下，顺便写一下关于配置 gpg 需要注意的东西和配置的完整步骤。 安装 gpgbrew install gpg 确认是否安装成功：输入gpg -h 后，没有报错并有 gpg 相关的帮助文档的话就安装成功了。 生成 gpg 密钥 输入生成 gpg 密钥对的命令 gpg --full-generate-key 提示要生成的加密类型，或者直接 enter 默认 提示要生成的密钥大小，直接 enter 默认 输入密钥的有效时常，直接 enter 默认（不会过期） 验证是否输入正确，确认之前输入的是否是自己想要的，如果是就确认 输入用户信息：按照提示输入真实姓名、邮箱（和 GitHub 绑定的邮箱） 提示输入密码：在查看生成的公钥会用到 命令行输入 gpg --list-secret-keys --keyid-format=long，展示所有生成的 gpg 密钥 获取要上传至 GitHub 的密钥 id： sec rsa3072xxx 中的 xxx 就是对应的密钥 id sec rsa3072/xxx 2023-01-16 [SC] xxxuid [ 绝对 ] xxx (github use) xxx@xx.comssb rsa3072/xxx 2023-01-16 [E] 输入 gpg --armor --export 3AA5C34371567BD2 查看生成的公钥 复制以 —–BEGIN PGP PUBLIC KEY BLOCK—– 开头并以 —–END PGP PUBLIC KEY BLOCK—– 结尾的 GPG 密钥。 注意： 一定要将打印出的所有内容都粘贴，包括 -----BEGIN PGP PUBLIC KEY BLOCK----- 和 -----END PGP PUBLIC KEY BLOCK-----。不然添加会失败 在 GitHub 中添加 https://docs.github.com/zh/authentication/managing-commit-signature-verification/adding-a-gpg-key-to-your-github-accounthttps://docs.github.com/zh/authentication/managing-commit-signature-verification/adding-a-gpg-key-to-your-github-account 添加 git 处理配置让 git 使用 gpg 进行签名 git config --global user.signingkey 密钥ID 设置 git 全局使用该密钥加密 commit git config --global commit.gpgsign true 设置 git 全局使用该密钥进行加密 tag git config --global tag.forcesignannotated true 报错处理报错gpg failed to sign the data使用 zsh 需要添加export GPG_TTY=$(tty) sudo vi ~/.zshrc 添加配置 export GPG_TTY=$(tty) 重新加载 zsh 配置文件 source ~/.zshrc 提交时一直报错如果您之前设置了 pinentry 和 gpg，但它突然停止工作：检查您的 gpg 是否有效： echo test | gpg --clearsign 如果它说gpg: signing failed: No pinentry，只需重新启动 gpg 守护程序客户端，它会不时卡住： gpgconf --kill gpg-agent 现在它应该可以工作了： 可以运行echo test | gpg --clearsign 先，会提示输入密码，输入密码后再次进行代码提交就 ok 了。 实在不行就使用 git config --global commit.gpgsign false git config --global tag.forcesignannotated false 直接关闭全局 gpg 加密","tags":["gpg签名"],"categories":["代码人生"]},{"title":"mac平台 go开发环境搭建","path":"/2023/01/11/mac平台-go开发环境搭建/","content":"使用 homebrew 安装 go 开发环境 使用 homebrew 安装 brew install go 查看是否安装成功 go version 更新 go 版本 brew update go","categories":["代码人生","后端技术"]},{"title":"Arc浏览器激活码领取","path":"/2023/01/11/Arc浏览器激活码领取/","content":"Arc 浏览器是真滴好用，如果你没有激活码，可以点击下方链接领取激活码。 hey, here’s an invite to Arc, the browser I was telling you about! https://arc.net/gift/1fba8766","categories":["代码人生","开源分享"]},{"title":"给vitepress添加algolia搜索","path":"/2023/01/11/给vitepress添加algolia搜索/","content":"这里推介一篇文章给 VitePress 添加 algolia 搜索。 效果可以去 http://doc.whbbit.cn 或原作者站点 https://chodocs.cn 查看","tags":["vitepress"],"categories":["代码人生","静态站点"]},{"title":"vue项目权限控制","path":"/2023/01/03/vue项目权限控制/","content":"实现 vue 动态路由的测试，登录 user 和 admin 可以访问不同的菜单 router/index.tsimport createWebHashHistory, createRouter, RouteRecordRaw from vue-router// 静态路由const routes: RouteRecordRaw[] = [ name: home, path: /, meta: label: 首页 , component: () = import(../pages/home.vue), , name: login, path: /login, meta: label: 登录 , component: () = import(../pages/login.vue), , name: disboard, path: /disboard, meta: label: 工作台 , component: () = import(../pages/disboard.vue), ,]// 动态路由const dynamicRoutes: RouteRecordRaw[] = [ name: list, path: /list, meta: label: 列表, roles: [admin, user] , component: () = import(../pages/list.vue), , name: about, path: /about, meta: label: 关于, roles: [admin, user] , component: () = import(../pages/about.vue), , name: user, path: /user, meta: label: 用户, roles: [admin, user] , component: () = import(../pages/user.vue), children: [ name: user-info, path: /user/info, meta: label: 用户info, roles: [admin, user] , component: () = import(../pages/user-info.vue), children: [ name: user-info.a, path: /user/info/a, meta: label: 用户info.a, roles: [admin, user] , component: () = import(../pages/user-info-a.vue), , name: user-info.b, path: /user/info/b, meta: label: 用户info.b, roles: [admin, user] , component: () = import(../pages/user-info-b.vue), , ], , name: user-orders, path: /user/orders, meta: label: 用户orders, roles: [user] , component: () = import(../pages/user-orders.vue), , ], ,]// routes 扁平化处理const loopRoutes = (routes: RouteRecordRaw[], role: string = ) = const result: RouteRecordRaw[] = [] const loopChildren = (children: RouteRecordRaw[] = [], parent: string = ) = children.forEach((item) = if (item.children) const children, ...rest = item if (!rest.meta?.roles || (rest.meta?.roles as string[]).includes(role)) result.push(rest) if (!router.hasRoute(item.name!)) if (parent) router.addRoute(parent, rest) else router.addRoute(rest) loopChildren(children, rest.name as string) else // meta信息中没有roles或者meta信息中roles包含当前登录用户的role if (!item.meta?.roles || (item.meta?.roles as string[]).includes(role)) result.push(item) if (!router.hasRoute(item.name!)) if (parent) // 有父级 router.addRoute(parent, item) else router.addRoute(item) ) loopChildren(dynamicRoutes) console.log(result) return [...routes, ...result].filter((item) = item.name !== login)const router = createRouter( history: createWebHashHistory(), routes,)export default routerexport routes, loopRoutes App.vuescript setup lang=ts import provide, ref, watch from vue import router, routes from ./router const showRoutes = ref(routes) provide(showRoutes, showRoutes) const logout = () = location.href = / watch(showRoutes, () = console.log(router.getRoutes()) // 查看当前路由列表 )/scripttemplate router-link v-for=route in showRoutes :key=route.name :to= name: route.name 【 route.meta?.label 】 /router-link button @click=logout退出登录/button hr / router-view/router-view/templatestyle scoped/style login.vuescript lang=ts setup import inject, Ref from vue import loopRoutes, routes from ../router const showRoutes = inject(showRoutes) as unknown as Ref const login = (userType: string) = showRoutes.value = loopRoutes(routes, userType) /scripttemplate login.vue button @click=login(user)用户登录/button button @click=login(admin)admin登录/button/templatestyle scoped lang=scss/style","categories":["代码人生","前端技术"]},{"title":"rest client插件使用","path":"/2023/01/03/rest-client插件使用/","content":"rest client 是 vscode 中类似 Postman 的 api 接口请求利器。 https://marketplace.visualstudio.com/items?itemName=humao.rest-clienthttps://marketplace.visualstudio.com/items?itemName=humao.rest-client 创建 http 文件 使用 .http 结尾的文件可以被 rest-client 插件识别 注意： 以 ### 分割接口 @uri 可以定义请求前缀，且不能加 示例里的接口服务器地址在国外，测试时可能会发生错误，发生错误时多试几次即可http://jsonplaceholder.typicode.com/http://jsonplaceholder.typicode.com/ api.http@uri=https://jsonplaceholder.typicode.com###GET uri/posts/1###GET uri/posts###POST uri/postsContent-Type: application/json;charset=UTF-8 title: foo, body: bar, userId: 1###PUT uri/posts/1Content-Type: application/json;charset=UTF-8 id: 1, title: foo, body: bar, userId: 1###PATCH uri/posts/1Content-Type: application/json;charset=UTF-8 title: foo,###DELETE uri/posts/1### form表单传值POST uri/fileContent-Type: application/x-www-form-urlencodedfileName=helloHonofileSize=1024","tags":["vscode","插件"],"categories":["代码人生","编码工具"]},{"title":"prisma实践——结合nestjs实现restful风格api","path":"/2023/01/03/prisma实践——结合nestjs实现restful风格api/","content":"本文我们使用 prisma + nestjs 实现一下 restful 风格的 api 初始化项目和依赖安装初始化 nest 项目 nest new restful-test 安装依赖 pnpm i pnpm i 编写 prisma 模型model User id Int @id @default(autoincrement()) name String? email String @unique nickName String @default() @map(nick_name) createdAt DateTime @default(now()) @map(created_at) updatedAt DateTime @updatedAt @map(updated_at) 接口编写使用 nest cli 自动生成 crud 模板 nest g resolve user 编写对应的 controller 测试接口调用","tags":["node","prisma","orm","nestjs"],"categories":["代码人生","后端技术"]},{"title":"prisma","path":"/2023/01/02/prisma/","content":"prisma 是 nodejs 中著名的 orm 框架，这篇文章我们一起来了解一下 prisma 怎么结合 node 进行数据操作 官方网址： https://www.prisma.io/https://www.prisma.io/ node 项目中引入 prisma 和初始化创建一个 node 项目 mkdir prisma cd prisma pnpm init -y 引入 prisma pnpm i prisma -D 初始化一个使用 sqlite 的 prisma npx prisma init --datasource-provider sqlite 这时，你可以看到该项目中有一个 prisma 文件夹和一个.env文件，prisma 文件夹里面包含了一个schema.prisma文件，.env文件里则是数据库的配置 如果你使用 vscode 作为开发工具的话可以下载https://marketplace.visualstudio.com/items?itemName=Prisma.prisma插件让.prisma文件有高亮和格式化功能。 此时schema.prisma文件里的内容包含如下: // This is your Prisma schema file,// learn more about it in the docs: https://pris.ly/d/prisma-schemagenerator client provider = prisma-client-jsdatasource db provider = sqlite url = env(DATABASE_URL) 知识点 provider = sqlite 标识当前使用的数据库是 sqlite provider = prisma-client-js 标识当前项目是 js 项目 url = env(DATABASE_URL) 标识当前项目数据库文件地址 prisma 中的模型创建 以一个用户表来进行演示 model User id Int @id @default(autoincrement()) name String? email String @unique nickName String @default() @map(nick_name) createdAt DateTime @default(now()) @map(created_at) updatedAt DateTime @updatedAt @map(updated_at) @@map(users) 上面这段代码表示：创建一个 User 模型，其中包含的字段有： 一个 id ，整型自动递增 一个可选的 name 一个唯一值的 email 知识点 prisma 中创建模型使用关键字model 标识一个字段为 id 使用 @id 设置非必填字段使用 ? 给该字段一个默认值使用 @default() 给字段名在数据库中重新命名使用 @map() 给一个模型在数据库中重新命名使用 @@map() prisma 文件中所有引号需要使用双引号 使用 prisma studio 查看创建好的数据库npx prisma studio 数据库迁移创建好表结构定义后，执行 npx prisma migrate dev 命令，会在 prisma/migrations 目录下生成迁移文件，同时在数据库中创建表。 npx prisma migrate dev 此条命令动作为：根据定义生成迁移文件-执行新的迁移文件修改表 - 生成 Prisma Client 重置数据库npx prisma migrate reset 此条命令动作为：删除数据库-创建同名数据库-执行所有迁移文件-运行 seed 数据填充","tags":["node","prisma","orm"],"categories":["代码人生","后端技术"]},{"title":"vim","path":"/2023/01/01/vim/","content":"vim 常用操作及含义 模式切换光标移动动作","tags":["vim"],"categories":["代码人生","编码工具"]},{"title":"mock数据","path":"/2022/12/31/mock数据/","content":"在开发中我们常会用到一些模拟数据来确定程序是否有问题，这次我们一起来看一下怎么使用模拟数据来进行测试 json-server安装npm i -g json-server 使用在本地创建一个db.json文件，填写需要模拟的数据 post: [ id: 1, title: 三体 , id: 2, title: 流浪地球 ] 启动json-server --watch db.json --port 3004 --watch 表示监听 db.json 数据的变化 --port 后可以根据实际情况来指定服务启动的端口 启动成功后，我们就可以使用 restful 风格的接口来进行增删改查的操作了 GET http://localhost:3004/postGET http://localhost:3004/post/1PUT http://localhost:3004/post/1POST http://localhost:3004/postDELETE http://localhost:3004/post/1 使用编程模式创建模拟数据除了我们手动填写数据，还可以使用编程的方式来批量生成 mock 数据来进行测试 mock.jsmodule.exports = () = const data = post: [] for (let i = 0; i 20; i++) data.post.push( id: i, content: `post content $i`, ) return data json-server mock.js 上面的方法虽然可以模拟数据，但是少一些数据的随机性。我们可以使用 mockjs 来模拟生成其他类型的 mock 数据 mockjs初始化 node 项目 npm init -y 安装依赖 npm i -D mockjs 编写 mock.js 文件用于 json-server 模拟数据 mock.jsconst mockjs = require(mockjs)const Random = mockjs.Randommodule.exports = () = const data = post: [] for (let i = 0; i 5; i++) data.post.push( id: i, content: Random.cword(3), ) return data 启动 json-server --watch --port 9999 mock.js 我们在浏览器使用http://localhost:9999/post就可以获取到刚才创建好的 mock 数据了 [ id: 0, content: 问形院 , id: 1, content: 同离去 , id: 2, content: 队农而 , id: 3, content: 分列流 , id: 4, content: 即飞月 ] 具体 mockjs 的使用方式，可以查看文章下方的 mockjs 示例","categories":["代码人生","前端技术"]},{"title":"log4js node日志管理","path":"/2022/12/19/log4js-node日志管理/","content":"log4js 是一款 nodejs 日志管理工具 源码地址GitHub 地址： https://github.com/log4js-node/log4js-node文档地址： https://log4js-node.github.io/log4js-node/appenders.html 安装npm i log4js pnpm i log4js yarn add log4js 简易使用说明日志等级 trace debug info warn error fatal 使用main.jsconst log4js = require(log4js)const logger = log4js.getLogger()logger.trace(trace)logger.debug(debug)logger.info(info)logger.warn(warn)logger.error(error)logger.fatal(fatal) 控制输出的日志级别一下控制日志输出级别大于 debug 的输出到控制台 main.jsconst log4js = require(log4js)const logger = log4js.getLogger()log4js.level = warnlogger.trace(trace)logger.debug(debug)logger.info(info)logger.warn(warn) // 会在控制台输出logger.error(error) // 输出logger.fatal(fatal) // 输出 控制日志输出至文件以下示例表示日志文件输出为 all.log 文件中，文件根据每日日期进行分割，输出 debug 以上级别日志 main.jsconst log4js = require(log4js)log4js.configure( appenders: console: type: console , file: type: file, filename: log.log , dayfile: type: dateFile, filename: all.log, pattern: .yyyyMMdd, , , categories: default: appenders: [console, dayfile], level: debug, // 显示什么级别及以上日志 , ,)const logger = log4js.getLogger()logger.trace(trace)logger.debug(debug)logger.info(info)logger.warn(warn)logger.error(error)logger.fatal(fatal) all.log[2022-12-19T14:41:40.330] [DEBUG] default - debug[2022-12-19T14:41:40.331] [INFO] default - info[2022-12-19T14:41:40.331] [WARN] default - warn[2022-12-19T14:41:40.331] [ERROR] default - error[2022-12-19T14:41:40.332] [FATAL] default - fatal","tags":["node","服务端"],"categories":["代码人生","后端技术"]},{"title":"申请https证书并部署至nginx服务器","path":"/2022/12/15/申请https证书并部署至nginx服务器/","content":"申请免费的 https 证书并部署至 nginx 服务 在部署了本站后，每天看着浏览器左侧的红色锁头都不是很爽，正好借着这次机会分享一下在阿里云申请 https 证书并部署至阿里云 ubuntu 服务器的过程。 申请在阿里云网站查找 ssl 证书，点击点击 选购ssl证书 找到免费证书 如果你没有就点击购买 购买成功后，点击创建证书，点击证书申请，在弹出的抽屉里填写你的网站信息 点击下一步，按照提示完成 DNS 解析。 验证成功后，注意查收阿里云短信邮箱发送的 ssl 证书申请成功提示。 成功后，点击下载对应服务的 ssl 证书文件。 将下载好的压缩包在本地解压待用。 使用 ssh 工具链接服务器，上传文件至服务器这一步需要传输文件，你可以和我一样使用 vscode 的 ssh 插件 以下是插件列表 ms-vscode-remote.remote-ssh ms-vscode-remote.remote-ssh-edit ms-vscode.remote-explorer Natizyskunk.sftp 安装好后，点击侧边栏出现的图标，添加服务器即可。 将解压好的文件夹里的文件 xxx.key xxx.pem 上传至服务器 /usr/share/nginx/cert 文件夹中，若无 cert 文件，手动创建该文件夹即可。 这里可能会遇到权限问题，需要重新输入密码，需要关注 vscode 弹出的输入框 配置 nginx进入对应 nginx 配置文件中 vim /etc/nginx/sites-available/default 找到对应站点配置项，我这里是将 www.whbbit.cn 和 whbbit.cn 域名跳转至 https 服务 server listen 80; server_name www.whbbit.cn whbbit.cn; return https://$server_name$request_uri; 配置 ssl 证书 server listen 443 ssl; server_name www; # 证书申请时的域名 # 这段是阿里云官网上粘贴的，注意ssl_certificate和ssl_certificate_key最好写你上传ssl证书文件的绝对路径 root html; index index.html; ssl_certificate /usr/share/nginx/cert/9001033_www.whbbit.cn.pem; ssl_certificate_key /usr/share/nginx/cert/9001033_www.whbbit.cn.key; ssl_session_timeout 5m; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_protocols TLSv1.1 TLSv1.2 TLSv1.3; #表示使用的TLS协议的类型，您需要自行评估是否配置TLSv1.1协议。 ssl_prefer_server_ciphers on; location / root /xxxx; # 你网站静态文件所在目录 index index.html index.htm; 配置完成后，运行 nginx -t 查看配置项是否有问题。没有报错后运行 nginx -s reload 重新启动 ngin 服务。这时，在浏览器输入 whbbit.cn 或 www.whbbit.cn 会自动跳转至 https://www,whbbit.cn。 而且浏览器地址栏中的红色锁头编程了灰色。 在配置过程中遇到的坑 阿里云官网教程在不懂 luinx 系统的我来说比较晦涩且有一些配置项和 ubuntu 服务器有区别，在对照学习时需要注意系统是否和官网的一致 第三方博客省去了部分的配置细节，具体也需要对照官方教程进行补全。 目前为止，按照我这样配置重复配置另一个域名也没有遇到问题。您可以自己去试一下，我所使用的服务器如下 系统 阿里云 ubuntu 20.04","tags":["Nginx","服务器"],"categories":["代码人生","Linux/运维"]},{"title":"nestjs入门","path":"/2022/12/12/nestjs入门/","content":"nestjs 开发手册 安装npm i -g @nestjs/cli 创建项目nest new project-name nestjs 开发依赖orm - prismapnpm add prisma-binding @prisma/client pnpm add -D prisma mock 数据pnpm add mockjs pnpm add -D @types/mockjs 配置文件pnpm add @nestjs/config 校验pnpm add class-validator class-transformer 密码加密bcrypt 依赖 python 环境 pnpm add bcrypt 或者下载 bcryptjs pnpm add bcryptjs pnpm add -D @types/bcryptjs bcrypt 使用使用 bcrypt 加密密码 import hashSync from bcryptjs// hasnSync(要散列的值，加密等级)// val ? hashSync(val) : val;// 对比密码是否一致 jwtpnpm add @nestjs/jwt SECRET = 22222 jwt.module.tsimport JwtModule from @nestjs/jwt@Global()@Module( imports: [JwtModule.registerAsync( useFactory() return secret: process.env.SECRET, )], providers: [], exports: [JwtModule]) passport 验证安装依赖pnpm add @nestjs/passport passport passport-local passport-jwt pnpm add -D @types/passport @types/passport-local @types/passport-jwt 使用 进行登录时的校验并颁发 token local.strategy.tsimport Strategy, IStrategyOptions from passport-localimport PassportStrategy from @nestjs/passportimport compareSync from bcryptjsexport class LocalStrategy extends PassportStrategy(Strategy, local) //local为策略的名称，默认为passport-local ,-后面的local。可以自定义名称，自定义名称后，使用AuthGuard需要指定对应的名称 constructor(@InjectModel(User) private userModel: ReturnModelTypetypeof User) super( usernameField: username, passwordField: password, as IStrategyOptions) // 策略执行 async validate(username: string, password: string) const user = await this.userModel.findOne( username ).select(password) // 用户不存在 if (!user) throw new BadRequestException(用户名不正确) // 密码不存在 if (!compareSync(password, user.password)) throw new BadRequestException(密码错误) return user jwt.strategy.tsimport Strategy, StrategyOptions, ExtractJwt from passport-jwtimport PassportStrategy from @nestjs/passportimport compareSync from bcryptjsexport class LocalStrategy extends PassportStrategy(Strategy, jwt) //jwt为策略的名称，默认为passport-jwt ,-后面的jwt。可以自定义名称，自定义名称后，使用AuthGuard需要指定对应的名称 constructor(@InjectModel(User) private userModel: ReturnModelTypetypeof User) super( jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(), secretOrKey: process.env.SECRET, as StrategyOptions) // 策略执行 async validate(id) return await this.userModel.findById(id) login.dto.tsexport class LoginDto username: string password: string auth.module.tsimport Module from @nestjs/commonimport AuthController from ./auth.controllerimport PassportModule from @nestjs/passportimport LocalStrategy from ./local.strategyimport JwtStrategy from ./jwt.strategy@Module( imports: [PassportModule], controllers: [AuthController], providers: [LocalStrategy, JwtStrategy],)export class AuthModule auth.controller.tsimport Post, UseGuards from @nestjs/commonimport AuthGuard from @nestjs/passportimport LoginDto from ./login.dto.tsimport JwtService from /jwt.moduleexport class AuthController constructor(private jwtService: JwtService) @Post(login) @UseGuards(AuthGuard(local)) async login(@Body() dto: LoginDto, @Req() req) return token: this.jwtService.sign(String(req.user._id)), @Post(user) @UseGuards(AuthGuard(jwt)) async user(@Req() req) return req.user token 颁发 日期处理 pnpm add dayjs swagger 集成 pnpm add pnpm add prisma-binding @prisma/client mockjs @nestjs/config class-validator class-transformer argon2 @nestjs/passport passport passport-local @nestjs/jwt passport-jwt lodash multer dayjs express redis @nestjs/throttler pnpm add -D prisma typescript @types/node @types/mockjs @nestjs/mapped-types @types/passport-local @types/passport-jwt @types/express @types/lodash @types/multer @types/node","tags":["node","服务端","nest"],"categories":["代码人生","后端技术"]},{"title":"视频网站封面图制作","path":"/2022/12/08/视频网站封面图/","content":"各主流平台视频封面图大小一览 封面大小 比例为 16:9 YouTube 知乎 微博 百度号 头条（西瓜视频） 注意建议分辨率为1920*1080,图片大小不超过2Mbps 比例为 16:10 bilibili 注意建议分辨率为1146*717,图片大小不超过2Mbps 比例为 9:16 抖音 注意建议分辨率为1920*1080,最终呈现图片中1080*1464之间 封面素材 https://www.irasutoya.com/ https://reincar.net/sozai/ https://booth.pm/zh-cn https://emojipedia.org/people/ 稿定设计","tags":["自媒体"],"categories":["自媒体"]},{"title":"js数组","path":"/2022/12/07/js数组/","content":"js 数组的基础知识 基本操作声明数组里可以存放任何类型的数据 // 使用构造函数创建let arr = new Arrary(0, 1, 2, 3)// 字面量方式创建let newArr = [0, 1, 2, 3] 获取元素根据下标获取，从 0 开始 let arr = [0, 1, 2, 3, 4]// 获取第三个元素cosnole.log(arr[2]) // 2let arr1 = [ [1, 2], [2, 3],]console.log(arr[0]) // [1,2] 获取数组长度根据 arr.length 获取数组长度 let arr = [0, 1, 2, 3, 4]console.log(arr.length) // 5arr[10] = 2console.log(arr.length) // 10，6-9会填充为emptyconsole.log(arr[7]) // undefined 注意 使用构造函数创建数组时， 如果只填写一个为 number 类型的值，就会将此数组填充为对应长度的数组 let arr = new Array(10)console.log(arr.length) // 10 在 es6 以后，使用 Array.of 可以解决此问题 let arr = Array.of(10)console.log(arr.length) // 1console.log(arr) // [10] 类型检测可以使用 Array.isArray 检测一个数据是否是数组 console.log(Array.isArray([])) // trueconsole.log(Array.isArray()) // falseconsole.log(Array.isArray()) // falseconsole.log(Array.isArray(1)) // falseconsole.log(Array.isArray(false)) // false 转换为字符串可以使用 数组.toString 将数组转换为字符串 console.log([].toString()) // console.log([1, 2, 3].toString()) // 1,2,3 使用后端需要传递一个 id 字符串时，可以使用此方法转换 可以使用数组 String(数组) 来转换 console.log(String([1, 2, 3, 4])) // 1,2,3,4 可以使用数组.join(拼接的字符)来自定义用什么符号拼接为字符串 console.log([1, 2, 3, 4].join(-)) // 1-2-3-4console.log([1, 2, 3, 4].join(,)) // 1,2,3,4 其他类型数据转换为数组字符串可以使用字符串.split()转换为数组 console.log(1,3,4,6.split(,)) // [1,3,4,6] 元素中有 length 属性时，可以使用 Array.from(元素) 转换 const string = whbbit.cnconsole.log(Array.from(string))//[w, h, b, b, i, t,., c, n] Object 也可以使用此特性转换： let obj = 0: whbbit.cn 1: wxwconsole.log(Array.from(obj)) // []obj.length = 2console.log(Array.from(obj)) // [whbbit.cn, wxw] Arrar.from()有第二个参数，是对第一个元素的操作 div1/divdiv2/divscript let divs = document.querySelectorAll(div) // 将div元素的color设置为红色 Array.from(divs, (item) = item.style.color = red return item )/script 扩展运算符数组拼接let className = [js, css, html]let numbers = [1, 2, 3]console.log([...numbers, className]) 函数传参参数数量不确定时可以使用展开语法将所有参数接收到一个数组中 function sum(...rest) return rest.reduce((s, v) = (s += v), 0)sum(1, 2, 3, 4) dom 节点操作div1/divdiv2/divscript let divs = document.querySelectorAll(div) // 直接进行遍历会报错 // divs.map(item = console.log(item)) // 报错 // 需要转换为数组进行遍历 ;[...divs].map((item) = console.log(item) )/script 解构赋值不使用解构赋值 let arr = [wxw, 23]let name = arr[0]let age = arr[1] 使用解构赋值 let [name, age] = [wxw, 23] 过滤某个值 let [, age] = [wxw, 23] 结合扩展运算符 let [name, ...rest] = [wxw, 23, whbbit.cn] 赋值默认值 function show([name, year, site = 10]) console.log(name, year, site) // wxw, 23, 10show([wxw, 23]) 数组方法数组元素添加let arr = [0, 1]// 数组后追加arr[arr.length] = [2]arr[arr.length] = [3]arr = [...arr, 4]arr.push(5) // 返回值是数组长度// 在数组前添加arr.unshift(-1) // 返回值是数组长度arr = [-2, ...arr] 数组删除元素使用 pop()弹出数组最后一个元素，会改变原数组 let arr = [0, 1]let val = arr.pop()console.log(val) // 1 使用 shift() 弹出数组第一个元素，会改变原数组 let arr = [0, 1]let val = arr.shift()console.log(val) // 0 数组填充console.log(new Array(3).fill(0)) // [0,0,0] 在指定位置填充 // 从下标为1填充至下标为3，不包含3console.log([1, 2, 3, 4].fill(wxw, 1, 3))// [1, wxw, wxw, 4] splice会改变原数组，返回值为受改变的元素 let arr = [0, 1, 2, 3, 4]// 第一个参数从下标为几开始 第二个参数截取几位，第三个/n个参数：替换的元素let change = arr.slice(1, 2)console.log(change) // [1,2] slice不会改变原数组，返回值为受改变的元素 let arr = [0, 1, 2, 3, 4]// 第一个参数从下标为几开始 第二个参数到下标为几结束let change = arr.slice(1, 2)console.log(change) // [2]// 从0截取到末尾change = arr.slice()console.log(change) // [0,1,2,3,4]// 从1截取到末尾change = arr.slice(1)console.log(change) // [1,2,3,4] 案例：移动数组元素方法function move(array, from, to) if (from 0 || to = array.length) console.log(参数错误) return const newArray = [...array] let item = newArray.splice(from, 1) newArray.splice(to, 0, ...item) return newArraylet array = [0, 1, 2, 3]console.log(move(array, 1, 3)) 清空数组赋值一个新数组，内存地址更改为新数组的地址。对原有内存地址数据没有改变 let array = [0, 1, 2, 3, 4]let w = arrayarray = []console.log(array) // []console.log(w) // [0, 1, 2, 3, 4] 长度设置为 0，对原有内存地址数据进行操作。其他引用该地址的数据也会清空 let array = [0, 1, 2, 3, 4]let w = arrayarray.length = 0console.log(array) // []console.log(w) // [] let array = [0, 1, 2, 3, 4]array.splice(0) let array = [0, 1, 2, 3, 4]while (array.pop()) 数组拆分合并拆分 let str = 1,2let arr = str.split(,) 合并 concat() 或 扩展运算符 let arr1 = [1, 2, 3]let arr2 = [4, 5, 6]arr1.concat(arr2) 复制指定元素至指定位置 copyWithin() 查找数据indexOf 和 lastIndexOfindexOf从数组左侧开始查找对应元素。元素存在就返回当前元素在数组中第一次出现的位置，不存在就返回-1 let arr = [1, 2, 3, 4]console.log(arr.indexOf(2)) // 1console.log(arr.indexOf(8)) // -1 lastIndexOf从数组右侧开始查找对应的元素。元素存在就返回当前元素最后一次出现的位置，不存在就返回 -1 let arr = [1, 2, 3, 4, 3]console.log(arr.lastIndexOf(3)) // 4console.log(arr.lastIndexOf(6)) // -1 注意indexOf 和 lastIndexOf会进行类型匹配 let arr = [1, 2, 3, 4, 5]console.log(arr.indexOf(5)) // -1console.log(arr.lastIndexOf(5)) // -1 注意indexOf 和 lastIndexOf可以传递第二个参数，表示从第几个元素开始查找 返回值还是该元素在数组中出现的第一次或最后一次 let arr = [1, 2, 3, 4, 2]console.log(arr.indexOf(2, 1)) // 1console.log(arr.indexOf(3, 1)) // 4 includes查找对应的元素是否在对应的数组中，返回 boolean 类型 let arr = [1, 2, 3, 4, 5]console.log(arr.includes(2)) // trueconsole.log(arr.includes(10)) // false includes 实现原理 function includes(array, val) for (const value of array) if (value === val) return true return false let array = [1, 2]console.log(includes(array, 2)) // true let lesson = [ name: html , name: js , name: css ]console.log(lesson.includes( name: html )) // false// 内存地址不一致导致没有找到对应的元素 find 和 findIndexfindfind 可以传递一个回调函数，回调函数返回值为 true 时就返回找到第一个值，回调函数返回为 false 时就返回 undefined let arr = [1, 2, 3]console.log(arr.find((item) = true)) // 1console.log(arr.find((item) = item === 2)) // 2console.log(arr.find((item) = item === 2)) // undefinedconsole.log(arr.find((item) = item === 200)) // undefined let lesson = [ name: html , name: js , name: css ]console.log(lesson.find((item) = item.name === html)) // name: html findIndexfindIndex 可以传递一个回调函数，回调函数返回值为 true 时就返回找到第一个值所在的位置，回调函数返回为 false 时就返回 -1 let lesson = [ name: html , name: js , name: css ]console.log(lesson.findIndex((item) = item.name === html)) // 1 自定义 findfunction find(array, callback) for (const value of array) if (callback(value)) return value return undefinedfind([1, 2, 3, 4], (item) = item === 2) // 2 在原型链上定制 findValue 方法 Array.prototype.findValue = function (callback) for (const value of this) if (callback(value)) return value return undefined;[1, 2, 3, 4].findValue((item) = item === 2) // 2 排序sort回调函数返回值小于 0 两者位置互换，大于 0 不变 let arr = [1, 3, 2, 4, 5]// 从小到大排序arr.sort((a, b) = a - b) // [1,2,3,4,5]// 从大到小排序arr.sort((a, b) = b - a) // [5,4,3,2,1]let cart = [ name: html, price: 20 , name: css, price: 25 , name: js, price: 30 ,]//按价格从小到大排cart = cart.sort((a, b) = a.price - b.price)// 按价格从大到小排cart = cart.sort((a, b) = b.price - a.price) sort 实现function sort(array, callback) for (const n in array) for (const m in array) if (callback(array[n], array[m]) 0) ;[array[n], array[m]] = [array[m], array[n]] return arrayarr = sort([2, 3, 1], (a, b) = a - b)arr = sort([2, 3, 1], (a, b) = b - a) 数组循环for 循环let lessons = [ name: html, price: 20 , name: css, price: 25 , name: js, price: 30 ,]for (let i = 0; i lessons.length; i++) console.log(lessons[i])// name: html, price: 20 // name: css, price: 25 // name: js, price: 30 for … of拿到的值是对应元素的值 let lessons = [ name: html, price: 20 , name: css, price: 25 , name: js, price: 30 ,]for (const lesson of lessons) lesson.click = trueconsole.log(lessons)/** [ name: html, price: 20, click: true, name: css, price: 25, click: true, name: js, price: 30, click: true, ] */ 为什么可以改变原数组呢？这里的 lesson 是重新赋值的一个元素，可以改变原数组是因为这是直接改变内存地址中的值 let arr = [1, 2, 3]for (const value of arr) value = 3console.log(arr) // [1,2,3] for … in拿到的值是对应元素的下标 let lessons = [ name: html, price: 20 , name: css, price: 25 , name: js, price: 30 ,]for (const index in lessons) console.log(lessons[index])// name: html, price: 20 // name: css, price: 25 // name: js, price: 30 forEachforEach 可以收两个参数，第一个参数是一个回调函数，第二个参数是 this 指向。回调函数可以接受三个参数，第一个是当先循环的元素，第二个是当前循环的下标，第三个元素是原数组 let lessons = [ name: html, price: 20 , name: css, price: 25 , name: js, price: 30 ,]lessons.forEach((item, index, lessons) = console.log(item, index, lessons)) interator 迭代器let lessons = [ name: html, price: 20 , name: css, price: 25 , name: js, price: 30 ,]console.log(lessons.keys().next()) some everysomeevery数组过滤filter返回符合条件的数据数组 let arr = [1, 2, 3]console.log(arr.filter((item) = item 2)) // [3] filter 实现let arr = [1, 2, 3]function filter(array, callback) let newArray = [] for (const value of array) if (callback(value) === true) newArray.push(value) return newArrayconst res = filter(arr, (item) = item 2)console.log(res) // [3] map返回一个操作后的数组 let arr = [1, 2, 3]let newArr = arr.map((item) = item + 2)console.log(newArr) // [3,4,5] reducereduce 接收两个参数，第一个参数为一个回调函数，第二个参数是初始值 回调函数第一个值是上一次回调函数的返回值，第一次调用时 reduce 没有传递第二个参数，就默认为数组的第一个参数，第二个参数有传值就为第二个参数传递的值 let arr = [1, 2, 3, 4, 5]arr.reduce((pre, value, index, array) = console.log(pre, value))/** 1,2 undefined, 3 undefined, 4 undefined, 5 */arr.reduce((pre, value, index, array) = console.log(pre, value), 2)/** 2,1 undefined, 2 undefined, 3 undefined, 4 undefined, 5 */arr.reduce((pre, value, index, array) = console.log(pre, value) return 22, 2)/** 2,1 22, 2 22, 3 22, 4 22, 5 */ 案例：统计元素出现次数function arrayCount(array, item) return array.reduce((total, cur) = total += item === cur ? 1 : 0 return total , 0)console.log(arrayCount([1, 2, 2, 2, 1, 1, 2], 2)) // 4console.log(arrayCount([1, 2, 2, 2, 1, 1, 2], 1)) // 3 案例：获取元素中的最大值function getMaxItem(array, item) return array.reduce((pre, cur) = (pre cur ? pre : cur))console.log(getMaxItem([1, 2, 3, 444, 555])) 案例：获取阅读次数最多的文章function max(array) return array.reduce((pre, cur) = return pre.count cur.count ? pre : cur )let article = [ title: js基础, count: 100 , title: css基础, count: 200 , title: ts基础, count: 10 , title: html基础, count: 500 ,]console.log(max(article)) 案例：所有文章阅读总数function count(array) return array.reduce((pre, cur) = (pre += cur.count), 0)let article = [ title: js基础, count: 100 , title: css基础, count: 200 , title: ts基础, count: 10 , title: html基础, count: 500 ,]console.log(count(article)) 案例：文章阅读总数大于 200 的文章名称function getTitleByCount(array, count) return array .reduce((arr, cur) = if (cur.count count) arr.push(cur) return arr , []) .map((item) = item.title)let article = [ title: js基础, count: 100 , title: css基础, count: 200 , title: ts基础, count: 10 , title: html基础, count: 500 ,]console.log(getTitleByCount(article, 200)) 案例： 数组去重使用 reduce let arr = [1, 2, 2, 2, 3, 34, 4, 1, 1, 1, 2, 3, 4, 5]let result = arr.reduce((arr, cur) = if (!arr.includes(cur)) arr.push(cur) return arr, [])console.log(result) 使用扩展运算符和 Set let arr = [1, 2, 2, 2, 3, 34, 4, 1, 1, 1, 2, 3, 4, 5]let result = [...new Set([...arr])]console.log(result)","tags":["js"],"categories":["代码人生","前端技术"]},{"title":"ts 枚举","path":"/2022/12/05/ts-枚举/","content":"ts 的枚举类型 枚举类型默认从 0 开始enum SexType BOY, GIRL,console.log(SexType.BOY) // 0console.log(SexType.GIRL) // 1 枚举编号会自动递增enum SexType BOY = 2, GIRL,console.log(SexType.BOY) // 2console.log(SexType.GIRL) // 3 枚举可以自定义enum SexType BOY = 男, GIRL = 女,console.log(SexType.BOY) // 男console.log(SexType.GIRL) // 女","tags":["ts"],"categories":["代码人生","前端技术"]},{"title":"使用GitHubActions部署","path":"/2022/12/05/使用GitHubActions部署/","content":"使用阿里云服务器搭建 hexo 博客 GitHub ActionsGitHub Actions 是 GitHub 的持续集成服务，我们可以使用它做网站的自动部署等工作。可以点击下面的链接查看示例。 https://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.htmlhttps://www.ruanyifeng.com/blog/2019/09/getting-started-with-github-actions.html 我们这里只做应用。 GitHub 变量添加可以到 GitHub 仓库的 settings - Secrets - Actions 中新增变量 具体步骤如下 codeblock:false 如何使用在配置文件 .github/workflows/main.yml 中可以使用 $secrets.变量名 的方式使用 .github/workflows/main.yml- name: copy dist file with scp uses: appleboy/scp-action@master with: host: $ secrets.WXW_HOST username: $ secrets.WXW_USERNAME password: $ secrets.WXW_PASSWORD port: 22 source: public/ target: $ secrets.WXW_TARGET 这里的WXW_HOST是服务器公网 ip，WXW_USERNAME 是服务器用户名， WXW_PASSWORD 是服务器用户密码， WXW_TARGET是要复制文件到那个文件中。我们会在下面的配置中使用这几个变量 最终代码.github/workflows/main.ymlname: deplay-hexo-blogon: push: branches: [master] workflow_dispatch:jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 # 安装nodejs - name: install nodejs uses: actions/setup-node@v3.4.1 with: node-version: 16.x # 安装依赖 - name: install packages run: npm install # 打包项目 - name: build run: npm run build # 文件复制到服务器 - name: copy dist file with scp uses: appleboy/scp-action@master with: host: $ secrets.WXW_HOST username: $ secrets.WXW_USERNAME password: $ secrets.WXW_PASSWORD port: 22 source: public/ target: $ secrets.WXW_TARGET 代码详解：这段代码表示在 master 分支提交时会触发该 actions on: push: branches: [master] workflow_dispatch: 这一段为使用 ubuntu-latest 虚拟机执行，安装 nodejs - 安装依赖 - 项目打包 - 将文件复制到服务器指定位置 name 为 copy dist file with scp 这一段会把生成好的 public 文件复制到服务器指定位置 $secrets.WXW_TARGET 下 jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v3 # 安装nodejs - name: install nodejs uses: actions/setup-node@v3.4.1 with: node-version: 16.x # 安装依赖 - name: install packages run: npm install # 打包项目 - name: build run: npm run build # 文件复制到服务器 - name: copy dist file with scp uses: appleboy/scp-action@master with: host: $ secrets.WXW_HOST username: $ secrets.WXW_USERNAME password: $ secrets.WXW_PASSWORD port: 22 source: public/ target: $ secrets.WXW_TARGET 服务器配置 nginx我这里使用www.whbbit.cn这个域名 server listen 80; server_name www.whbbit.cn; location / root /code/public; index index.html; try_files $uri $uri/ = 404; 配置好后，运行nginx -s reload重启一下 nginx 服务器，我们就可以使用www.whbbit.cn来访问我们部署好的网站了。","tags":["hexo","GitHubActions"],"categories":["代码人生","CI/CD"]},{"title":"nest 服务提供者","path":"/2022/12/04/nest-服务提供者/","content":"实现一些简单的 nest 服务提供者，以此了解服务提供者的作用方式。并且自定义一个 DbModule 接入 typegoose 类注册import Module from @nestjs/commonimport AppController from ./app.controllerimport AppService from ./app.serviceimport MyService from ./my/my.service@Module( imports: [], controllers: [AppController], providers: [AppService, MyService],)export class AppModule 使用： export class AppController() constructor(private readonly MyService) 完整写法，可更改提供者名称 import Module from @nestjs/commonimport AppController from ./app.controllerimport AppService from ./app.serviceimport MyService from ./my/my.service@Module( imports: [], controllers: [AppController], providers: [ AppService, provide: myService, useClass: MyService, , ],)export class AppModule 使用： export class AppController() constructor(@Inject(myService) private readonly myService) 基本数据注册import Module from @nestjs/commonimport AppController from ./app.controllerimport AppService from ./app.service@Module( imports: [], controllers: [AppController], providers: [ AppService, provide: config, useValue: name: wxw, author: wxw , , ],)export class AppModule 使用： export class AppController constructor(@Inject(config) private readonly config) 动态加载模块实现根据不同的环境创建不同的服务，首先需要获取 env 环境变量 pnpm add dotenv 创建 app.service.ts 和 my.service.ts 根据不同环境变量动态设置服务 import Module from @nestjs/commonimport AppController from ./app.controllerimport AppService from ./app.serviceimport MyService from ./my/my.serviceimport path from pathimport config from dotenvconfig( path: path.join(__dirname, ../.env) )const appService = provide: appService, useClass: process.env.NODE_ENV === development ? AppService : MyService,@Module( imports: [], controllers: [AppController], providers: [appService],)export class AppModule 自定义 DbModule 接入 typegoose GitHub 仓库地址 主要代码实现 // db.module.tsimport DynamicModule, Module, Provider from @nestjs/common;import DbService from ./db.service;import getModelForClass, mongoose from @typegoose/typegoose;import ConfigService from @nestjs/config;type ClassType = new (...args: any[]): any ;@Module()export class DbModule static forRoot(envKey: string, options = ): DynamicModule const providers: Provider[] = [ provide: DB_CONNECT, inject: [ConfigService], useFactory: (configService: ConfigService) = const uri = configService.getstring(envKey, MONGO_URI); return mongoose.connect(uri, options); , , ]; return module: DbModule, providers, exports: providers, global: true, ; static forFeature(models: ClassType[]): DynamicModule const providers = models.map((model) = return provide: model.name, useFactory: () = getModelForClass(model), as Provider; ); return module: DbModule, providers, exports: providers, global: true, ;","tags":["服务端","nest"],"categories":["代码人生","后端技术"]},{"title":"nest 拦截器","path":"/2022/12/04/nest-拦截器/","content":"实现几个常用的 nest 拦截器 全局响应拦截器import ArgumentsHost, Catch, ExceptionFilter, HttpStatus, ServiceUnavailableException from @nestjs/commonimport FastifyReply, FastifyRequest from fastify@Catch()export class AllExceptionsFilter implements ExceptionFilter catch(exception: Error, host: ArgumentsHost) const ctx = host.switchToHttp() const response = ctx.getResponseFastifyReply() const request = ctx.getRequestFastifyRequest() request.log.error(exception) // 非 HTTP 标准异常处理 response.status(HttpStatus.SERVICE_UNAVAILABLE).send( statusCode: HttpStatus.SERVICE_UNAVAILABLE, timestamp: new Date().toISOString(), path: request.url, message: new ServiceUnavailableException().getResponse(), ) 全局 HTTP 响应拦截器import ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus from @nestjs/commonimport FastifyReply, FastifyRequest from fastifyimport BusinessExceptions from ./business.exception.filter@Catch(HttpException)export class HttpExceptionsFilter implements ExceptionFilter catch(exception: HttpException, host: ArgumentsHost) const ctx = host.switchToHttp() const response = ctx.getResponseFastifyReply() const request = ctx.getRequestFastifyRequest() const status = exception.getStatus() if (exception instanceof BusinessExceptions) const error = exception.getResponse() response.status(HttpStatus.OK).send( data: null, status: error[code], extra: , message: error[message], success: false, ) return response.status(status).send( statusCode: status, timestamp: new Date().toISOString(), path: request.url, message: exception.getResponse(), ) 自定义拦截器import HttpException, HttpStatus from @nestjs/commonimport BUSINESS_ERROR_CODE from ./business.error.codestype BusinessError = code: number message: stringexport class BusinessExceptions extends HttpException constructor(err: BusinessError | string) if (typeof err === string) err = code: BUSINESS_ERROR_CODE.COMMON, message: err, super(err, HttpStatus.OK) static throwForbidden() throw new BusinessExceptions( code: BUSINESS_ERROR_CODE.ACCESS_FORBIDDEN, message: 抱歉哦，您无此权限！, )","tags":["node","服务端","nest"],"categories":["代码人生","后端技术"]},{"title":"常用代码片段","path":"/2022/12/04/常用代码片段/","content":"整合一些一些常用的 js 代码片段 数组去重cosnt newArr = [...new Set(arr)] 判断网页请求是 http 还是 httpsconst isHttp = document.location.protocol === http: ? true : false;","tags":["JavaScript"],"categories":["代码人生","JavaScript"]},{"title":"blob","path":"/2022/12/04/blob/","content":"流文件常见类型概览及前端 blob 文件下载简易封装 Blob 文件类型 拓展名 文件类型 MIME 类型 .aac AAC 音频 audioaac .abw AbiWord 文档 applicationx-abiword .arc 存档文档(多个文件嵌入) applicationx-freearc .avi AVI: 音频视频交错 videox-msvideo .azw 亚马逊 Kindle 电子书格式 applicationvnd.amazon.ebook .bin 任何类型的二进制数据 applicationoctet-stream .bmp Windows OS2 位图图形 imagebmp .bz BZip 存档 applicationx-bzip .bz2 BZip2 存档 applicationx-bzip2 .csh C-Shell 脚本 applicationx-csh .css CSS textcss .csv CSV textcsv .doc Microsoft Word applicationmsword .docx Microsoft Word (OpenXML) applicationvnd.openxmlformats-officedocument.wordprocessingml.document .eot MS 嵌入式 OpenType 字体 applicationvnd.ms-fontobject .epub 电子出版物(EPUB) applicationepub+zip .gif GIF imagegif .htm 超文本标记语言 (HTML) texthtml .html 超文本标记语言 (HTML) texthtml .ico Icon 格式 imagevnd.microsoft.icon .ics iCalendar 格式 textcalendar .jar Java Archive (JAR) applicationjava-archive .jpeg JPEG 图片 imagejpeg .jpg JPEG 图片 imagejpeg .js JavaScript textjavascript .json JSON 格式 applicationjson .jsonld JSON-LD 格式 applicationld+json .mid 乐器数字接口(MIDI) audiomidi audiox-midi .midi 乐器数字接口(MIDI) audiomidi audiox-midi .mjs JavaScript 模块 textjavascript .mp3 MP3 音频 audiompeg .mpeg MPEG 视频 videompeg .mpkg 苹果安装程序包 applicationvnd.apple.installer+xml .odp OpenDocument 演示文档 applicationvnd.oasis.opendocument.presentation .ods OpenDocument 电子表格文件 applicationvnd.oasis.opendocument.spreadsheet .odt OpenDocument 文本文档 applicationvnd.oasis.opendocument.text .oga OGG 音频 audioogg .ogv OGG 视频 videoogg .ogx OGG applicationogg .otf OpenType 字体 fontotf .png 便携式网络图形（PNG） imagepng .pdf PDF applicationpdf .ppt Microsoft PowerPoint applicationvnd.ms-powerpoint .pptx Microsoft PowerPoint (OpenXML) applicationvnd.openxmlformats-officedocument.presentationml.presentation .rar RAR 存档 applicationx-rar-compressed .rtf 富文本格式 (RTF) applicationrtf .sh Bourne shell 脚本 applicationx-sh .svg 可缩放矢量图形 (SVG) imagesvg+xml .swf 小型 web 格式 (SWF) or Adobe Flash document applicationx-shockwave-flash .tar Tape 归档(TAR) applicationx-tar .tif 标记图像文件格式 (TIFF) imagetiff .tiff Tagged Image File Format (TIFF) imagetiff .ttf TrueType 字体 fontttf .txt Text textplain .vsd Microsoft Visio applicationvnd.visio .wav 波形音频格式 audiowav .weba WEBM 音频 audiowebm .webm WEBM 视频 videowebm .webp WEBP 图片 imagewebp .woff 网页开放字体格式 (WOFF) fontwoff .woff2 网页开放字体格式 (WOFF) fontwoff2 .xhtml XHTML applicationxhtml+xml .xls Microsoft Excel applicationvnd.ms-excel .xlsx Microsoft Excel (OpenXML) applicationvnd.openxmlformats-officedocument.spreadsheetml.sheet .xml XML applicationxml（普通用户不可读）、textxml（普通用户可读） .xul XUL applicationvnd.mozilla.xul+xml .zip ZIP applicationzip .3gp 3GPP audiovideo 容器 video3gpp、audio3gpp（不含视频） .3g2 3GPP2 audiovideo 容器 video3gpp2、audio3gpp2（不含视频） .7z 7-zip applicationx-7z-compressed 简易 blob 下载文件封装传入二进制流下载文件 /** * blobData 流文件 * blobType 导出类型 * fileName 导出文件名称 * ..attr 其他信息 */export function dowloadBlobFile(blobData, blobType, fileName, ...attr) const blob = new Blob([blobData], type: blobType || application/vnd.ms-excel, ) const objectUrl = URL.createObjectURL(blob) const link = document.createElement(a) link.style.display = none link.href = objectUrl document.body.appendChild(link) link.click() document.body.removeChild(link) 传入链接下载文件 export function dowloadFile(url) const link = document.createElement(a) link.style.display = none link.href = url document.body.appendChild(link) link.click() document.body.removeChild(link) link.remove() Blob 和 Base64 互相转换// base64 to blob二进制function dataURItoBlob(dataURI) const mimeString = dataURI.split(,)[0].split(:)[1].split(;)[0] // mime类型 const byteString = atob(dataURI.split(,)[1]) //base64 解码 const arrayBuffer = new ArrayBuffer(byteString.length) //创建缓冲数组 const intArray = new Uint8Array(arrayBuffer) //创建视图 for (let i = 0; i byteString.length; i++) intArray[i] = byteString.charCodeAt(i) return new Blob([intArray], type: mimeString )// blob二进制 to base64function blobToDataURI(blob, callback) const reader = new FileReader() reader.onload = function (e) callback(e.target.result) reader.readAsDataURL(blob)","tags":["js","blob"],"categories":["代码人生","前端技术"]},{"title":"gin初始化项目","path":"/2022/12/04/gin初始化项目/","content":"初始化一个 gin 的项目，领略一下 go 语言的风采 初始化项目 初始化 go 项目 go mod init program-name 配置国内镜像 go env -w GOPROXY=https://goproxy.io,direct 引入 gin 框架 go get -u github.com/gin-gonic/gin 编写一个网络请求 package mainimport github.com/gin-gonic/ginfunc main() r := gin.Default()\tr.GET(/ping, func(c *gin.Context) c.JSON(200, gin.H message: ping, )\t)\tr.Run(:9999) // 在9999端口启动服务，不填默认在8080端口启动 启动项目 go run main.go 网站目录初始化 定义一个初始化的项目目录，方便后期开发 --| api/ # 放置api接口，相当于controller\t--| v1/--| config/ # 放置网站配置文件\t--| config.ini--| middleware/ # 中间件--| model/ # 数据模型--| routes/ # 网站路由--| upload/ # 上传静态文件托管--| utils/ # 公共函数--| web/ # 前端静态文件托管--| main.go # 项目入口 使用 ini 做网站配置go get -u gopkg.in/ini.v1 config/config.ini# 网站服务配置[server]AppMode = debug # debug or serverHttpPort = :9999JWTToken = ajlsdflasjdjlasjdlf# 数据库配置[database]DB = mysqlDBHost = localhostDBPort = 3306DBUser = rootDBPwd = admin888DBName = ginblog utils/setting.gopackage utilsimport (\tfmt\tgopkg.in/ini.v1)var (\tAppMode string\tHttpPort string\tJWTToken string\tDB string\tDBHost string\tDBPort string\tDBUser string\tDBPwd string\tDBName string)func init() file, err := ini.Load(config/config.ini)\tif err != nil fmt.Println(配置文件错误，请确认配置文件是否正确) LoadServer(file)\tLoadDataBase(file)// 加载网站配置func LoadServer(file *ini.File) AppMode = file.Section(server).Key(AppMode).MustString(debug)\tHttpPort = file.Section(server).Key(HttpPort).MustString(:9999)\tJWTToken = file.Section(server).Key(JWTToken).MustString(ajlsdflasjdjlasjdlf)// 加载数据库配置func LoadDataBase(file *ini.File) DB = file.Section(database).Key(DB).MustString(mysql)\tDBHost = file.Section(database).Key(DBHost).MustString(localhost)\tDBPort = file.Section(database).Key(DBPort).MustString(3306)\tDBUser = file.Section(database).Key(DBUser).MustString(root)\tDBPwd = file.Section(database).Key(DBPwd ).MustString(admin888)\tDBName = file.Section(database).Key(DBName).MustString(ginblog) router 分组main.gopackage mainimport (\tgithub.com/gin-gonic/gin\tv1 whbbit.cn/gin/router/v1)func main() r := gin.Default()\tv1.InitRouter(r)\tr.Run(:9999) router/v1package v1import github.com/gin-gonic/ginfunc InitRouter(g *gin.Engine) v1 := g.Group(v1)\tv1.GET(/hello, func(c *gin.Context) c.JSON(200, gin.H message: hello v1, )\t)\tv2 := g.Group(v2)\tv2.GET(/hello, func(c *gin.Context) c.JSON(200, gin.H message: hello v2, )\t) 使用 gorm 操作 mysql 数据库go get -u gorm.io/gorm go get -u gorm.io/driver/mysql 配置 gorm 连接数据库model/db.gopackage modelimport (\tfmt\tserver/utils\ttime\tgorm.io/driver/mysql\tgorm.io/gorm)var db *gorm.DBvar err errorfunc InitDB() db, err = gorm.Open(mysql.Open(fmt.Sprintf(%s:%s@tcp(%s:%s)/%s?charset=utf8mb4parseTime=Trueloc=Local, utils.DBUser, utils.DBPwd, utils.DBHost, utils.DBPort, utils.DBName,\t)))\tif err != nil fmt.Println(数据库连接失败，请检查参数, err) // 迁移文件\tdb.AutoMigrate(User, Article, Category)\t// 获取通用数据库对象 sql.DB ，然后使用其提供的功能\tdb, err := db.DB()\tif err != nil fmt.Println(数据库连接失败，请检查参数, err) // SetMaxIdleConns 用于设置连接池中空闲连接的最大数量。\tdb.SetMaxIdleConns(10)\t// SetMaxOpenConns 设置打开数据库连接的最大数量。\tdb.SetMaxOpenConns(100)\t// SetConnMaxLifetime 设置了连接可复用的最大时间。\tdb.SetConnMaxLifetime(10 * time.Second) // 最大连接时间10s，超出10s就超时\t// 关闭数据库连接\tdb.Close() 创建数据模型model/User.gopackage modelimport gorm.io/gormtype User struct gorm.Model\tUsername string `gorm:type:varchar(20);not null json:username`\tPassword string `gorm:type:varchar(20);not null json:password`\tRole int `gorm:type:int json:role` model/Category.gopackage modelimport gorm.io/gormtype Category struct gorm.Model\tName string `gorm:varchar(20);not null json:name` model/Article.gopackage modelimport gorm.io/gormtype Article struct gorm.Model\tTitle string `gorm:varchar(100);not null json:title`\tBody string `gorm:longtext;not null json:body`\tDesc string `gorm:varchar(200); json:desc`\tCover string `gorm:varchar(100); json:cover`\tCategory Category `gorm:foreignKey:Cid`\tCid int `gorm:int;not null json:cid`","tags":["gin","go","服务端"],"categories":["代码人生","后端技术"]},{"title":"golang基础语法","path":"/2022/12/04/golang基础语法/","content":"golang 基础语法概览 打印内容package mainimport fmtfunc main () fmt.Println(hello) 注释// 单行注释/* 多行注释 */ 变量声明// 单独声明var age intvar name string// 类型一致时可以只写一次var a, b int// 会自动推断类型var username = whbbit","tags":["go"],"categories":["代码人生","后端技术"]},{"title":"git统计代码提交数量","path":"/2022/12/04/git统计代码提交数量/","content":"查看项目中的每个人代码提交量，看看谁在摸鱼吧 统计 git 提交次数: 所有人的所有提交次数，会展示所有的提交人 提交次数详情 git log | grep ^Author: | awk print $2 | sort | uniq -c | sort -k1,1nr 查看 git 上的个人代码量 git log --author=username --pretty=tformat: --numstat | awk add += $1; subs += $2; loc += $1 - $2 END printf added lines: %s, removed lines: %s, total lines: %s , add, subs, loc - username 需要修改为提交人的 username 统计每个人增删行数 git log --format=%aN | sort -u | while read name; do echo -en $name\\t; git log --author=$name --pretty=tformat: --numstat | awk add += $1; subs += $2; loc += $1 - $2 END printf added lines: %s, removed lines: %s, total lines: %s , add, subs, loc -; done 202104 - 202211 代码总量一览 项目 用户名 添加 删除行 总数 门户 王晓伟 1 1 0 门户 whbbit 115145 17563 97582 官网 whbbit 23569 8000 15569 官网 wxw 5369 2315 3054 开票程序 whbbit 1612697 871939 740758 票夹小程序 whbbit 96152 10207 85945 开票云平台 whbbit 231420 139413 92007 开票云平台 王晓伟 54 45 9 开票云平台 wxw 87952 61171 26781 运营管理（数据可视化） whbbit 191928 32904 159024 总计 whbbitwxw王晓伟 2364287 1143558 1220729","tags":["git"],"categories":["代码人生","Linux/运维"]},{"title":"sass实现一个简易的原子样式库","path":"/2022/12/04/sass实现一个简易的原子样式库/","content":"用 sass 实现一个简易的原子样式库。通过此了解 sass 基础语法的实际使用。 _variables.scss$colors: ( white: #ffffff, primary: #367ee8, primary-light: #e9f0ff, bg: #f3f6fd, gray: #ccc, gray-sm-dark: #777, gray-dark: #555, black: #222, success: #22c55e, success-light: rgba(145, 191, 111, 0.25), error: #dc2626, error-light: #dc2626, warning: rgb(211, 151, 33), warning-light: #fff0e3, gray-bg: rgb(241, 241, 241),);$spacing-base-size: 1rem;$flex-jc: ( start: flex-start, end: flex-end, center: center, between: space-between, around: space-around,);$flex-ai: ( start: flex-start, end: flex-end, center: center, stretch: stretch,);// spacing$spacing-types: ( m: margin, p: padding,);$spacing-directions: ( t: top, b: bottom, l: left, r: right,);$spacing-sizes: ( 0: 0, 1: 0.25, 2: 0.5, 3: 1, 4: 1.5, 5: 3,);// border-radius$radiu-sizes: ( 0: 0, 1: 0.25, 2: 0.5, 3: 1, 4: 1.5, 5: 3,);$button-radius: 0.3rem;$font-sizes: ( base: 1rem, sm: 0.9rem, xs: 0.8rem, lg: 1.2rem,); main.scss@import ./_variables.scss;@each $colorKey, $color in $colors // 文字颜色 .text-#$colorKey color: $color; // 背景色 .bg-#$colorKey background-color: $color; .bloder font-weight: bolder;// 文字对齐方式@each $var in (left, center, right) .text-#$var text-align: $var !important; // text-overflow.text-ellipsis display: inline-block; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;// width, height.w-screen width: 100vw;.h-screen height: 100vh;.w-full width: 100%;.h-full height: 100%;// flex.flex display: flex;.flex-col flex-direction: column;.flex-wrap flex-wrap: wrap;.flex-1 flex: 1;.flex-grow-1 flex-grow: 1;@each $key, $value in $flex-jc .jc-#$key justify-content: $value; @each $key, $value in $flex-ai .ai-#$key align-items: $value; // m-0, mx-0@each $typeKey, $type in $spacing-types // .m-1 @each $sizeKey, $size in $spacing-sizes .#$typeKey-#$sizeKey #$type: $size * $spacing-base-size; // .mx-1 , .my-1 @each $sizeKey, $size in $spacing-sizes .#$typeKeyx-#$sizeKey #$type-left: $size * $spacing-base-size; #$type-right: $size * $spacing-base-size; .#$typeKeyy-#$sizeKey #$type-top: $size * $spacing-base-size; #$type-bottom: $size * $spacing-base-size; // .mt-1 @each $directionKey, $direction in $spacing-directions @each $sizeKey, $size in $spacing-sizes .#$typeKey#$directionKey-#$sizeKey #$type-#$direction: $size * $spacing-base-size; // border-radius@each $sizeKey, $size in $radiu-sizes .round-#$sizeKey border-radius: $size * $spacing-base-size; // overflow.hidden overflow: hidden;// border$border-color: map-get($colors, gray);.border-0 border: 0px !important;@each $dir in (top, right, left, bottom) .border-#$dir border-#$dir: 1px solid $border-color; // shadow.shadow-md box-shadow: 0px 2rpx 2rpx 10rpx rgba(0, 0, 0, 0.02);@each $key, $value in $font-sizes .font-#$key font-size: $value; .border-b border-bottom: 1px solid map-get($map: $colors, $key: gray);","categories":["代码人生","前端技术"]},{"title":"sass","path":"/2022/12/04/sass/","content":"sass 常用语法一览 在我们日常开发中，使用 lesssass 提供的层级样式方便于代码的编写，甚至我们可以使用 sass 中的一些函数来完成一个简单的 css 库来供我们复用 css 代码，这里我会仿照 tailwindcss 来写一些公共代码。我相信，有了这个基础，我们可以对 sass 有更加深入的了解。 官方网址sass 官方 sass 中文 安装使用 yarn 安装 yarn add sass -D 使用 npm 安装 npm i sass -D 使用 pnpm 安装 pnpm i sass -D 变量sass 的变量都是使用 $ 开始，以 ; 结束 // 申明单个值$primary: #22c55e;// 申明一组值$colors: ( white: #ffffff, primary: #367ee8, primary-light: #e9f0ff,); 或者我们可以在一个变量中用另一个变量 下面两种的写法是等效的 $border-color: map-get($colors, primary);// or$border-color: map-get( $map: $colors, $key: primary,); 注释scss 支持单行注释，使用单行注释后，在编译好的文件中不会包含备注内容。想要在编译后的 css 中显示注释的话需要使用 css 原本支持的注释方法/**/ 循环使用一组已有的数据@each $colorKey, $color in $colors .text-#$colorKey color: $color; 生成的 css 代码 .text-white color: #ffffff;.text-primary color: #367ee8;.text-primary-light color: #e9f0ff; 使用一组未定义的数据@each $var in (left, center, right) .text-#$var text-align: $var; 生成的代码 .text-left text-align: left;.text-center text-align: center;.text-right text-align: right;","tags":["css","sass"],"categories":["代码人生","前端技术"]},{"title":"vite开发时问题及解决方案","path":"/2022/12/04/vite开发时问题及解决方案/","content":"使用 vite 开发时可能会遇到的问题及解决方案 vue+ts 工程：找不到模块“@apiuser”或其相应的类型声明在 tsconfig.node.json tsconfig.json 文件中添加 3-6 compilerOptions: baseUrl: ./, paths: @/*: [src/*] vue3 项目报错：无法使用 JSX，除非提供了 “–jsx” 标志在 tsconfig.node.json tsconfig.json 文件中添加 3 compilerOptions: jsx: preserve","categories":["代码人生","前端技术"]},{"title":"chrome操作","path":"/2022/12/04/chrome操作/","content":"使用 chrome 调试代码时的一些骚操作 跟踪新开标签页的网络请求浏览器控制台 seeting - preferences - Global - Auto-open DevTools for popups","tags":["chrome","浏览器","代码调试"],"categories":["代码人生","前端技术"]},{"title":"axios","path":"/2022/12/04/axios/","content":"axios 入门级简易封装 官网地址https://axios-http.com/ 安装npm # pnpmpnpm i axios yarn # yarnyarn add axios pnpm # pnpmpnpm i axios 请求拦截器响应拦截器axios 封装 使用示例","tags":["node","js"],"categories":["代码人生","前端技术"]},{"title":"math.js 的使用","path":"/2022/12/04/mathjs/","content":"常用的 js 计算 精度解决方案 安装npm i mathjs 使用import create, all from mathjs;const config = number: BigNumber, precision: 20,;const math = create(all, config);function calc(expression) if (expression) return math.number(math.evaluate(expression)); else return 0; // 可以使用表达式进行计算console.log(calc(`0.1 + 0.2`)); // 0.3 这里推介使用表达式的方式进行计算，灵活且精确 其他计算库 currency.js","tags":["node","js","工具"],"categories":["代码人生","前端技术"]},{"title":"n切换node版本","path":"/2022/12/04/n切换node版本/","content":"linux 和 mac 下如何切换不同的 node 版本呢？ 安装npm i -g n 为什么使用 n 切换版本无效 n 的安装路径和 node 默认路径不一致 查看 node 安装路径 which node 编辑.bash_profile文件 vim ~/.bash_profile 在该文件中添加 export N_PREFIX=/usr/local/bin/node #根据你的安装路径而定export PATH=$N_PREFIX/bin:$PATH 保存并刷新文件 source ~/.bash_profile 重新安装 n n stable 这次就可以切换版本了，但是需要授予 sudo 权限 sudo n 参考文章n 模块切换 node 版本无效的解决办法","tags":["node"],"categories":["代码人生","前端技术"]},{"title":"nrm切换npm版本","path":"/2022/12/04/nrm/","content":"如何快速切换 npm 镜像呢？可以试试这个 nrm 可以快速的帮我们在不同的镜像中切换。 安装npm npm i -g nrm yarn yarn global add nrm 命令查看镜像列表nrm ls 结果如下： npm ---------- https://registry.npmjs.org/ yarn --------- https://registry.yarnpkg.com/ tencent ------ https://mirrors.cloud.tencent.com/npm/ cnpm --------- https://r.cnpmjs.org/* taobao ------- https://registry.npmmirror.com/ npmMirror ---- https://skimdb.npmjs.com/registry/ 选择镜像 使用淘宝镜像 nrm use taobao 查看当前源nrm current 结果如下： SUCCESS The registry has been changed to taobao. 测试速度nrm test 结果如下： npm ---------- 1013 ms yarn --------- 1437 ms tencent ------ 101 ms cnpm --------- 1364 ms* taobao ------- 215 ms npmMirror ---- 1865 ms 常见问题mac m1 芯片可能会修改失败，可以执行以下命令解决 npm uninstall -g nrmnpm i -g @adams549659584/nrm","tags":["nrm"],"categories":["代码人生","前端技术"]},{"title":"oss搭建个人图床","path":"/2022/12/04/oss搭建个人图床/","content":"oss 的简单应用 在写 markdown 文档的时候，经常会想要插入一些图片来让文章变的尽可能的图文并茂，但是如果是托管到 GitHub 上的话，图片又不是太好处理，所以就有了今天的这篇文章。 搭建自己的图床的好处再网上你可以搜索到许许多多的图床供你来使用，但是这些经常会因为各种各样的原因被封。如果你使用网上的图床，有可能会使你的博客的文章在一夜之间所有的图片显示不出来。这时你就会感到自己搭建图床的好处了。有的人可能会想，免费的图床它不香吗，被封了我再将图片传到另一个不就行了吗？但是你想过没有，有时你急需要图床的时候，又不是很好找到，还有自己的图片在本地不小心被删掉的状况。搭建一个自己的图床来保存图片，可以随时随地的使用自己的链接，不是很好吗？ 搭建的方法（这里用阿里云 OSS）一、开通阿里云 OSS 服务首先在阿里云上购买 OSS 服务，地址 https://www.aliyun.com/product/oss点击折扣套餐跳转后，选择最低配置，选择支付 在管理控制台新建 BucketBucket 名称按要求填好即可，下面的读写权限选择成为公共读创建成功后，就先可告一段落 图片的上传这里推荐使用PicGo，它是 GitHub 上的开源项目，可以快速的将本地图片上传到图床，可以去https://github.com/Molunerfinn/PicGo 下载 PicGo（文档都是中文，安装过程应该不用赘述）下载安装好后，是这个样子的 ↓ PicGo 配置图床点击图床设置，找到并点击阿里云 OSS 这里的 accesskey 和 accesskeySecret 可以从阿里云控制台获取（鼠标移至阿里云你的头像上，可以发现 Accesskey 管理） 存储空间和你刚才创建 Bucket 时使用同一个，可以从阿里云 OSS 控制台上复制，以免手贱打错字 存储区域在阿里云 OSS 控制台去找，如下图所示 可以先填写有星号的，其他默认即可 使用配置完成后，就可以再截图后，点击剪贴板图片上传直接将刚截到的图片上传至图床；或者可以将本地的图片拖到虚线框内即可。如果你和我一样是在 markdown 中使用，就选择西方的 markdown 即可。 至此，图床就可以使用了。在 PicGo 中，点击相册，看到图片下面有 3 个按钮，点击第一个就是复制链接。复制后，将其直接粘贴到你的 markdown 文章中即可使用。本文中所使用的所有图片都是来源于此 注意事项将自己阿里云上的 accesskey 保存好，不要轻易的告诉别人。信息安全问题，有可能就是一个疏忽造成的。","tags":["阿里云","oss"],"categories":["代码人生","其他","Linux/运维"]},{"title":"vue3响应式系统","path":"/2022/12/04/vue3响应式系统/","content":"跟着尤大实现一下 vue3 的响应式系统 Vue.js官网地址(中文) 响应式let activeEffectclass Dep subscribers = new Set() define() if (activeEffect) this.subscribers.add(activeEffect) notify() this.subscribers.forEach((effect) = effect() ) function watchEffect(effect) activeEffect = effect effect() activeEffect = nulllet targetMap = new WeakMap()function getDep(target, key) let depsMap = targetMap.get(target) if (!depsMap) depsMap = new Map() targetMap.set(target, depsMap) let dep = depsMap.get(key) if (!dep) dep = new Dep() depsMap.set(key, dep) return depconst reactiveHandlers = get(target, key, receiver) const dep = getDep(target, key) dep.define() return Reflect.get(target, key, receiver) , set(target, key, value, receiver) const dep = getDep(target, key) const result = Reflect.set(target, key, value, receiver) dep.notify() return result ,function reactive(raw) return new Proxy(raw, reactiveHandlers)// 使用const state = reactive( count: 0,)watchEffect(() = console.log(state.count))state.count++ 虚拟 dom 渲染style .red color: red; .green color: green; /stylediv id=app/divscript function h(tag, props, children) return tag, props, children function mount(vnode, container) const el = (vnode.el = document.createElement(vnode.tag)) // props if (vnode.props) for (const key in vnode.props) const value = vnode.props[key] el.setAttribute(key, value) // children if (vnode.children) if (typeof vnode.children === string) el.textContent = vnode.children else vnode.children.forEach((child) = mount(child, el) ) container.appendChild(el) const vdom = h(div, id: hello, class: red , [h(span, null, hello)]) mount(vdom, document.getElementById(app)) function patch(n1, n2) if (n1.tag === n2.tag) const el = (n2.el = n1.el) // props const oldProps = n1.props || const newProps = n2.props || for (const key in newProps) const oldVal = oldProps[key] const newVal = newProps[key] if (newVal !== oldVal) el.setAttribute(key, newVal) for (const key in oldProps) if (!(key in newProps)) el.removeAttribute(key) // children const oldChildren = n1.children const newChildren = n2.children if (typeof newChildren === string) if (typeof oldChildren === string) if (newChildren !== oldChildren) el.textContent = newChildren else el.textContent = newChildren else if (typeof oldChildren === string) el.innerHTML = newChildren.forEach((child) = mount(child, el) ) else const commonLength = Math.min(oldChildren.length, newChildren.length) for (let i = 0; i commonLength; i++) patch(oldChildren[i], newChildren[i]) if (newChildren.length oldChildren.length) newChildren.slice(oldChildren.length).forEach((child) = mount(child, el) ) if (newChildren.length oldChildren.length) oldChildren.slice(newChildren.length).forEach((child) = el.removeChild(child.el) ) else // replace const vdom2 = h(div, id: hello, class: green , [h(span, null, change!)]) patch(vdom, vdom2)/script 两者结合组成 mini-Vuediv id=app/divscript function h(tag, props, children) return tag, props, children function mount(vnode, container) const el = (vnode.el = document.createElement(vnode.tag)) // props if (vnode.props) for (const key in vnode.props) const value = vnode.props[key] if (key.startsWith(on)) el.addEventListener(key.slice(2).toLowerCase(), value) else el.setAttribute(key, value) // children if (vnode.children) if (typeof vnode.children === string) el.textContent = vnode.children else vnode.children.forEach((child) = mount(child, el) ) container.appendChild(el) function patch(n1, n2) if (n1.tag === n2.tag) const el = (n2.el = n1.el) // props const oldProps = n1.props || const newProps = n2.props || for (const key in newProps) const oldVal = oldProps[key] const newVal = newProps[key] if (newVal !== oldVal) el.setAttribute(key, newVal) for (const key in oldProps) if (!(key in newProps)) el.removeAttribute(key) // children const oldChildren = n1.children const newChildren = n2.children if (typeof newChildren === string) if (typeof oldChildren === string) if (newChildren !== oldChildren) el.textContent = newChildren else el.textContent = newChildren else if (typeof oldChildren === string) el.innerHTML = newChildren.forEach((child) = mount(child, el) ) else const commonLength = Math.min(oldChildren.length, newChildren.length) for (let i = 0; i commonLength; i++) patch(oldChildren[i], newChildren[i]) if (newChildren.length oldChildren.length) newChildren.slice(oldChildren.length).forEach((child) = mount(child, el) ) if (newChildren.length oldChildren.length) oldChildren.slice(newChildren.length).forEach((child) = el.removeChild(child.el) ) else // replace // reactive let activeEffect class Dep subscribers = new Set() depend() if (activeEffect) this.subscribers.add(activeEffect) notify() this.subscribers.forEach((effect) = effect() ) function watchEffect(effect) activeEffect = effect effect() activeEffect = null const targetMap = new WeakMap() function getDep(target, key) let depsMap = targetMap.get(target) if (!depsMap) depsMap = new Map() targetMap.set(target, depsMap) let dep = depsMap.get(key) if (!dep) dep = new Dep() depsMap.set(key, dep) return dep const reactiveHandlers = get(target, key, receiver) const dep = getDep(target, key) dep.depend() return Reflect.get(target, key, receiver) , set(target, key, value, receiver) const dep = getDep(target, key) const result = Reflect.set(target, key, value, receiver) dep.notify() return result , function reactive(raw) return new Proxy(raw, reactiveHandlers) const App = data: reactive( count: 22, ), render() return h( div, onClick: () = this.data.count++ , , String(this.data.count) ) , function mountApp(component, container) let isMounted = false let prevVdom watchEffect(() = if (!isMounted) prevVdom = component.render() mount(prevVdom, container) isMounted = true else const newVdom = component.render() patch(prevVdom, newVdom) prevVdom = newVdom ) mountApp(App, document.getElementById(app))/script","categories":["代码人生","前端技术"]},{"title":"pinia使用","path":"/2022/12/04/pinia使用/","content":"pinia 简易入门指南 详细文档请访问 pinia 安装使用 npm npm i pinia 使用 yarn yarn add pinia 使用 pnpm pnpm i pinia 在 vue 中使用import createApp from vueimport createPinia from piniaconst app = createApp()const pinia = createPinia()app.use(pinia)app.mount(#app) 定义一个 Store 导出的 store 函数名一般使用 use 开头 import defineStore from pinia// 第一个参数在全局store中的唯一idexport const useUserStore = defineStore(user, ) 在页面中使用 store script lang=ts setupimport useUserStore from @/store/model/userStoreconst userStore = useUserStore()// 可以使用userStore.xx来访问store中的内容/script or script lang=ts setupimport storeToRefs from piniaimport useUserStore from @/store/model/userStoreconst userStore = useUserStore()const userInfo = storeToRefs(userStore)/script Stateimport defineStore from piniaexport const useUserStore = defineStore(user, state: () = return userInfo: null, ,) 在页面中访问 state 可以直接写入读取状态 import useUserStore from @/store/model/userStoreconst userStore = useUserStore()userStore.userInfo = name: wxw, age: 23 console.log(userStore.userInfo) 重置状态 import useUserStore from @/store/model/userStoreconst userStore = useUserStore()userStore.$reset() Getters 可以等同于 vue 中的计算属性 import defineStore from piniaexport const useUserStore = defineStore(user, state: () = return userInfo: null, , getters: getUserInfo() return this.userInfo , ,) 在页面中使用 getter getter 是属性，访问时不需要使用函数的方式来访问 script lang=ts setupimport useUserStore from @/store/model/userStoreconst userStore = useUserStore()setTimeout(() = userStore.userInfo = name: wxw, age: 23 , 3000)/scripttemplate div userStore.getUserInfo /div/template Actions 相当于组件的方法（vue2 中的 methods） import defineStore from piniaexport const useUserStore = defineStore(user, state: () = return userInfo: null, , getters: getUserInfo() return this.userInfo , , actions: setUserInfo(userInfo) this.userInfo = userInfo , // 也支持异步方法 async setAdmin(userInfo) try const code, data, message = await setUserApi(userInfo) catch (error) throw error , ,) 在组件中使用 script lang=ts setupimport useUserStore from @/store/model/userStoreconst userStore = useUserStore()const setUser = () = userStore.setUserInfo( name: wxw, age: 23 )/scripttemplate button @click=setUser设置用户信息/button div userStore.getUserInfo /div/template Plugins 推介文章Pinia: How to reset stores created with functionsetup syntax","tags":["pinia"],"categories":["代码人生","前端技术"]},{"title":"vite使用","path":"/2022/12/04/vite使用/","content":"vite 简易使用指南 vite vite 的基本使用 使用 vite 创建项目使用 pnpm pnpm create vite 使用官方的模版 pnpm create vite vite-program -- --template vue-ts 生成好项目后你可以看到项目中有一个 vite.config.ts的文件，在这里我们可以进行一系列的配置 配置路径别名安装类型声明文件 pnpm i -D @type/node 将 @ 指向 src 文件 import defineConfig from viteimport vue from @vitejs/plugin-vueimport path from pathexport default defineConfig( plugins: [vue()], resolve: alias: @: path.resolve(__dirname, src) , ,) 配置代理export default defineConfig( server: proxy: // string shorthand /foo: http://localhost:4567, // with options /api: target: http://jsonplaceholder.typicode.com, changeOrigin: true, rewrite: (path) = path.replace(/^\\/api/, ), , // with RegEx ^/fallback/.*: target: http://jsonplaceholder.typicode.com, changeOrigin: true, rewrite: (path) = path.replace(/^\\/fallback/, ), , // Using the proxy instance /api: target: http://jsonplaceholder.typicode.com, changeOrigin: true, configure: (proxy, options) = // proxy will be an instance of http-proxy , , // Proxying websockets or socket.io /socket.io: target: ws://localhost:3000, ws: true, , , ,) 配置项目端口及自动启动export default defineConfig( server: port: 3030, // 服务启动端口 open: true, // 服务启动自动打开默认浏览器 ,) 配置插件在 Vue.js 中写 Jsxpnpm i -D @vitejs/plugin-vue-jsx import defineConfig from viteimport vue from @vitejs/plugin-vueimport vueJsx from @vitejs/plugin-vue-jsxexport default defineConfig( plugins: [vue(), vueJsx()],)","tags":["前端工程化","vite"],"categories":["代码人生","前端技术"]},{"title":"gulp压缩js文件","path":"/2022/12/04/gulp压缩js文件/","content":"使用 gulp 来写一个压缩 js 的小工具 使用 gulp 压缩 js 文件初始化项目 npm init -y 安装依赖包 npm i gulp gulp-uflify gulp-rename gulp-notify 编写gulpfile.js文件 const gulp = require(gulp)const uglify = require(gulp-uglify)const rename = require(gulp-rename)const notify = require(gulp-notify)// 压缩js代码function minjs() return gulp .src(js/*.js) .pipe(uglify( mangle: true, compress: true )) .pipe(rename( extname: .min.js )) .pipe(gulp.dest(dist/js)) .pipe(notify( message: 压缩完成 ))module.exports = minjs 更新 package.json script 脚本 scripts: minjs: gulp 使用方式： 在项目根目录下创建 js 文件夹（需要压缩的文件需要放到此文件夹内） 使用命令行输入 gulp minjs。运行成功后会在 distjs 文件夹中生成压缩好的 js 代码并有系统级的提示 命令行 gulp-uflify 包用于压缩 js 代码gulp-rename 用于给压缩后的文件重新命名gulp-notify 用于压缩好后进行提示（系统级提示）","tags":["js","gulp","前端工程化"],"categories":["代码人生","前端技术"]},{"title":"微信短链 URL Link","path":"/2022/12/04/miniprogram-微信短链/","content":"我们可以使用微信提供的接口来生成一个短链，可以在微信外直接跳转至指定小程序界面 获取 token 这个接口会返回一个 token 接口 请求方式 接口地址 获取 token GET https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credentialappid=appidsecret=secret 生成短链 此接口返回一个微信的短链 接口 请求方式 接口地址 获取 token POST https://api.weixin.qq.com/wxa/generate_urllink?access_token=token 注意此处的 token 必须在拼接至路径中 传参须使用 json 格式，在 body 中传参 path: /pages/index/index, query: name=wxw, expire_type: 1, expire_interval: 1, env_version: trial 官方文档","tags":["微信接口"],"categories":["代码人生","前端技术"]},{"title":"小程序分包及uniapp分包","path":"/2022/12/04/miniprogram-小程序分包及uniapp分包/","content":"分包是什么？我们为什么要进行分包？ 在微信小程序开发中，为了更加快速的加载，微信限制主包的大小不能超过 2M。对于一些稍大型的程序来说就要引入分包的概念了。 uniapp 小程序分包操作 找到 manifest.json 文件 在 mp-weixin 一项下新增 optimization: subPackages: true //是否启用分包优化 此段代码意思为： 启用分包优化 在文件根目录下创建一个文件夹作为分包，这里用page_开头来作为分包的名称。这里创建一个page_user作为演示 在 pages.json 文件中添加配置subPackages，和pages同级 pages: ... , subPackages: [ root: page_user, // 这里是分包的文件夹名称 pages: [ path: userinfo/userinfo, style: navigationBarTitleText: 用户信息, enablePullDownRefresh: false ] ] 分包访问时的路径为/page_user/userinfo/userinfo 分包预加载 参考文章：UNIAPP—-小程序分包及预加载","tags":["uniapp","小程序"],"categories":["代码人生","前端技术"]},{"title":"uniapp中使用pinia","path":"/2022/12/04/miniprogram-uniapp中使用pinia/","content":"在小程序中使用 pinianpm init -y 安装 pinia npm install pinia 创建 store 文件夹用来管理状态 store/index.js// store/index.jsimport createPinia from piniaconst store = createPinia()export default store 在 mian.js 中引入 pinia main.js// #ifndef VUE3import Vue from vueimport App from ./AppVue.config.productionTip = falseApp.mpType = appconst app = new Vue( ...App,)app.$mount()// #endif// #ifdef VUE3import createSSRApp from vueimport pinia from ./store/index.jsimport App from ./App.vueexport function createApp() const app = createSSRApp(App) app.use(pinia) return app, // #endif 创建 store 及在页面中使用详情见pinia一章 在小程序中实现数据的持久化存储 在一些时候，我们需要持久化存储一些数据，保证页面刷新后还能拿到对应的数据 我们可以使用 uni-app 的数据存储方法，uni-app 的数据存储和获取方法可以做到直接存储对象或数组到本地缓存中。我们可以利用这个来做。 存储数据获取数据删除数据的简易封装export default // 获取本地缓存中的数据 get(key) try return uni.getStorageSync(key) catch (e) console.error(e) , // 数据持久化存储 set(key, value) try uni.setStorageSync(key, value) catch (e) console.error(e) , // 移除本地存储中的数据 remove(key) try uni.removeStorageSync(key) catch (e) console.error(e) , 存储数据键值对的封装我们可以参考 ts 的 enum，将要存储到 storage 中的 key 和程序中的 key 分离开来，后期要修改 storage 中的键时，程序部分只需改动该文件即可 export default TOKEN: TOKEN, USER_INFO: USER_INFO, 此时，我们存入本地存储的 key 为 TOKEN 和 USER_INFO， 如果我们想将 TOKEN 更改为 USER_TOKEN 的话，也只需要改动该文件即可 1export default TOKEN: USER_TOKEN, USER_INFO: USER_INFO, 在对应仓库中使用 这里用 useUserStore 举例 import defineStore from piniaimport Enmu from @/enmu/index.jsimport PerStorage from @/utils/PerStorage.jsexport const useUserStore = defineStore(user, state: () = return userInfo: null, token: , , getters: getUserInfo() return this.userInfo || PerStorage.get(Enmu.USER_INFO) || , , actions: setUserInfo(userInfo) this.userInfo = userInfo PerStorage.set(Enmu.USER_INFO, userInfo) , ,)","tags":["uniapp","小程序","pinia"],"categories":["代码人生","前端技术"]},{"title":"showToast 在真机会闪退的问题及解决方案","path":"/2022/12/04/miniprogram-showToast-在真机会闪退的问题及解决方案/","content":"当你在 uni-app 中使用 showLoading 进行加载状态的实现，然后数据返回后进行其他文字提示。你可能会遇到以下问题： 在微信开发者工具中是完美的，但是到实际手机上运行（预览版正式发布）会出现 loading 加载完成后，后面的提示问题一闪而过。 导致这个问题的原因是，在小程序底层 showLoading 和 showToast 其实都是 showToast 来实现的。在实机运行时，运行的顺序是 showLoading - showToast - hideLoading。而我们想要的效果是showLoading - hideLoading - showToast 如何解决这个问题呢？在 uniapp 中，我们可以使用 showToast 来实现 loading 的效果 uni.showToast( icon: loading, duration: 300000, mask: true,) 这里的 icon 为 loading 是，就和 showLoading 现实的状态是一致的。这里的延时duration我们尽可能的设置长一些，尽量达到接口超时时间，这样，就不必担心数据还未返回，loading 状态就消失不见了。下面是一个简单的示例： async function getUserList() try uni.showToast( icon: loading, duration: 300000, mask: true, ) const code, data, message = await getUserListApi() uni.hideToast() uni.showToast( icon: none, title: message, ) catch (error) hideToast() finally","tags":["uniapp","小程序"],"categories":["代码人生","前端技术"]},{"title":"扫码跳转至指定界面","path":"/2022/12/04/miniprogram-扫码跳转至指定界面/","content":"原文地址","tags":["微信接口"],"categories":["代码人生","前端技术"]},{"title":"小程序接入微信支付","path":"/2022/12/04/miniprogram-小程序接入微信支付/","content":"// 这里的数据是后端返回的订单数据const wechatOrder = orderInfo: appid: wx1e**********689f, noncestr: 2rxK********Gv3A, package: Sign=WXPay, partnerid: 16****039, prepayid: wx13************c615acf50000, timestamp: 1663061271, sign: 3513ECA3B3AC1AD6F7D8BA748970D51D2236589734518F086AB99673AAE844FE, , 依赖加密包npm i crypto-js 小程序支付时的二次签名import crypto from crypto-js/crypto-jsconst timeStamp = Math.floor(new Date().getTime() / 1000)const key = 53E12F838************5A43C5DC3// 二次签名const sign = `appId=$appidnonceStr=$wechatOrder.orderInfo.nonce_strpackage=prepay_id=$wechatOrder.orderInfo.prepay_idsignType=HMAC-SHA256timeStamp=$timeStampkey=$key`wx.requestPayment( timeStamp: timeStamp + , // 时间戳（单位：秒） nonceStr: wechatOrder.orderInfo.nonce_str, // 随机字符串 package: `prepay_id=$wechatOrder.orderInfo.prepay_id`, // 固定值 signType: HMAC-SHA256, //固定值 paySign: crypto.enc.Hex.stringify(crypto.HmacSHA256(sign, key)).toUpperCase(), success: function (res) console.log(success: + JSON.stringify(res)) console.log(支付成功) showToast( title: 支付成功, ) , fail: function (err) console.log(fail: + JSON.stringify(err)) console.log(支付失败) showErrorMsgModal( content: err, ) ,) app 支付时的二次签名const partnerid = 160*****39const key = 53E12F838************5A43C5DC3// 报错支付场景不合法const appid = wechatOrder.orderInfo.appidconst timeStamp = Math.floor(new Date().getTime() / 1000) + const sign = `appid=$appidnoncestr=$wechatOrder.orderInfo.nonce_strpackage=Sign=WXPaypartnerid=$partneridprepayid=$wechatOrder.orderInfo.prepay_idtimestamp=$timeStampkey=$key`const orderInfo = appid: appid, // 微信开放平台 - 应用 - AppId，注意和微信小程序、公众号 AppId 可能不一致 noncestr: wechatOrder.orderInfo.nonce_str, // 随机字符串 package: Sign=WXPay, // 固定值 partnerid: partnerid, // 微信支付商户号 prepayid: wechatOrder.orderInfo.prepay_id, // 统一下单订单号 timestamp: timeStamp, // 时间戳（单位：秒） sign: crypto.enc.Hex.stringify(crypto.HmacSHA256(sign, key)), // 签名，这里用的 MD5/RSA 签名uni.requestPayment( provider: wxpay, orderInfo: orderInfo, success: (res) = console.log(调用微信支付, res) , fail: (err) = console.log(调用支付失败, err) , complete(complete) console.log(complete, complete) ,)","tags":["uniapp","小程序","支付"],"categories":["代码人生","前端技术"]},{"title":"小程序常用工具/文档","path":"/2022/12/04/miniprogram-小程序常用工具-文档/","content":"长按图片识别图中二维码image 标签中添加 show-menu-by-longpress属性 工具文档微信支付接口签名校验工具 生成二维码","tags":["工具","小程序"],"categories":["代码人生","前端技术"]},{"title":"扫码获取微信抬头","path":"/2022/12/04/miniprogram-扫码获取微信抬头/","content":"官方文档地址 实现步骤 前端扫码微信抬头，获取到返回的 result（链接） 后端实现解析链接内容接口，在后端部分调用公众号接口解析链接内容 前端部分处理script setupimport ref from vue;const result = ref();const sancode = () = uni.scanCode( success(res) result.value = res.result; console.log(result.value); uni.request( url: http://localhost:3020/api/getInvoiceTitle, method: POST, data: link: result.value , success(invoiceTitle) console.log(invoiceTitle); , fail(e) console.log(e); ); , fail(e) console.log(e: , e); );;/scripttemplate view class=contentbutton @click=sancode获取扫码结果/button/view/templatestyle lang=scss/style 后端部分的处理 这里的 APPID 和 SECRET 需要在公众号中获取 import axios from axiosimport Fastify from fastifyimport APPID, SECRET from ./configconst fastify = Fastify( logger: true )fastify.post(/api/getInvoiceTitle, async (req, res) = const link = req.body const access_token = await getAccessToken() const data = await getInvoiceTitle(link, access_token) return data )async function getAccessToken() const res = await axios.get( `https://api.weixin.qq.com/cgi-bin/token?grant_type=client_credentialappid=$APPIDsecret=$SECRET` ) const access_token = res.data return access_tokenasync function getInvoiceTitle(link, access_token) const res = await axios.post(`https://api.weixin.qq.com/card/invoice/scantitle?access_token=$access_token`, scan_text: link, ) const data = res return datafastify.listen( port: 3020 , (err, address) = console.log(http://localhost:3020))","tags":["uniapp","小程序","server","公众号"],"categories":["代码人生","前端技术"]},{"title":"小程序简易请求数据封装","path":"/2022/12/04/miniprogram-小程序简易请求数据封装/","content":"uniapp 请求封装// 从配置文件中引入配置好的默认路径import config from ./config.jsclass Request constructor() /** * BASEURL - 请求路径（公用） * method - 请求方式 * url - 请求路径 * data - 请求数据 * header - 请求头 * responseType - 返回数据类型 */ request( BASEURL = config.BASEURL, method = POST, url, data, header = Content-Type: application/json , responseType = text, ) return new Promise((resolve, reject) = uni.request( url: `$BASEURL/$url`, method, data, header, responseType, success: (res) = resolve(res) , fail: (err) = reject(err) , ) ) const http = new Request()export http","tags":["uniapp","小程序"],"categories":["代码人生","前端技术"]},{"title":"uniapp 接入微信客服","path":"/2022/12/04/miniprogram-uniapp-接入微信客服/","content":"注意必须有用户点击事件 用户点击按钮后（必须有点击），打开微信客服。 示例代码wx.openCustomerServiceChat( extInfo: url: , corpId: , success(res) , fail(error) ,) 参考文章：小程序中接入微信客服","tags":["uniapp","小程序"],"categories":["代码人生","前端技术"]},{"title":"uniapp 条件编译","path":"/2022/12/04/miniprogram-uniapp-条件编译/","content":"写法条件编译是用特殊的注释作为标记，在编译时根据这些特殊的注释，将注释里面的代码编译到不同平台。 写法：以 #ifdef 或 #ifndef 加 %PLATFORM% 开头，以 #endif 结尾。 #ifdef：if defined 仅在某平台存在#ifndef：if not defined 除了某平台均存在%PLATFORM%：平台名称 %PLATFORM% 可取的值 标识 生效条件平台 APP-PLUS App APP-PLUS-NVUE 或 APP-NVUE App nvue H5 H5 MP-WEIXIN 微信小程序 MP-ALIPAY 支付宝小程序 MP-BAIDU 百度小程序 MP-TOUTIAO 字节跳动小程序 MP-LARK 飞书小程序 MP-QQ QQ 小程序 MP-KUAISHOU 快手小程序 MP-JD 京东小程序 MP-360 360 小程序 MP 微信小程序支付宝小程序百度小程序字节跳动小程序飞书小程序QQ 小程序360 小程序 QUICKAPP-WEBVIEW 快应用通用(包含联盟、华为 ) QUICKAPP-WEBVIEW-UNION 快应用联盟 QUICKAPP-WEBVIEW-HUAWEI 快应用华为 参考文章跨端兼容","tags":["uniapp","小程序"],"categories":["代码人生","前端技术"]},{"title":"uniapp常见问题(一)","path":"/2022/12/04/miniprogram-uniapp常见问题-一/","content":"使用 pinia 后报错解决方式：实例化 store 时需要放置于 composable 函数内 import useLoginStore from @/store/loginconst loginStore = useLoginStore()function useIsLogin() function isLogin() xxx //逻辑代码 return isLogin 上面的写法打成 app 包时会导致页面白屏。更改成下面的写法就解决了 import useLoginStore from @/store/loginfunction useIsLogin() function isLogin() const loginStore = useLoginStore() xxx //逻辑代码 return isLogin 使用组件默认插槽MyComponents template #defaultcontent.../template/MyComponents!-- or --MyComponents content... /MyComponents 打包为 app 后调用微信客服uni.share( provider: weixin, openCustomerServiceChat: true, corpid: WX_CORP_ID, // 客服ID customerUrl: WX_SERVICE_CHAT_URL, // 客服的页面路径) 可能会遇到调用微信客服报错 (bad_param)的问题，需要在微信开放平台中创建一个移动应用。并在 hbuilderx 中配置微信分享的 appid（开放平台中移动应用的 appid） 打包时需注意 使用电脑模拟器进行测试时需要勾选对 x86 的支持，否则有些模拟器会打不开 正式打包时需要去除对 x86 CPU 的支持（勾选 x86 后云打包只能打包为 32 位的包，有些平台上传失败 小程序路径跳转时出现的问题跳转时携带的参数中含有字符串，会导致在跳转后的界面中使用解构获取参数时不完整。 解决方式 可以在跳转前将不需要截取的参数中使用其他字符将 符替换，在跳转后的界面中重新替换回来 可以使用 sotrage 存储数据，在跳转页面中获取 storage 中的值 小程序请求本地接口报错不在以下 request 合法域名列表中解决方法: 在微信开发者工具中 详情 - 本地设置 把 不校验本地合法域名 一项勾选 uniapp 中使用 official-account 组件时 bindload 属性和 binderror 属性不会执行解决方法将其改为 load 和 error 即可 uniapp 中的写法 official-account @error=officalAccountError @load=officalAccountErrorLoad /","tags":["uniapp","小程序"],"categories":["代码人生","前端技术"]},{"title":"app打包上线要注意的部分","path":"/2022/12/04/miniprogram-app打包上线要注意的部分/","content":"隐私政策部分在国内 app 上架应用商店必须要做此操作，大概流程如下： 找到 manifest.json 文件 - 选择 App 启动界面配置 - 勾选 使用原生隐私政策提示框 勾选后会在项目中自动添加 androidPrivacy.json 文件，可以双击打开自定义配置 version: 1, prompt: template, title: 服务协议和隐私政策, message: 请你务必审慎阅读、充分理解“服务协议”和“隐私政策”各条款，包括但不限于：为了更好的向你提供服务，我们需要收集你的设备标识、操作日志等信息用于分析、优化应用性能。br/ 你可阅读a href=\\https://fp.newtimeai.com/khsyxy.html\\《服务协议》/a和a href=\\http://cs.newtimeai.com:8889/uni-yszc.html\\《隐私政策》/a了解详细信息。如果你同意，请点击下面按钮开始接受我们的服务。, buttonAccept: 同意并接受, buttonRefuse: 暂不同意, hrefLoader: system|default, second: title: 确认提示, message: 进入应用前，你需先同意a href=\\https://fp.newtimeai.com/khsyxy.html\\《服务协议》/a和a href=\\http://cs.newtimeai.com:8889/uni-yszc.html\\《隐私政策》/a，否则将退出应用。, buttonAccept: 同意并继续, buttonRefuse: 退出应用 uniapp对隐私政策的说明详细内容请查看uniapp 对隐私政策的说明 android 应用隐私管理在应用商城上架时，在应用内必须要有用户可以关闭某些权限的功能。 关于权限判断和提示，官方推介使用App 权限判断和提示插件。 下面的三个链接，就是 uniapp 对于这部分的 api 及说明 https://uniapp.dcloud.net.cn/api/system/getappauthorizesetting.html#getappauthorizesetting https://uniapp.dcloud.net.cn/api/system/getsystemsetting.html https://uniapp.dcloud.net.cn/api/system/openappauthorizesetting.html 隐私政策参考 华为 APP 常见个人信息保护问题 FAQ 隐私政策参考（CSDN 隐私政策） uniapp Android 平台各功能模块隐私合规协议 uni-AD App 端打包注意及 plus.ad 使用指南 uniapp 国内应用市场上架 uniapp 示例项目 ios 分享签名问题 包名签名自查：https://docs.qq.com/doc/DRHJjS0RHRGFHdnly 微信开放平台：https://developers.weixin.qq.com/doc/oplatform/Downloads/Android_Resource.html","tags":["app","uniapp","项目打包"],"categories":["代码人生","前端技术"]},{"title":"Hexo-theme-Stellar主题使用","path":"/2022/12/04/Hexo-theme-Stellar主题使用/","content":"hexo-theme-stellar 主题好看配置项又多，今天和我一起来看一下如何使用该主题创建一个 hexo 博客站点吧！ 官方文档 https://xaoxuu.com/wiki/stellar/#starthttps://xaoxuu.com/wiki/stellar/#start 侧边栏配置首页侧边栏欢迎语句_data/widgets.ymlwelcome: layout: markdown title: 欢迎欢迎 content: | 本站是Whbbit1999的知识和个人博客集合站，希望您在这里玩的开心。 侧边栏文章大纲_data/widgets.ymltoc: layout: toc list_number: false # 是否显示序号 min_depth: 2 # 建议不要低于 2 即从 H2 标签开始解析（H1标签用于文章大标题） max_depth: 5 # 5 代表最多解析到 H5 标签 fallback: recent # Use a backup widget when toc does not exist. 侧边栏标签云组件_data/widgets.ymltagcloud: layout: tagcloud title: 标签云 # 标签云配置 min_font: 12 max_font: 24 amount: 100 orderby: name order: 1 # 1, sac 升序；-1, desc 降序 color: false # 使用颜色 start_color: # 开始的颜色。您可使用十六进位值（#b700ff），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。 end_color: # 结束的颜色。您可使用十六进位值（#b700ff），rgba（rgba(183, 0, 255, 1)），hsla（hsla(283, 100%, 50%, 1)）或 颜色关键字。此变量仅在 color 参数开启时才有用。 show_count: false # 显示每个标签的文章总数 使用在使用时，需要在文章配置sidebar项中配置对应的layout_id即可在对应页面展示相应的自定义组件如： ---sidebar: [toc, tagcloud]--- about 页面配置GitHub 信息_data/widgets.yml# github infoghuser: layout: ghuser api: https://api.github.com # 若有 api.github.com 镜像可填，否则保持默认 username: Whbbit1999 # your github login username avatar: true # show avatar or not menu: true # show menu or notghrepo: layout: ghrepo /source/about/index.md---sidebar: [ghuser, toc]--- 统一配置以下是我的配置 _config/stellar.yml# 侧边栏配置sidebar: widgets: #### 自动生成的页面 #### # 主页 home: search, welcome, recent,tagcloud, timeline # for home # 博客索引页 blog_index: search_blog, recent, timeline # for categories/tags/archives # 文档索引页 wiki_index: search_docs, recent, timeline # for wiki # 其它（404） others: search, welcome, recent, timeline # for 404 and ... #### 手动创建的页面 #### # 文章内页 post: toc, ghrepo, search, ghissues # for pages using layout:post # 文档内页 wiki: search, ghrepo, toc, ghissues, related # for pages using layout:wiki # 其它 layout:page 的页面 page: welcome, toc # for custom pages using layout:page menu: post: [btn.blog](/) wiki: [btn.wiki](/wiki/) # notes: [随记](/notes/) more: [社交](/about/)search: service: local_search # local_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容 codeblock: false # 是否搜索代码块（需要content: true)# 开启图片点击放大功能tag_plugins: # % image % image: fancybox: true# footerfooter: social: github: icon: svg aria-hidden=true height=24 viewBox=0 0 16 16 version=1.1 width=24 data-view-component=true class=octicon octicon-mark-github path fill-rule=evenodd d=M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z/path/svg url: https://github.com/Whbbit1999 content: | # 支持 Markdown 格式 本站由 [@Whbbit1999](/) 使用 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar) 主题创建。 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。 [晋ICP备2020011938号-1](https://beian.miit.gov.cn/) | [晋公网安备 14062102000028号](http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=14062102000028) 各种自定义标签 可以在这里找到许多自定义标签配置http://example.com/%3Cahref=https://xaoxuu.com/wiki/stellar/tag-plugins/#%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0%E6%A0%87%E7%AD%BE%E9%9B%86>https://xaoxuu.com/wiki/stellar/tag-plugins/#%E6%96%87%E6%9C%AC%E4%BF%AE%E9%A5%B0%E6%A0%87%E7%AD%BE%E9%9B%86","tags":["hexo","hexo主题"],"categories":["代码人生","静态站点"]},{"title":"Nginx安装配置","path":"/2022/12/04/Nginx安装配置/","content":"ubuntu 系统中 Nginx 的简易安装和配置 nginx 在这里我服务器使用的 ubuntu 的系统，所以就用它举例。其他操作系统几乎一致。 在 ubuntu 中安装 nginxsudo apt updatesudo apt install nginx 安转完成 nginx 会自动启用，您可以在浏览器中输入您的 ip 进行查看（需要确认您的服务防火墙开启了 80 端口）。或者使用命令 sudo systemctl status nginx nginx 常用命令 启动 nginx 服务 sudo nginx -s start 停止 nginx 服务 sudo nginx -s stop 重启 nginx 服务 sudo nginx -s reload nginx 配置配置文件详情 默认的配置文件在 /etc/nginx/目录下 主要的配置文件是 /etc/nginx/nginx.conf Nginx 服务器配置文件被储存在 /etc/nginx/sites-available 目录下。在 /etc/nginx/sites-enabled 目录下的配置文件都将被 Nginx 使用。 自定义配置我们可以使用 sudo vim /etc/nginx/sites-enabled/default 来查看和修改 nginx 配置文件 这里使用 sudo 是为了避免遭遇权限问题导致文件保存报错 下面是主要要修改的配置 server listen 80; listen [::]:80; server_name example.com; root /var/www/example.com; index index.html; location / try_files $uri $uri/ =404; 我们可以在 location 这个模块下 新建一个 root 来指定我们要访问的跟路径location / root /code/vitepress/dist; 如果该项目和默认配置的 root 地址不是一个，需要在 location 模块中配置对应的 root 目录，不然网站的 css 或者其他文件会加载不到 我们可以设置 index 来设置默认访问文件location / index index.html; 这里的 index.html 会自动拼接上面设置的 root 路径，如果在 location 中没有配置 root 就会使用全局的 server 下的 root 路径 注意记得每行命令结束后加上 ;， 要不然会报错的","tags":["Nginx"],"categories":["代码人生","Linux/运维"]},{"title":"Nginx gzip配置","path":"/2022/12/03/nginx-gzip/","content":"想让网站访问快一些吗？可以试试这个 参数 名称 默认配置 作用域 作用 gzip gzip: off http\\server\\location\\if in location 设置是否开启对后端响应的 gzip 压缩，然后返回压缩内容给前端 gzip_types gzip_types texthtml; http\\server\\location 指定哪些文件启用 gzip 压缩 gzip_comp_level gzip_comp_level 1; http\\ server\\ location 指定 gzip 压缩的级别，默认为 1，该值可设置的范围是 1-9，1 为最小化压缩(处理速度快),9 为最大化压缩(处理速度慢)，数字越大压缩的越好，也越占用 CPU 时间 gzip_min_length gzip_min_length 20; http, server, location 设定进行 gzip 压缩的阈值，当后端 response 的 Content-Length 大小小于该值则不进行 gzip 压缩 gzip_http_version gzip_http_version 1.1; http, server, location 设定进行 gzip 压缩的最小 http 版本 gzip_proxied gzip_proxied off; http, server, location 根据 request 或响应的相关 header 的值来决定是否进行 gzip gzip_static gzip_static off; http, server, location 开启之后，接到(静态文件)请求会到 url 相同的路径的文件系统去找扩展名为”.gz”的文件，如果存在直接把它发送出去，如果不存在，则进行 gzip 压缩，再发送出去 gzip_disable http, server, location 正则匹配 User-Agent 中的值，匹配上则不进行 gzip gzip_buffers gzip_buffers 32 4k 或 16 8k; http, server, location 设置用于压缩后端 response 的 buffer 的数量和每个的大小，默认每个 buffer 大小为一个内存页，根据平台不同可能是 4k 或 8k 配置文件示例 gzip 可以在 http, server, location 中和配置，配置到 http 下是全局配置，只要是使用当前 nginx 服务器的站点都会开启 gzip 这里是 nginx.conf配置文件里的设置，你可以根据需求把对应的参数注释去掉 http ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; # gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; # gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; 下面是doc.whbbit.cn的配置 http ## # Gzip Settings ## gzip on; # gzip_vary on; # gzip_proxied any; gzip_comp_level 6; # gzip_buffers 16 8k; # gzip_http_version 1.1; gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript; 查看配置文件是否正确：可以使用nginx -t 查看配置文件是否正确","tags":["Nginx","Linux","服务器"],"categories":["代码人生","Linux/运维"]},{"title":"建站记事","path":"/2022/12/02/建站记事/","content":"建站过程记 缘起离职回家已半月有余，之前使用的 vitepress 也不适合作为碎片信息搜集站点。看着之前废弃的 hexo 博客，又萌生了使用 hexo 建立一个碎片知识站点和博客文章站点。 个人历史本站点我希望能坚持下去，之前的博客站点因为服务器到期导致从 19 年年中就荒废了。代替而来的是今年年初建立的 blog.whbbit.cn 站点来记录学习和工作中的笔记。但是平时碎片知识居多，vitepress 的文件组织不是很能满足我对碎片知识的处理，所以此站应该要作为之后记录学习和生活的主站了。 对于 hexo 的使用是来自 18 年-19 年在学校找实习时，听人说有一个博客站点能为面试加分很多。随即便开始了 hexo 博客的折腾。然而事与愿违，基础知识的缺失倒是实习工作之难找，加之疫情来袭。家里蹲了几个月才找到一个在市区的工作。 因为工作要出差北京，机缘巧合下，在北京工作了两年多。如今也离开了北京，在北京这两年过的很充实，天天白天上班，晚上补充基础知识，努力扩大自己的知识认知范围。这样的努力没有白费，在年初，正式作为公司的前端组组长工作了一年有余，在管理岗位上也学习了很多东西。帮助公司进行了前后端分离的工作，对目前使用的前端架构也做出了相应的调整。 由于个人原因，暂时离开北京，回到老家休养几月。顺便思考一下自己未来的方向。 展望未来会将 doc.whbbit.cn 中的碎片知识转移过来，doc.whbbit.cn 这个站点就作为系统知识整理在积累至一定程度后整理发布。","tags":["hexo","vitepress"],"categories":["代码人生","静态站点"]},{"path":"/about/sao.html","content":"发不完牢骚，漂泊不定的人 2024 年 3 月 5 日最近每晚都睡不好，每天半夜都会惊醒一次。梦境和生活开始变得极为相似。我大概是病了吧2024 年 1 月 6 日 14:08喝点酒，感受着心脏强力的跳动，活着的感觉真好！！！2023 年 12 月 31 日 20:41新的一年快要来了，但是我看不到前方有什么希望。不知为何！2023，对所有事情都保持悲观状态。2023 年 11 月 25 日 14:26心理问题有点严重哦，要看看老庄哲学来学点超然物外的精神了！虚则静，静则定，定则从容。2023 年 11 月 19 日 20:25家里的催婚越来越严重了 如果为了结婚而结婚，这又有什么意义呢？2023 年 10 月 24 日 19:33面试出来，秋风拂面，感觉真舒服啊。恍惚间回到了 19 年，在学校中真的是初生牛犊不怕虎。现在的我却有着越来越多担心的事了。2023 年 10 月 22 日 01:24突然刷到了禁止直播带货的新闻。重心真的转到实体产业了？回家种地好像真的有出路了"},{"path":"/about/index.html","content":"个人介绍赞助列表大事记牢骚留言WxW无名小卒，为生活奔波 近日喜欢的诗作 我咽下一枚铁做的月亮许立志我咽下一枚铁做的月亮他们把它叫做螺丝我咽下这工业的废水，失业的订单那些低于机台的青春早早夭亡我咽下奔波，咽下流离失所咽下人行天桥，咽下长满水锈的生活我再咽不下了所有我曾经咽下的现在都从喉咙汹涌而出在祖国的领土上铺成一首耻辱的诗诗词节选 在听的音乐Echo 抢食异乡人 在玩的游戏我的世界 我用的设备 Macbook Pro M1 IQUNIX OG80 Razer Basilisk V3 X HyperSpeed Redmi k50 HUAWEI Free Buds 5 HUAWEI Watch GT 4 参与项目 shadcn-vue-admin Vue3 仪表盘模板 shadcn-vue Vue3 组件库 vue-devui Vue3 组件库 licht React 组件库 sable admin 中后台管理前端脚手架 SableChat UI React"},{"path":"/about/sponsor.html","content":"赞助者们 感谢各位的赞助 2022 年 11 月 02 日赞助者金额暂无0"},{"path":"/about/timeline.html","content":"大事记 2024 年 09月29我是极度不自信的一个人。但是在和几位前辈聊天后，他们都说我的技术水平还算可以。哈哈哈😄2024 年 09月20再次入京又快一年了，来时拿了多少钱，现在还是多少钱。这一年的时光像是不存在似的！2024 年 3月已经有三个月没法工资了，租的房子又要拆迁了。还得找房子2023 年 10 月重返北京，生活还需继续2023 年 7 月来大理了，出来逛逛。话说大理是真不错啊！找到一份远程的工作，感觉还不错哦！2023 年 5 月目标：成都。出发，追寻新的生活。来成都几天，找到工作了。今年的面试不好约啊。2023 年 4 月科三科四一把过，驾照拿到了，可以考虑出发了。从我上学以来，三年级就在外住校了，在家待半年的时间还是寥寥无几（印象中只有这次）。在家待的时间长了，我怕我再没勇气离开他们，离开这温暖的家。2023 年 3 月科二考过了。陪老爹去太原心血管病医院看病，住了 15 天。这应该是我和我爸独处最长的时间了。手术成功，一切顺利2023 年 2 月准备出发，但是都说考个驾照再走，工作了就不好抽时间来考试了。在大同报了个驾校。科一考过了。2023 年 1 月终于能在家过个年了，整个月都洋溢着幸福。老姐出嫁了，老爹在外打工。家里过年时显得有点冷清。2022 年 12 月疫情放开，全家都阳了一次。2022 年 11 月第一次参与开源项目，虽然只是对文档的修改。但是很兴奋经历了两年的疫情，认真思考后，从公司离职。目标：山西，回家。回家的时候还在封城，幸好听老姐的话早回几天，不然就等到 12 月全国解封了。房东人很好，走时没通暖气，把我的暖气费退掉了。"},{"path":"/friends/index.html","content":"留言赛博好友 各位大佬的博客 峰华前端工程师SunShy三只棒棒糖xaoxuu大鱼资源网 来自GitHub的朋友 可以去友链自助添加"},{"title":"常用网址导航","path":"/notes/index.html","content":"站长工具 百度统计网站访问次数统计谷歌统计谷歌网站统计 开发者 版本号规则0.0.1不兼容版本.功能更新版本.bug 修复版本^ element ui proTable postcss 插件 如何使用及 postcss 实现"},{"title":"sable系列产品计划","path":"/notes/其他.html","content":"sable admin 中后台管理多级菜单 icon 组件 coupon 优惠劵 css 组件 全局 loading 历史菜单 + keep-alive 外部链接 数据可视化集成 错误页面/登录页面优化 全局暗黑模式 手机端适配 文档集成，使用单仓库 -- vitepress 怎么让用户的数据处理不会影响全局数据呢？使用浏览器数据库在进入系统时进行数据填充？？？ sable admin 后端使用技术：nestjs + mysql 目的： 提供给 sable video 使用 练习使用 nestjs 进行后端系统的搭建 sable video 前台视频点播网站 - web 端使用技术： nuxt3 功能实现：实现用户登录，评论，视频观看，帖子发布等功能 样式设计：使用 figma 进行绘制，学习 UI 设计 目的： 练习使用 nuxt 进行前端展示页面的开发 为专栏的 nuxt 入门录制实战视频 探索 nuxt 进阶使用场景 webrtcwebgl"},{"title":"常用网址导航","path":"/notes/好文章或视频.html","content":"2023 视频文章推荐为什么有些人看起来不努力，却进步飞快？【正确打开 2023】 有的人忙着翻身，有的人急着认命 一小时读完《Vue.js 设计与实现》 要钱不要命"},{"title":"二叉树遍历","path":"/wiki/frontNotes/ds_二叉树遍历.html","content":"什么是二叉树？ 前序遍历中左右 递归var preorderTraversal = function (root) = const result = [] if (root === null) return result const order = (node) = result.push(node) if(node.left !== null) order(node.left) if(node.right !== null) order(node.right) order(root) return result 9 6 8 迭代var preorderTraversal = function(root) = const result = [] if (root === null) return result const stack = [] stack.push(root) while(stack.length 0) const current = stack.pop() result.push(current.val) if (current.right !== null) stack.push(current.right) if (current.left !== null) stack.push(current.left) return result 中序遍历左中右 递归var preorderTraversal = function(root) = const result = [] if (root === null) return result const order = (node) = if (node.left !== null) order(node.left) result.push(node.val) if (node.right !== null) order(node.right) order(root) return result 迭代var preorderTraversal = function(root) = const resultult = [] if(root === null) return resultult const stack = [] let temp = root while(temp !== null) stack.push(temp) temp = temp.left while(stack.length) const current = stack.pop() resultult.push(current.val) if (current.right !== null) let temp2 = current.right while(temp2 !== null) stack.push(temp2) temp2 = temp2.left return resultult 后序遍历层序遍历"},{"title":"JS 事件循环（EventLoop）","path":"/wiki/frontNotes/js_EventLoop.html","content":"浏览器的进程和线程进程：每个应用至少有一个进程，进程之间相互独立。线程：一个进程中包括多个线程（线程用来运行代码）。一个进程中至少有一个线程，随进程创建的线程称为主线程。如果程序需要同时执行多块代码，需要创建多个线程。 浏览器有哪些进程和线程？浏览器是一个多进程多线程的应用程序。 当浏览器启动后，会自动启动多个进程。浏览器有哪些进程呢？ 浏览器进程负责进行主界面展示（浏览器界面）、用户交互、子进程管理（其他进程都是由其产生） 网络进程负责加载网络资源 渲染进程（一个标签页对应一个渲染进程）渲染进程启动后，会开启一个渲染主线程，主线程负责执行 HTML、CSS、JS 代码。默认情况下，浏览器会为每个标签页启动新的渲染进程，保证不同标签页之间互不影响。 渲染主线程是如何工作的？渲染主线程是浏览器中最繁忙的线程，需要它处理的包括但不限于： 解析 HTML 解析 CSS 计算样式 布局 处理图层 每秒把页面绘制 60 次（FPS） 执行全局 JS 代码 执行事件处理函数 执行计时器的回调函数 …… 思考为什么不用多个线程处理这些事？ 要处理这么多任务，主线程遇到了一个难题：如何调度任务？ 比如： 正在执行一个 JS 函数，执行到一半时用户点击了按钮，要立即去执行点击事件的处理函数吗？ 正在执行一个 JS 函数，执行到一半时某个计时器到达了时间，要立即执行该计时器的回调函数吗？ 浏览器进程通知“用户点击了按钮”，与此同时，一个计时器也到达了时间，要先处理哪一个呢？ 渲染主线程说：排队，都去排队！！！ ![临时占位](.截屏 2023-10-14 17.42.50.png) 在最开始的时候，渲染主线程会进入一个无限循环while(true)... for(;;)... 每次进入循环时会判断是否有任务存在。如果有，就取出一个任务执行，执行完成后进入下一次循环；如果没有，就进入休眠状态 其他所有线程（包括其他进程的线程）可以随时向消息队列添加任务。新任务会添加到消息队列末尾。在添加新任务时，如果主线程是休眠状态，这将会唤醒主线程继续循环拿去任务。 整个过程叫做事件循环（消息循环）。 何为异步代码在执行过程中，会遇到一些无法立即处理的任务，如： 计时器完成后需要执行的任务： setTimeout setInterval 网络通信完成后需要执行的任务： XHR fetch 用户操作后要执行的任务：addEventListener 如果让渲染主线程等待这些任务的时机到达，就会导致主线程长期处于阻塞状态，从而导致浏览器卡死 ![Alt text](.截屏 2023-10-14 17.54.33.png) 渲染主线程承担着极其重要的恶工作，无论如何都不能阻塞！ 因此，浏览器选择异步来解决这个问题![Alt text](.截屏 2023-10-14 18.02.01.png) 使用异步的方式，渲染主线程永不阻塞 面试题：如何理解 js 异步JS 是一门单线程的语言，这是因为它运行在浏览器的渲染主线程中，而渲染主线程只有一个。而渲染主线程承担着诸多工作，渲染页面、执行 HTML、CSS、JS 等都在其中运行。 如果使用同步的方式，就极有可能导致主线程产生阻塞，从而导致消息队列中很多其他任务无法执行。这样依赖，一方面会导致繁忙的主线程白白消耗时间，另一方面导致页面无法及时更新，给用户造成卡死的现象。 所以，浏览器采用异步的方式来避免。具体做法是当某些任务发生时，比如计时器、网络、事件监听，主线程将任务交给其他线程去处理，自身立即结束该任务的执行，转而执行后续代码，当其他线程完成对应的任务时，将事先传递的回调函数包装成任务加入到消息队列末尾，排队等待主线程调度执行。 在这种异步模式下，浏览器用不阻塞，从而最大限度保证了单线程的流畅运行。 JS 为什么会阻碍渲染html head/head body h1wxw/h1 buttonchange name/button script const h1 = document.querySelector(h1) const btn = document.querySelector(button) function delay(duration) const start = Date.now() while (Date.now() - start duration) btn.onclick = () = h1.textContext = !!! delay(3000) /script /body/html 任务有优先级吗任务没有优先级，在消息队列中先进先出 但是消息队列是有优先级的 根据 W3C 的最新解释： 每个任务都有一个任务类型，同一个类型的任务必须在同一个队列，不同类型的任务可以分属于不同的队列。在一次事件循环中，浏览器可以根据实际情况从不同的队列中取任务执行。 浏览器必须准备好一个微队列，微队列中的任务优先所有其他任务执行 随着浏览器复杂度的提升，W3C 不再使用宏队列的说法。 在 chrome 的实现中，至少包含了下面的队列： 延时队列：用于存放计时器到达后的回调事件，优先级中 交互队列：用于存放用户操作后产生的事件处理任务，优先级高 微队列：用于存放需要最快执行的任务，优先级最高 添加到微任务的最主要方式是使用 Promise、MutationObserver // 立即把一个函数添加到微队列Promise.resolve().then(函数内容) 面试题：简述一下 JS 的事件循环事件循环又叫消息循环，是浏览器主线程的工作方式。 在 Chrome 的源码中，他会开启一个不会结束的 for 循环，每次循环从事件循环队列中取出第一个任务执行，而其他线程只需要在合适的时候将任务添加到任务队列末尾即可。 过去把事件循环队列简单分为宏队列和微队列，这种说法已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式。 根据 W3C 官方的解释，每个任务有不同的类型，同类型的任务必须在同一个队列里，不同任务可以属于不同的队列。不同任务队列有不同的优先级，再每次事件循环中，由浏览器自行决定取哪一个队列的任务，但浏览器必须有一个微任务队列，微任务队列的任务一定具有最高的优先级，必须优先调度执行。 面试题：JS 计时器能做到精确计时吗？为什么？不行，因为： 计算机硬件没有原子钟，无法做到准确计时 操作系统的计时函数本就有少量的偏差，由于 JS 的计时器最终调用的是操作系统的计时函数，也就携带了这些偏差 按照 W3C 的标准，浏览器实现计时器时，如果嵌套层级超过 5 层，则会带有 4ms 的最少事件，咋样在计时器少于 4ms 时又带来了偏差 受事件循环的影响，计时器的回调函数只能在主线程空闲时运行，这又带来了些许偏差"},{"title":"DOM","path":"/wiki/frontNotes/js_dom.html","content":"dom"},{"title":"JavaScript","path":"/wiki/frontNotes/js_index.html","content":"练习项目推荐https://github.com/Asabeneh/30-Days-Of-JavaScripthttps://github.com/Asabeneh/30-Days-Of-JavaScript JavaScript 基础"},{"title":"浏览器渲染原理","path":"/wiki/frontNotes/js_浏览器渲染原理.html","content":"什么是渲染？ 将 HTML 字符串绘制为屏幕上的像素点的过程叫渲染（render） 浏览器是如何渲染页面的当浏览器的网络线程收到 HTML 文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列。 在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程。 整个渲染流程分为多个阶段，分别是：HTML 解析、样式计算、布局、分层、绘制、分块、光栅化、绘制页面。 每个阶段都有明显的输入输出，上个阶段的输出会称为下一个阶段的输入。 这样，整个渲染流程就形成了一套组织严密的生产流水线。 渲染的第一步是 解析 HTML (Parse HTML)解析过程中遇到 CSS 解析 CSS、遇到 JS 执行 JS。为了提高解析效率，浏览器在解析开始前，会启动一个预解析的流程，率先下载 HTML 中的外部 CSS 文件和 JS 文件。 如果主线程解析到 link 位置，此时外部的 CSS 文件还是没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。 如果主线程解析到 script 位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 渲染的根本原因。 第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树中。 渲染的第二步是 样式计算主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它的最终的样式，称之为 Computed Style。 在这一过程中，很多预设值会变成绝对值，比如 red 会变成rgb(255,0,0)；相对单位会变成绝对单位，比如 em 会变成 px 这一步完成后，会得到一棵带有样式的 DOM 树。 接下来是 布局布局完成后会得到布局树。 布局阶段会依次遍历 DOM 树中的每一个节点，计算每个节点的几何信息。例如节点的宽高、相对包含块的位置。 大部分的时候，DOM 树和布局树并非一一对应。 比如 display:none 的节点没有几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然 DOM 树中并不存在这些伪元素节点，但它们拥有几何信息，所以会生成到布局树中。含有匿名行盒、匿名块盒等等都会导致 DOM 树和布局树无法一一对应。 下一步是 分层主线程会使用一套复杂的策略对整个布局树中进行分层。 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率。 滚动条、堆叠上下文、transform、opacity 等样式都会或多或少的影响分层结果，也可以通过 will-change 属性更大程度的影响分层结果。 再下一步是 绘制主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何画出来。 再下一步是 分块完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将会由合成线程完成。 合成线程首先对每个图层进行分块，将其划分为更多的小区域。 他会从线程池中拿取多个线程来完成分块工作。 再下一步是 光栅化分块完成后，进入光栅化阶段。 合成线程会将信息交给 GPU 进程，以极高的速度完成光栅化。 GPU 进程会开启多个线程来完成光栅化，并且优先处理靠近视口区域的块。 光栅化的结果，就是一块一块的位图。 再下一步是 绘制最后一个阶段就是绘制了。 合成线程拿到的每个层、每个块的位图后，生成一个个指引（quad）信息。 指引会标识出每个位图应该绘制到屏幕的哪个位置，以及会考虑到旋转、缩放等变形。 变形会发生在合成线程，与渲染主线程无关，这就是 transform 效率高的本质原因。 合成后会把 quad 提交给 GPU 进程，由 GPU 进程产生系统调用，提交给 GPU 硬件，完成最终的屏幕成像。 什么是 reflowreflow 的本质就是重新计算 layout 树。 当进行了会影响布局树的操作后，需要重新计算布局树，会引发 reflow。 为了避免连续的多次操作导致布局树反复计算，浏览器会合并这些操作，当 JS 代码全部完成后再进行统一计算。所以，改动属性造成的 reflow 是异步完成的。 也同样因为如此，当 JS 获取布局属性时，就可能造成无法获取到最新的布局信息。 浏览器在反复权衡下，最终决定获取属性立即 reflow。 什么是 repaintrepaint 的本质就是重新根据分层信息计算了绘制指令。 当改动了可见样式后，就需要重新计算，会引发 repaint。 由于元素的布局信息也属于可见样式，所以 reflow 一定会引起 repaint。"},{"title":"浏览器输入URL后发生了什么","path":"/wiki/frontNotes/js_浏览器输入URL后发生了什么.html","content":"http://www.bilibili.com/space/xxxx.html URL 是由 访问协议 http 服务器名称：域名 www.bilibili.com 资源的路径名 目录名 /space/ 文件名 xxxx.html DNS 查询为什么要有 DNS？ 每个服务器的地址其实是一个 IP 地址，IP 不是很好记忆，衍生出了域名来辅助我们记忆。DNS 可以通过域名来查找对应的 IP 地址 DNS 查询顺序如下，若其中一步成功则直接跳转到建立连接部分： 浏览器自身 DNS 操作系统 DNS 本地 hosts 文件 向域名服务器发送请求查找顺序如下： 客户端- 本地 DNS 服务器 - 根域名服务器 客户端- 本地 DNS 服务器 - 顶级域名服务器 客户端- 本地 DNS 服务器 - 权威域名服务器 发送网络请求OSI 七层网络模型 解析页面"},{"title":"JS 闭包 (Closure) 和 回调函数（callback）","path":"/wiki/frontNotes/js_闭包.html","content":"什么是闭包呢？在 JS 中当一个函数被创建的时候，闭包就形成了。 当一个函数能够直接访问外部作用域的条件下，形成闭包。 一个函数能够访问外部的词法作用域就是闭包 function test() var a = 1 var b = 2 function c() console.log(a, b) c() // 在内部调用 return cconst t = test()t() // 在外部调用，需要返回一个函数 有下面一段代码，函数 t2 是一个闭包吗？ function t2() console.log(123)function t() var a = 1 return test2() 不是，因为它不能访问 t 函数范围内的词法作用域 闭包的作用变量私有化 function calculator(initialNumber) let num = Number(initialNumber) || 0 function changeNumber(value) num += value // 闭包（获取了num） function add(value) changeNumber(value) // 闭包（获取了changeNumber函数） function minus(value) changeNumber(-value) // 闭包（获取了changeNumber函数） function value() return num // 闭包（获取了num） return add, minus, value const cal = calculator(10)console.log(cal.value()) 函数柯里化 function add(a, b, c) return function (b) return function (c) return a + b + c add(1)(2)(3) 每个闭包都绑定了块级作用的变量 https://www.bilibili.com/video/BV1ch4y1L7cU/?p=2vd_source=6e32730b05dc719c9f21598867bef69d const arr = []function getNumber() for (var a = 0; a 5; a++) arr[a] = a console.log(a) getNumber() 回调函数一段函数执行完成后要调用的函数，一般作为另一个函数的参数传递 function request(cb) console.log(请求开始) cb() console.log(请求结束)function callback() console.log(回调函数)request(callback)"},{"title":"面试题","path":"/wiki/frontNotes/js_面试题.html","content":"this闭包深度克隆递归 const cache = new WekaMap()function deepClone(value) if (typeof value !== object || value === null) return value const cached = cache.get(value) if (cached) return cached const result = Array.isArray(value) ? [] : // 保持原形一致 Object.setPrototypeOf(result, Object.getPrototypeOf(value)) cache.set(value, result) for (const key in value) // 剔除原型链上的内容 if (value.hasOwnProperty(key)) result[key] = deepClone(value[key]) return result JSON 转换 无法处理循环引用 function deepClone(value) return JSON.parse(JSON.stringify(value)) 标签页通信 当消息包含函数、Symbol 等不可序列化的值时，就会报无法克隆的 DOM 异常。 function deepClone(value) return new Promise((resolve) = const port1, port2 = new MessageChannel() port1.postMessage(value) post2.onmessage = (msg) = resolve(msg.data) ) 性能优化 CDN 引入 SPA 路由懒加载 图片懒加载 图片压缩 使用 webp 格式图片 相同类型包替换，dayjs 替换 momentjs 打包优化 代码切割，将不同的代码分包 开启 gzip 压缩"},{"title":"两数之和","path":"/wiki/frontNotes/leetcode_两数之和.html","content":"二分查找给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。 示例 1: 输入: nums = [-1,0,3,5,9,12], target = 9输出: 4解释: 9 出现在 nums 中并且下标为 4 示例 2: 输入: nums = [-1,0,3,5,9,12], target = 2输出: -1解释: 2 不存在 nums 中因此返回 -1 提示： 你可以假设 nums 中的所有元素是不重复的。n 将在 [1, 10000]之间。nums 的每个元素都将在 [-9999, 9999]之间。 解function search(nums: number[], target: number): number let right = nums.length - 1 let left = 0 while (left = right) let middle = Math.floor(left + (right - left) / 2) if (nums[middle] === target) return middle else if (nums[middle] target) left = middle + 1 else if (nums[middle] target) right = middle - 1 return -1"},{"title":"面试题","path":"/wiki/frontNotes/ms_面试题.html","content":"vue 都有哪些生命周期vue2 中有 beforeCreate,created, beforeMount,mounted, beforeUpdate, updated, beforeDestroy, destroyed vue3 中有 onBeforeMount, onMounted, onUpdate, onUpdated, onUnmount,onUnmounted都会在 setup 中同步调用 vue 双向绑定的原理是什么vue2 中使用 Object.defineProperty 来劫持每个数据的 getter 和 setter，在数据发生变化时进行响应的处理。 vue3 中使用 Proxy 来解决 Object.defineProperty 的一些问题 vue3 响应式数据原理是什么？vue3 使用了 Proxy 来实现响应式数据，放弃了 vue2 中使用 Object.defineProperty，主要是有一下几点考虑： Object.defineProperty 无法监听到数组下标的变化，导致数组通过下标添加或修改时无法响应 Object.defineProperty 只能劫持对象的属性，从而需要对每个对象进行遍历，如果属性值还是对象，就需要进行深度遍历。Proxy 可以劫持整个对象，并返回一个新对象 Proxy 不仅可以代理对象，还可以代理数组。甚至可以代理动态新增的属性 ?? Proxy 只会代理对象的第一层，vue3 是如何处理这个问题呢？判断当前的 Reflect.get 返回值是否为 Object，如果是就通过 reactive 方法进行代理，这样就做到了深度监听 ?? v-model 的双向绑定原理是什么v-model 的本质是 :value 和 updatedValue 的集合 vue2 和 vue3 渲染器的 diff 算法有什么不同呢？为什么 vue3 的性能会很好呢？为什么 vue3 的表格有时会很卡呢？有什么解决方法？vue 组建参数传递vue 路由怎么实现呢？vuex 是什么，如何使用呢？什么场景下会使用它v-if 和 v-show 的区别如何让 css 只在当前组建中起作用使用 scoped，使用 scoped 后，每个 css 会被添加一个唯一的动态属性。 scoped 如何实现样式穿透keep-alive 的实现原理是什么？相关的生命周期函数，什么场景下会使用？常用属性有哪些？怎么声明一个组件？如何实现全局组件注册？nextTick 有什么作用？实现原理是什么？SSR 的实现原理vue2 data 为什么必须是一个函数vue computed 的实现原理watch 和 computed 的区别是什么？都在场景下使用？"},{"title":"nuxt.config.ts 配置文件使用","path":"/wiki/frontNotes/nuxt_NuxtConfigTs.html","content":"alias 路径别名网站信息配置"},{"title":"初识Nuxt","path":"/wiki/frontNotes/nuxt_index.html","content":"官网网址 https://nuxt.comhttps://nuxt.com 为什么会有 Nuxt在了解为什么会出现 Nuxt 时，我们要先了解两个概念：spa 和 ssr spa： 单页应用，多用于客户端应用。使用 vue 或 React 开发的网站默认都是 spa。对 seo 不友好，搜索引擎收录率不好。 ssr： 在服务端渲染，渲染完成后返回给客户端，每个页面都有独立的 URL，对 seo 友好，搜索引擎收录率良好。 对于一些应用（官网、活动页等）需要做搜索引擎优化，所以出现了服务端渲染技术。React 的服务端渲染框架中的优胜者是 Next，vue 的服务端渲染的优胜者是 Nuxt。 初次安装使用我们可以使用 npx 直接使用 nuxi 初始化一个 Nuxt3 应用。 使用 npx 需要 npm 版本在 5.2 以上。 npx nuxi init nuxt3-learn 出现以下内容就是初始化成功了 我们可以根据提示 cd nuxt3-learn 进入项目并使用 pnpm i --shamefully-hoist 安装需要的依赖。安装完成后，使用 pnpm run dev 来启动项目，出现下面的图片说明项目启动成功。 我们可以进入http://localhost:3000来访问启动的服务，可以看到 Nuxt 的欢迎页面 目录结构创建项目后的默认目录结构|-- .nuxt/ // nuxt自动编译后的目录|-- node_modules/ // npm 依赖包目录|-- .gitignore // git忽略文件|-- app.vue // 项目入口文件|-- nuxt.config.ts // nuxt项目配置文件|-- package.json // 项目配置文件|-- pnpm-lock.yaml // pnpm 依赖锁定文件|-- README.md // 项目说明文件|-- tsconfig.json // ts配置文件 随着开发的进展，开发时需要自己创建的文件目录 需要自己创建的目录概览|-- pages // 页面目录|-- components // 组件目录|-- assets // 静态资源目录|-- public // 静态资源目录|-- layouts // 布局目录|-- composables // 在此目录下的文件会被nuxt自动引入 下一节我们会比较详细地讲解以上常用目录的使用方式"},{"title":"常用内置标签","path":"/wiki/frontNotes/nuxt_内置标签.html","content":"NuxtLinkNuxtLink 会被编译为 a 标签 template NuxtLink to=https://whbbit.cnwhbbit/NuxtLink !-- 编译后：a href=https://whbbit.cn rel=noopener noreferrerwhbbit/a -- NuxtLink to=/apiAPI/NuxtLink !-- 编译后：a href=/apiAPI/a --/template NuxtLink 包含有 target，rel，noRel 属性 template NuxtLink to=https://twitter.com/nuxt_js target=_blank Nuxt Twitter /NuxtLink !-- a href=https://twitter.com/nuxt_js target=_blank rel=noopener noreferrer.../a -- NuxtLink to=https://discord.nuxtjs.org target=_blank rel=noopener Nuxt Discord /NuxtLink !-- a href=https://discord.nuxtjs.org target=_blank rel=noopener.../a -- NuxtLink to=https://github.com/nuxt no-rel Nuxt GitHub /NuxtLink !-- a href=https://github.com/nuxt.../a -- NuxtLink to=/contact target=_blank Contact page opens in another tab /NuxtLink !-- a href=/contact target=_blank rel=noopener noreferrer.../a --/template 路由可以匹配 NuxtLink 的 to 属性时，NuxtLink 编译后会被追加router-link-exact-active类。可以使用 .router-link-exact-active 控制 NuxtLink 的高亮样式。 layout/default.vuetemplate nav NuxtLink to=/首页/NuxtLink NuxtLink to=/getstart新手入门/NuxtLink NuxtLink to=/apiAPI/NuxtLink NuxtLink to=/about关于/NuxtLink /nav main slot / /main/templatestyle .router-link-exact-active color: #12b488; /style NuxtLayoutNuxt 内置的布局标签，使用 name prop 来调用对应的布局 编写默认布局 layout/default.vuetemplate div default layout slot / /div/template 编写 docs 布局 layout/docs.vuetemplate div docs layout slot / /div/template 使用默认布局 app.vuetemplate NuxtLayoutapp.vue/NuxtLayout/template 使用 docs 布局 app.vuetemplate NuxtLayout name=docs app.vue /NuxtLayout/template ClientOnly 包裹只在客户端展示的代码片段 template ClientOnly/ClientOnly/template NuxtLoadingIndicator / 提供网页顶部加载效果提供网页顶部加载效果 示例layout/default.vuescript lang=ts setup/scripttemplate nav class=bg-gray-700 NuxtLoadingIndicator / div class=container m-auto flex w-full justify-between items-center img src=/images/cnodejs_light.svg alt= class=h-[30px] w-auto / div class=flex gap-4 py-3 justify-end NuxtLink to=/首页/NuxtLink NuxtLink to=/getstart新手入门/NuxtLink NuxtLink to=/apiAPI/NuxtLink NuxtLink to=/about关于/NuxtLink /div /div /nav div class=container m-auto mt-2 slot / /div/templatestyle scoped lang=scss a text-decoration: none; color: #fff; .router-link-exact-active color: #12b488; /style props color：加载条颜色 height：加载条高度，默认 3 duration：加载条持续时间，默认 2000ms throttle： 限制出现和隐藏，默认 200ms NuxtErrorBoundary 可以捕获错误并进行展示 NuxtWelcomeNuxt 欢迎界面，创建项目时的 app.vue 中存在 TeleportfajsdFDJAS 和 vue3 中的 Teleport 标签用法一致"},{"title":"常用目录使用概览","path":"/wiki/frontNotes/nuxt_常用目录使用概览.html","content":"pages 目录我们可以根据约定式路由来访问对应的界面 |-- pages/ |-- index.vue |-- user-[group]/ |-- [id].vue 静态资源composables 目录composables 目录下的文件会被自动引入 具名导出 composables/useFoo.tsepxort const useFoo = () = return useState(foo, () = bar) 匿名导出 composables/useFoo.tsexport default () = return useState(foo, () = bar) 在 .vue 文件中使用 app.vuetemplate divfoo/div/templatescript setup const foo = useFoo()/script layouts 目录|-- layout/ |-- default.vue |-- doc.vue layouts/default.vuetemplate div default layout slot / /div/template layouts/doc.vuetemplate div doc layout slot / /div/template components 目录|-- layout/ |-- default.vue |-- doc.vue layouts/default.vuetemplate div default layout slot / /div/template layouts/doc.vuetemplate div doc layout slot / /div/template"},{"title":"项目实战——博客项目","path":"/wiki/frontNotes/nuxt_实战.html","content":"实战部分我们使用 Nuxt3 实现一个博客项目 使用到的 Nuxt 模块@nuxtjs/tailwindcss：用户编写页面样式 https://nuxt.com/modules/tailwindcsshttps://nuxt.com/modules/tailwindcss @nuxt/content：用于解析 markdown 文件 https://nuxt.com/modules/contenthttps://nuxt.com/modules/content 项目初始化初始化博客项目 pnpm dlx nuxi init nuxt-blog cd nuxt-blog pnpm i 依赖安装 pnpm i @nuxtjs/tailwindcss @nuxt/content pnpm i -D sass 配置 nuxt.config.ts文件 export default defineNuxtConfig( modules: [@nuxtjs/tailwindcss, @nuxt/content, @nuxt/ui], highlight: theme: vitesse-dark, ,) 创建布局文件创建 content 文件夹——存放 markdown 文件"},{"title":"模块使用","path":"/wiki/frontNotes/nuxt_模块.html","content":"集成 tailwindcss安装 tailwindcss pnpm i @nuxtjs/tailwindcss 在 nuxt.config.ts 文件中配置 nuxt.config.tsexport default defineNuxtConfig( modules: [@nuxtjs/tailwindcss],) 配置完成后，我们可以在 app.vue 文件中进行测试 app.vuetemplate div class=bg-gray-200 h-screen flex items-center justify-centerapp.vue/div/template 页面成为下面的样式就说明我们已经成功将 tailwindcss 集成到我们的项目中了"},{"title":"初识Nuxt","path":"/wiki/frontNotes/nuxt_技巧.html","content":"useFetch transform可以控制需要的数据，减少请求大小，加快页面加载速度 _Nuxt_"},{"title":"初识React","path":"/wiki/frontNotes/react_index.html","content":"https://beta.reactjs.org/https://beta.reactjs.org/"},{"title":"初识 TypeScript","path":"/wiki/frontNotes/ts_index.html","content":"https://www.typescriptlang.org/https://www.typescriptlang.org/ 为什么要学习 TypeScript 为大型系统而生 ts 是静态类型化的 js 的超集，在大型工程中有无可比拟的优势。 招聘市场需求 大量的前端团队都在使用 ts 进行系统的开发。 新框架几乎都在使用 ts 推荐课程我觉得学习 ts 最快的方法就是跟着别人的视频先大概了解一下 ts 到底是什么，能干什么事，大概的语法了解一下，深入部分可以自己去官方文档去查看。这里我推介一下我学习 ts 用到的部分视频资料网址。 付费教程： 后盾人网站 包含了装饰器等的使用，可以从多个角度了解 ts 在日常开发中的使用。在这个网站中甚至有 vue3、vue-router、js 基础、php 等全方面教程。可以全方位了解开发时前后端的流程。 https://www.houdunren.comhttps://www.houdunren.com 免费教程： 小满zs 的 ts 基础教程 https://www.bilibili.com/video/BV1wR4y1377K/?vd_source=6e32730b05dc719c9f21598867bef69dhttps://www.bilibili.com/video/BV1wR4y1377K/?vd_source=6e32730b05dc719c9f21598867bef69d 开发前的准备在开始使用 ts 前要有以下的准备工作： nodejs 8.0，最好是在 12 版本以上 包管理工具： npm、yarn 或 pnpm 其一 可以现在 typescript 官方训练场测试学习测试 ts 代码 https://www.typescriptlang.org/playhttps://www.typescriptlang.org/play 也可以在本地安装 typescript 进行项目开发 安装 ts 推荐使用 vite 创建 ts 项目，开箱即用。 通过 npm 全局安装 ts npm i -g typescript 创建环境手动创建创建 ts-learn 目录用于 ts 的学习 mkdir ts-learn cd ts-learn 在 ts-learn 目录下进行 node 项目初始化 npm init -y 进行 ts 的初始化工作 全局安装 ts 后会有 tsc 命令 tsc --init tsc 项目初始化后，会出现 tsconfig.json 文件，可以在 tsconfig.json 中开启或关闭某些设定。 使用 vite 创建更推介这种创建方式，省去很多对 tsc 的配置，可以让我们专注在 ts 的内容中 pnpm create vite 选择 Vanilla , typescript 即可创建好一个 typescript 的项目。"},{"title":"interface 和 type","path":"/wiki/frontNotes/ts_interface和type.html","content":"interface 和 abstract 抽象类想比 interface 中不能有具体代码实现。 类中实现 interface在类中要实现 interface，需要使用 implements interface name interface IAnimal name: string getName(): voidabstract class Animal constructor(public name: string) setName(name: string) this.name = name class Cat extends Animal implements IAnimal constructor(public name: string) super(name) public getName(): string return this.name const cat = new Cat(cat)cat.setName(dog)console.log(cat.getName()) interface 对对象的约束interface 对对象的约束，作用和 type 类似 [key: string]: any; 表示对象的键需要是字符串类型，值的累心不做约束 interface IUser name: string age: number site?: string info(): string [key: string]: anylet user: IUser = name: wxw, age: 25, sex: 男, info() return `$this.name $this.age` , 在函数中使用 interfaceinterface IUser name: string age: numberfunction setUser(user: IUser) return usersetUser( name: wxw, age: 25 ) interface 对函数的约束interface IGetUser (name: string): stringconst getUser: IGetUser = (name: string) = return nameconsole.log(getUser(W)) 在类中使用 interfaceinterface IUser name: string age: numberclass User _info: IUser constructor(user: IUser) this._info = user get info() return this._info const user = new User( name: whbbit, age: 25 )console.log(user.info) 数组中使用 interfaceinterface IUser name: string age: numberconst user1 = name: whbbit, age: 25 const user2 = name: wxw, age: 25 const users: IUser[] = [user1, user2] interface 结合 enumenum SexType BOY, GIRL,interface IUser name: string age: number sex: SexTypeconst user1 = name: whbbit, age: 25, sex: SexType.BOY const user2 = name: wxw, age: 25, sex: SexType.GIRL const users: IUser[] = [user1, user2] interface 的继承interface IVoice voice(): voidinterface IAnimal extends IVoice name: string getName(): void// 相当于// interface IAnimal // name: string;// getName(): void;// voice(): void;// interface 声明合并写一个同名 interface 就会实现 interface 的合并。 后面的 interface 和前面的 interface 中不能有同名参数 interface IAnimal name: string getName(): stringinterface IAnimal voice(): stringconst cat: IAnimal = getName() return this.name , name: cat, voice() return miao~ ,console.log(cat.getName())console.log(cat.voice()) type大多数情况下 type 和 interfere 使用相同 type TUser = name: string; age: 25 function getUser(user: TUser): TUser return userconst user: TUser = name: wxw, age: 25,console.log(getUser(user)) type 可以作为基本类型的别名使用，也可以申明联合类型 type IsAdmin = booleantype Sex = boy | girl type 和 interface 的区别 interface 同名会合并，type 同名会报错 interface 可以继承，type 使用 合并 type 可以使用 合并 interface 类型 type TName = name: stirng ;type TAge = age: number ;interface IMember = member: booleantype TUser = TName TAge IMember;"},{"title":"函数","path":"/wiki/frontNotes/ts_函数.html","content":"对函数进行声明 let func = () = whbbit.cn// ts会自动推断类型为 let func:() =string 明确类型赋值 let func: Function 对函数参数的类型限制function add(a: number, b: number) return a + badd(1, 2) 参数为可选参数时，可以使用 ? 进行限制，没有参数传参时，默认为 undefined function add(a: number, b: number, c?: number) console.log(c) // undefined return a + badd(1, 2) 设置默认参数值 有默认值时，? 需要去除 function add(a: number, b: number, c: number = 20) console.log(c) // 20 return a + badd(1, 2) 对函数返回值的类型限制ts 可以对函数返回值进行自动推断 let add = (a: number, b: number) = return a + b 也可以手动对返回值进行类型限制 let func = (a): void = console.log(`接收到了参数 $a`) function add(a: number, b: number): number return a + b 使用 type 对重复类型声明进行抽离let addUser = (user: name: string; age: number ): void = console.log(`添加用户$user`)addUser( name: whbbit, age: 25 )let updateUser = (user: name: string; age: number ): void = console.log(`编辑用户$user`)updateUser( name: whbbit1999, age: 25 ) 这时我们会发现，有重复的类型声明。我们可以使用 type 对重复的类型声明进行抽离 type userType = name: string; age: number let addUser = (user: userType): void = console.log(`添加用户$user`)addUser( name: whbbit, age: 25 )let updateUser = (user: userType): void = console.log(`编辑用户$user`)updateUser( name: whbbit1999, age: 25 ) 对函数结构的定义let func: (a:number, b: number) = number; // 这里是函数的结构// 这里是函数的实现func = (x: number, y:number) return x + y let addUser: (user: name: string; age: number ) = voidaddUser = (user: name: string; age: number ) = console.log(user)addUser( name: whbbit, age: 25 ) 可以使用 type 定义函数结构 type userType = name: string; age: number type addUserFunc = (user: userType) = voidlet addUser: addUserFuncaddUser = (user: userType) = console.log(user)addUser( name: whbbit, age: 25 ) 剩余参数的使用function sum(...args: number[]): number return args.reduce((s, n) = s + n, 0)console.log(sum(1, 2, 3, 4, 5)) function push(arr: any[], ...args: any[]): any[] arr.push(...args) return arrlet arr = push([], 1, 2, true, false)console.log(arr)"},{"title":"元组 tuple","path":"/wiki/frontNotes/ts_元组.html","content":"// 数组类型的限制， 我们无法做到对对应位置元素类型的限制let arr: (string | number)[] = [whbbit, wxw, 25] 元组可以对固定位置参数类型的限制 // 限制arr第一个元素是string类型，第二个元素是number类型，第三个元素是boolean类型let arr: [string, number, boolean] = [whbbit, 20, false]arr[0] = wxw // 类型正确，可以进行更改arr[0] = 10 // 这时就会报错"},{"title":"namespace 命名空间","path":"/wiki/frontNotes/ts_命名空间.html","content":"我们可以使用命名空间进行隔离，命名空间中的内容想让外部使用时，需要导出。类似于 es6 中的模块 namespace User export let username: string = whbbitconsole.log(User.username) 命名空间的嵌套想让外部使用时，需要对嵌套的命名空间进行导出 namespace User export let username: string = whbbit export namespace Member export let name = wxw console.log(User.Member.username)"},{"title":"基本数据类型","path":"/wiki/frontNotes/ts_基本数据类型.html","content":"包含了对断言、never、void 等类型的说明 基本类型定义数据类型，基本数据类型中包含 string number boolean 等 let name: string = whbbit // name 的值只能是字符串类型let age: number = 25 // age的值只能是数值类型let work: boolean = false // work的值只能是true/falselet stringArr: string[] // 数组里的值只能是字符串let obj1: object // obj1必须是一个对象let obj: name: string; age: number // obj这个对象中只能包含name和age属性，且类型必须是规定的类型 在 : 前添加 ? 表示这个值不是必填 let obj1: name: string; age: number; work: boolean = name: whbbit, aage: 25,console.log(obj1) // 编译时会有报错，Property work is missing in type name: string; age: number; but required in type name: string; age: number; work: boolean; .let obj: name: string; age: number; work?: boolean = name: whbbit, age: 25,console.log(obj) 类型自动推断在不写类型时，ts 会自动进行类型推断 let name = whbbit // 等同于 - let name: string = whbbit 类型组合使用 | 表示类型可以多选，符合 | 之前或者之后的类型即可 let a: string | number // 表示a可以是字符串也可以是一个数值a = whbbita = 20let b: string | number | booleanb = whbbitb = 20b = falselet arr: (string | number)[] = [] // 数组内容只能为字符串或数值类型let arr1: Arraystring | number = [] // 使用泛型 any在我们不知道是什么类型时，可以定义为 any 类型。对类型不做校验 let a: anya = whbbita = 10a = falsea = [whbbit]let arr: Array[any]let arr1: any[] 也可以对构造函数生成的实例进行类型限制。 不推介这样做，class 的类型推断和限制就没有了，不符合使用 ts 的场景 class Animal constructor() get = () = whbbit.cnconst cat: any = new Animal() 对配置文件改动，取消对 any 类型的自动推断 noImplicitAny: true unknownunknown 和 any 的区别 unknown 表示有类型但是不明确类型是什么，ts 会进行类型的判断 any 表示这个值没有类型，ts 不会进行类型的判断 let a: anylet a1: string = a // 不会进行报错，ts不做类型校验let b: unknownlet c: string = b // ts校验报错，类型不匹配 可以使用 as 断言来解决 let b: unknownlet c: string = b as string // 断言变量b一定是一个string类型的值 断言是什么? 怎么用?let a: string = 20let b: number = a as number // 会报错，不能对已经声明类型的值进行断言 怎么解决这种问题呢？ 我们可以先将 b 转换为 unknown 类型再断言 let a: string = 20let b: number = a as unknown as number voidvoid 可以是 null 或 undefined，多用于函数返回值的类型 let a: void = nulla = undefined nevernever 不是任何类型，在函数不能执行到结尾时进行类型推断 function err(): never throw new Error(err) void 和 never 的区别 void 常用作函数的返回值的推断，函数没有返回值时，可以将返回类型写为 void never 常用作 函数不能执行到末尾 时对函数类型的限制 function printString(content: any): void console.log(content)function throwError(err): never throw new Error(err) null undefinednull 和 undefined 代表的类型就是 js 中对应的 null 和 undefined let a: null = nulllet b: undefined = undefined 默认情况下 null 和 undefined 可以作为其他类型的值 let a: stringa = nulla = undefined// 这时不会报错 可以修改 tsconfig.json 文件中的配置让其不能作为其他类型的值 strictNullchecks: true"},{"title":"枚举类型","path":"/wiki/frontNotes/ts_枚举类型.html","content":"枚举的默认编号从 0 开始 enum SexType BOY, GIRL,console.log(SexType.BOY) // 0 可以自定义起始编号，后面的会自动 +1 enum SexType BOY = 1, GIRL,console.log(SexType.BOY, SexType.GIRL) // 1, 2 可以自定义值 enum Values TOKEN = token, SITE = whbbit.cn,"},{"title":"ts中的类","path":"/wiki/frontNotes/ts_类.html","content":"对参数进行约束定义一个普通的类，约束其接收的参数的类型 class User name: string age: number constructor(name: string, age: number) this.name = name this.age = age const user1 = new User(Whbbit, 25)const user2 = new User(wxw, 25)// 限制users数组的值只能是User类示例化的对象const users: User[] = [user1, user2] public 修饰符使用 public 修饰符表示这个函数，变量可以在函数外进行访问。默认为 public 在 js 中默认就可以在外部进行访问 class User public name: string public age: number constructor(name: string, age: number) this.name = name this.age = age public getName() return `name: $this.name, age: $this.age` const user1 = new User(whbbit, 25)user1.name = wxwconsole.log(user1.name)console.log(user1.getName()) protected 修饰符使用 protected 后，只能在类中调用。可以对方法和属性进行约束。 class User protected name: string protected age: number constructor(name: string, age: number) this.name = name this.age = age protected show() console.log(show) public getName() return `name: $this.name, age: $this.age` const user1 = new User(whbbit, 25)user1.name = wxw // ts 报错console.log(user1.name) // ts 报错user1.show() // ts 报错console.log(user1.getName()) // 正常运行 在父类中声明的受保护的方法或属性，在子类中可以调用。但在类外部不可调用 class Person protected name: string protected age: number protected show() console.log(show) class User extends Person constructor(name: string, age: number) super() this.name = name this.age = age public getInfo() return this.show() const user1 = new User(wxw, 25)user1.getInfo() private 私有属性在子类或类外部都不可访问。在父类中定义的私有方法子类不可使用，不可覆盖 class Person protected name: string; public age: number; private site: string; protected show() console.log(show， `site is $this.site`); class User extends Person constructor(name: string, age: number) super(); this.name = name; this.age = age; getSite() console.log(this.site); public getInfo() return this.show(); const user1 = new User(wxw, 25);user1.getInfo();console.log(user1.site); 在父类中定义的受保护的方法，在子类中可以使用，可以覆盖，但是权限只能降低为 public 或维持 protected。不能将其更改为private class Person protected name: string; public age: number; private site: string; protected show() console.log(show， `site is $this.site`); class User extends Person constructor(name: string, age: number) super(); this.name = name; this.age = age; getSite() console.log(this.site); private show() console.log(这里是子类覆盖掉的shou方法) public getInfo() return this.show(); const user1 = new User(wxw, 25);user1.show() readonly限定属性不能进行修改 class Axios readonly site: string = https://www.whbbit.cn/api constructor() public get(url: string) console.log(`请求地址是$url`) return [] const instance = new Axios()console.log(instance.site)instance.site = https://api.com // 报错：Cannot assign to site because it is a read-only property 但是在构造函数初始化时可以更改 class Axios readonly site: string = https://www.whbbit.cn/api constructor(site?: string) this.site = site || this.site public get(url: string) console.log(`请求地址是$this.site/$url`) return [] const instance = new Axios()instance.get(article) // 请求地址是https://www.whbbit.cn/api/articleconst instance1 = new Axios(https://www.whbbit.cn/docs)instance1.get(article) // 请求地址是https://www.whbbit.cn/docs/article readonly 前可以添加 public、protected、 private等修饰符 constructor 构造函数在构造函数中接收的参数前书写修饰符，ts 会自动帮我们进行初始化操作 class User constructor(public name: string, public: age: string) // 等同于 // public name: string // public age: number // constructor( name: string, age: number) // this.name = name // this.age = age // static 静态属性方法static 静态属性方法只能通过构造函数调用。 使用 static 修饰属性 class Axios static site: string = whbbit.cn constructor() const instance = new Axios()console.log(Axios.site)console.log(instance.site) // 报错 上面代码编译为 js 后的代码 use strictclass Axios constructor() Axios.site = whbbit.cnconst instance = new Axios()console.log(Axios.site)console.log(instance.site) // 报错 static 也可以修饰方法 class Axios static site: string = whbbit.cn constructor() public static getSite() return Axios.site const instance = new Axios()console.log(Axios.getSite()) get setclass User constructor(private _name: string) public get name(): string return this._name public set name(name: string) this._name = name const user = new User(wxw)console.log(user.name)console.log((user.name = whbbit))console.log(user.name) 使用访问器 getset 可以在设置或获取时进行处理 type articleType = title: string class Articles constructor(private _lists: articleType[] = []) get articles(): articleType[] return this._lists.map((article) = article.title = article.title + www.whbbit.cn return article ) set articles(articles: articleType[]) this._lists = articles const list = new Articles()list.articles = [ title: ts中的类 , title: ts断言 ]console.log(list.articles) 单例模式实现 将构造函数设置为私有 定义一个静态方法用来生成实例 定义一个静态属性，在静态方法中判断是否已经初始化，未初始化就进行初始化，已经初始化直接返回这个生成的实例 class Axios private static instance: Axios | null = null private constructor() console.log(构造函数方法) static make(): Axios if (Axios.instance === null) Axios.instance = new Axios() return Axios.instance const instance = Axios.make()console.log(instance) 抽象类// 抽象类abstract class Animal constructor(public name: string) abstract getName(): string setName(name: string) this.name = name // 派生类class Cat extends Animal constructor(public name: string) super(name) public getName(): string return this.name const cat = new Cat(cat)cat.setName(dog) 抽象类无法被实例化 派生类中需要实现抽象类中定义的方法"},{"title":"generics 泛型","path":"/wiki/frontNotes/ts_泛型.html","content":"什么是泛型可以理解为动态的类型，类型中可以接受参数。 我们要做一个输入什么就返回什么的函数，当我们将类型写死后，传递其他类型的数据就会在编译时报错类型错误。我们能不能做到在传递参数时声明一个类型，让我们声明的类型进行判断呢？ function returnSomething(inputSomething: string): string return inputSomethingreturnSomethingstring(wx)returnSomething(23) // 报错 这时我们可以使用泛型接受类型参数 function returnSomethingT(inputSomething: T): T return inputSomethingreturnSomethingstring(wx)returnSomethingnumber(2) 泛型的继承 extends有时我们需要一些特定类型的参数，里面包含一些相同的类型，我们可以用 extends 继承来约束可以传递的参数 function getLengthT extends length: number (arg: T): number return arg.lengthfunction getLengthT extends length: number (arg: T): number return arg.lengthgetLength(www)getLength([2, 3, 4])getLength(2) // 报错 类中使用我们可以使用泛型对函数的类型做限制，将类型的定义部分开放给用户。 class UserT constructor(private user: T) get(): T return this.user interface IUser name: string age: numberconst user = new UserIUser( age: 2, name: xxx )console.log(user.get()) interface 使用泛型interface IArticleB, C title: string isLock: B comments: C[]type CommentType = content: string const article: IArticleboolean, CommentType = title: 测试文章, isLock: false, comments: [ content: 测试评论 ],"},{"title":"as 断言","path":"/wiki/frontNotes/ts_断言.html","content":"断言就是我说了算。 // 这里的element 默认类型是HTMLElement | null ，这里我们可以直接说明这个element一定存在并且为一个div标签const element = document.getElementById(el) as HTMLDivElement as const 断言let a: string = whbbita = whbbit.cnconst b = whbbit // 按照js语法，b的值不能被改变let c = whbbit as const // c的值可以改变，但是只能改变为whbbit// 写法等同于 let c: whbbit = whbbit 数组使用 as const 时，相当于声明一个元组。 const arr = [whbbit, 25] as const// 等同于 const arr: [whbbit, 25] = [whbbit, 25]let a: string = whbbitlet b: number = 25const arr1 = [a, b] as const// 等同于 const arr: [string, number] = [a, b] 对象使用 as const 时 let age: number = 20let c = true as constconst obj = name: whbbit, age, c, as const// 类型为 readonly name: whbbit, readonly age: number, readonly c: true 数组或对象使用 as const 时，如果内容是引入别处的变量时，就使用该变量的类型，如果是常量时，就使用该常量的值 as const 在解构中使用的便利性 function func() let a = whbbit let b = 25 return a, b as constlet a, b = func()// 这时ts可以准确的推断a的类型是string，b的类型是number。// 不使用as const 时，a和b的类型都是 string | numberconsole.log(a, b) 非空断言const el = document.querySelector(#app)// 类型为 HTMLElement | null 当我们知道 id app 的元素是一个 div 元素时，我们想让其类型明确为HTMLDivElement 以获得更好的类型提示 const el: HTMLDivElement = document.querySelector(#app)// 这时会报错 Type HTMLDivElement | null is not assignable to type HTMLDivElement. Type null is not assignable to type HTMLDivElement. 当我们清楚的知道这个元素一定不为空时，就可以使用非空断言 const el: HTMLDivElement = document.querySelector(#app)! 或者我们也可以直接为其断言 const el = document.querySelector(#app) as HTMLDivElement DOM 类型推断我们可以断言 DOM 类型， 事件类型等 const el = document.querySelector(#app) as HTMLDivElementel.addEventListener(click, (e: Event) = console.log(e.target))"},{"title":"TypeScript中的类型工具","path":"/wiki/frontNotes/ts_类型工具.html","content":"这部分内容不是很好懂，可以多练习几次 extends 的多种使用方式类型继承extends 可以表示必须包含后面的类型 function userT extends id: number; render: (x: number) = number (arr: T[]) console.log(arr)user([ id: 1 ]) extends 类型条件判断窄类型 extends 宽类型 ? xxx : xxx判断窄类型是否从属于宽类型，可以就为 true，否则为 false type a = name: string; age: number type b = name: string type c = b extends a ? true : falselet d: c = falsed = true // 报错 对泛型进行条件判断分配类型使用[]包裹表示完全比对 [T] extends [a] type a = string | undefinedtype bT = T extends a ? string : booleanconst c: bnumber = false // 这时number不在a的类型里，所以此时c类型为booleanconst d: bstring = d // string在a的类型中，此时d的类型为string Exclude 过滤从左侧联合类型中过滤掉右边的类型，保留左侧类型比右侧类型中多的类型 type a = number | booleantype b = number | string | booleantype c = Excludeb, a// 获得的新类型为 stringtype d = Excludea, b// 获得的新类型为 never Extract和 Exclude 作用相反。只保留右侧类型声明中的类型 type a = number | boolean | stringtype b = Extracta, number | boolean// 获得的新类型为 number | boolean Picktype PICKT,U extends keyof K = {[P in U]: T[P]} 在类型中提取某几个组成新类型 type User = name: string; age: number; site: string let user: PickUser, name | site = name: wxw, site: whbbit.cn // 获得的新类型为 name: string, site: string Partial将属性类型转为可选 type User = name: string; age: number; site: string const user: PartialUser = // 获得的新类型为 name?:string; age?:number; site?: string Record快速生成具有属性的类型 type User = Recordstring, string | number// 获得的新类型为 [x: string]: string | number keyofinfer"},{"title":"结语","path":"/wiki/frontNotes/ts_结语.html","content":"看完这些，基本的 ts 项目就大概可以看懂了。如果你想要精进自己的 ts 技术，可以去玩一下 https://github.com/type-challenges/type-challengeshttps://github.com/type-challenges/type-challenges 也可以去挑战一下 ts 的类型体操，不过这个对于实际项目中没有什么作用。"},{"title":"Decorators 装饰器","path":"/wiki/frontNotes/ts_装饰器.html","content":"代码来自后盾网 装饰器为 ts 提供了强大的代码复用功能 使用装饰器需要在 tsconfig.json 中修改 装饰器是试验性的功能，需要在配置文件中开启 tsconfig.jsonexperimentalDecorators: true,emitDecoratorMetadata: true 类装饰器 ClassDecorator相当于在原型对象上添加属性 类装饰器只有一个参数，是构造函数。 const moveDecorator: ClassDecorator = (target: Function) = console.log(target) target.prototype.getPosition = (): x: number; y: number = return x: 20, y: 20 @moveDecoratorclass Player @moveDecoratorclass Tank const player = new Player()console.log(player.getPosition()) 装饰器语法糖 @不使用语法糖，需要传递类到对应的函数中。使用语法糖不需要手动调用。 const moveDecorator: ClassDecorator = (target: Function) = console.log(target) target.prototype.getPosition = (): x: number; y: number = return x: 20, y: 20 // 不使用语法糖class Player moveDecorator(Player)// 使用语法糖@moveDecoratorclass Tank const player = new Player()console.log(player.getPosition()) 装饰器叠加可以使用多个装饰器 const moveDecorator: ClassDecorator = (target: Function) = target.prototype.getPosition = () = console.log(获取位置) const MusicDecorator: ClassDecorator = (target: Function) = target.prototype.playMusic = () = console.log(音乐播放) @moveDecoratorclass Player const player = new Player()player.getPosition()@MusicDecorator@moveDecoratorclass Tank const tank = new Tank()tank.playMusic()tank.getPosition() 实例：全局消息响应const MessageDecorator: ClassDecorator = (target: Function) = target.prototype.sendMessage = (message: string, type: success | error = success) = return message, type, @MessageDecoratorclass LoginController login() console.log(登录业务处理) setTimeout(() = this.sendMessage(登录成功) , 2000) new LoginController().login() 装饰器工厂根据不同的条件返回不同的装饰器 const MusicDecorator = (type: string): ClassDecorator = switch (type) case player: return (target: Function) = target.prototype.playMusic = () = console.log(play player music) case tank: return (target: Function) = target.prototype.playMusic = () = console.log(play tank music) default: return (target: Function) = target.prototype.playMusic = () = console.log(play other music) @MusicDecorator(player)class Player new Player().playMusic()@MusicDecorator(tank)class Tank new Tank().playMusic() 方法装饰器const ShowDecorator: MethodDecorator = (...args: any[]) = console.log(args) /** 打印参数： [0]: 如果是静态函数就是构造函数，如果是普通方法就是其原型对象 [1]: 使用装饰器的方法名称 [2]: 方法属性的描述 [ User: , show, value: [Function (anonymous)] // 函数的内容 writable: true, enumerable: false, configurable: true ] */class User @ShowDecorator public show() 可以使用函数装饰器更改函数的内容 const ShowDecorator: MethodDecorator = (...args: any[]) = console.log(args) args[2].value = () = console.log(ShowDecorator changed) class User @ShowDecorator public show() console.log(show function ) new User().show() // 打印 ShowDecorator changed，函数内容已经被更改 上面那样使用数组接收后调用不是很直观，我们可以使用变量名接收方法装饰器参数 const ShowDecorator: MethodDecorator = (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = ... ; const ShowDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = descriptor.value = () = console.log(ShowDecorator changed) class User @ShowDecorator public show() console.log(show function ) new User().show() // 打印 ShowDecorator changed，函数内容已经被更改 调用装饰器时，也可以更改静态方法的内容 const ShowDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = descriptor.value = () = console.log(ShowDecorator changed) class User @ShowDecorator public static show() console.log(show function ) User.show() // 打印 ShowDecorator changed，函数内容已经被更改 调用 writable = true 控制方法不能重新声明 const ShowDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = descriptor.value = () = console.log(ShowDecorator changed) descriptor.writable = falseclass User @ShowDecorator public static show() console.log(show function ) User.show() // 打印 ShowDecorator changed，函数内容已经被更改User.show = () = console.log(重写show方法)User.show() 示例：模拟代码高亮可以先使用变量将函数内容保存起来，在自定义操作后直接调用保存的函数 const HighlightDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value descriptor.value = () = return `div style=background: red;$method()/div` class User @HighlightDecorator public show() return js code new User().show() 示例：结合装饰器工厂实现延迟执行const SleepDecorator = (times: number = 2000): MethodDecorator = return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value descriptor.value = () = setTimeout(() = method() , times) class User @SleepDecorator(3000) public show() console.log(wxw) new User().show() 示例：全局异常处理const ErrorDecorator: MethodDecorator = ( target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value descriptor.value = () = try method() catch (e) // 函数中抛出的错误在这里进行处理 console.log(%c异常处理, color: green;) console.log(`%c$e`, color: red) class User @ErrorDecorator find() throw new Error(出错了) new User().find() 示例：根据权限限制访问可以根据传入的权限数组进行判断用户是否有访问权限 type UserType = name: string; isLogin: boolean; permissions: string const user = name: wxw, isLogin: true, permissions: [admin, member],const AccessDecorator = (keys: string[]): MethodDecorator = return (target: Object, propertyKey: string | symbol, descriptor: PropertyDescriptor) = const method = descriptor.value const validate = () = keys.every((k) = user.permissions.includes(k)) descriptor.value = () = // 控制用户登录并且有权限才可访问 if (user.isLogin validate() === true) console.log(验证通过) method() return else console.log(验证失败) return false class User @AccessDecorator([admin]) find() console.log(find function) new User().find() 属性装饰器接收的参数 args[0]: target 静态参数就是构造函数，普通参数就是其原型对象 args[1]: propertyKey 属性名称 args[2]: undefined const PropDecorator: PropertyDecorator = (target: Object, propertyKey: string | symbol) = console.log(target, propertyKey)class User public username: string 实例：使用属性装饰器动态改变对象属性将属性改为全部大写 const UpperDecorator: PropertyDecorator = (target: Object, propertyKey: string | symbol) = let value: string = undefined //在这里使用Object.defineProperty对原数据进行更改 Object.defineProperty(target, propertyKey, get() return value.toUpperCase() , set(v) value = v , )class Article @UpperDecorator public title: string | undefinedconst article = new Article()article.title = article titleconsole.log(article.title) 参数装饰器接收的参数 args[0]: target 静态参数就是构造函数，普通参数就是其原型对象 args[1]: propertyKey 属性名称 args[2]: parameterIndex 参数所在的位置，从 0 开始计数 const ParamDecorator: ParameterDecorator = (target: Object, propertyKey: string | symbol, parameterIndex: number) = console.log(target, propertyKey, parameterIndex)class User show(id: number, @ParamDecorator user: name: string ) 装饰器执行顺序:参数装饰器 - 方法装饰器"},{"title":"初识Vue3","path":"/wiki/frontNotes/vue_index.html","content":"https://cn.vuejs.org/https://cn.vuejs.org/ 前端路由 多页面和单页面的区别： 多页面使用多个 HTML 切换页面内容向服务器请求新的 HTML 文件来切换新的内容 单页面使用单个 HTML，通过 JS 切换页面内容 多页面应用和路由多个 HTML 之间的跳转组成了多页面路由 单页面应用和路由单个 HTML 页面根据 js 切换页面内容 hash 和 history 模式的区别"},{"title":"设计","path":"/wiki/notes/design_index.html","content":"B 端设计主要内容 框架 排版 字体 色彩 控件 组件 icon B 端主要参数常用宽度 1440 1920 字体大小 min 12px base 14px 16px title 18px 常用布局 上下布局 左右布局 T 型布局 T 型布局常用参数 宽度 1440px 侧边栏 200 - 300px 顶栏 40 - 60px 最小颗粒度？8 * 8 px XYD Design 规范 来源：https://preline.co/ 内容层级关系 如何选择使用弹窗、抽屉或者跳转页面？https://www.bilibili.com/video/BV1Ve411M77i/?vd_source=6e32730b05dc719c9f21598867bef69d 原位编辑 - 气泡 - 弹窗 - 抽屉 - 页面跳转 复杂度 - 降低 独立性- 升高 草帽设计 移动端设计尺寸选择 ICON 绘制灵感 绘制灵感 和文字一起使用时，ICON 可以考虑从文字中提取 去除装饰，极简风格 保持线条宽度一致 使用基本几何形状拼接完成 系统 ICON 宽高 24*24 使用时需注意 居中问题 粗细问题 颜色感官一致 APCA https://www.myndex.com/APCA/ https://contrast.tools/"},{"title":"mac软件","path":"/wiki/sites/mac软件.html","content":"MacWk精品mac软件下载MacBL马可菠萝 - 分享你喜欢的MAC应用Xclient精品MAC应用分享 mac 好用软件分享 鼠标平滑滚动- mos https://mos.caldis.me/https://mos.caldis.me/"},{"title":"其他","path":"/wiki/sites/其他.html","content":"在线简历制作https://www.mujicv.com/index.htmlhttps://www.mujicv.com/index.html"},{"title":"网站收藏","path":"/wiki/sites/index.html","content":"这里包含有我收藏的一些好用的网站，具体分为以下几类： 网站维护数据统计类 电子书电子文档 开发相关资源 自媒体相关资源"},{"title":"开发相关","path":"/wiki/sites/开发相关.html","content":"学习网站web.devhttps://web.dev/uiverse css案例https://uiverse.io/ GitHub 开源库离线IP地址定位库和IP定位数据管理框架https://github.com/lionsoul2014/ip2region编程学习路径https://roadmap.sh/markdown编辑器https://imzbf.github.io/md-editor-v3/docs视频播放插件 哔哩哔哩样式https://artplayer.org/document/ vue 组件库Element UIhttps://element.eleme.io/#/zh-CNElement Plushttps://element-plus.org/zh-CN/#/zh-CNAnt Design Vuehttps://antdv.com/components/overview-cnMaterial Design for Bootstrap 5 & Vue 3https://mdbootstrap.com/docs/vue/Vanthttps://vant-ui.github.io/vant/#/zh-CNVuetifyhttps://vuetifyjs.com/zh-Hans/Quasarhttps://quasar.dev/Naive UIhttps://www.naiveui.com/zh-CN/os-theme React 组件库MUIhttps://mui.com/zh/Ant Designhttps://ant.design/index-cnArco Designhttps://arco.designfluentuihttps://github.com/microsoft/fluentuidndkitreact 拖拽组件 cssCSS Loading效果https://loading.io/css/Tailwidcsshttps://tailwindcss.com/loadinghttps://cssloaders.github.io/daisyuihttps://daisyui.com/aceternityhttps://ui.aceternity.com/ 后端管理脚手架BuildAdminhttps://wonderful-code.gitee.io/Pure Adminhttps://yiming_chang.gitee.io/pure-admin-doc/DataV vue 支持 Vue3 + Vite 的 DataV 组件库https://datav-vue3.netlify.app/ 其他工具npmnpmmdnmdn字体下载编程字体下载网站百度翻译百度翻译谷歌翻译谷歌翻译Vue3项目初始模板antfu的Vue3项目初始模板vxe-table 高性能表格组件高性能表格，可以代替 antd-vue 的表格组建精灵图切图自动精灵图切图在线nginx配置在线nginx配置网站Puppeteer无头浏览器jsont 在线JSON验证和编辑在线JSON验证和编辑electron-vitehttps://cn.electron-vite.org/ 桌面端框架taurihttps://tauri.app/Wailshttps://wails.io/Electronhttps://www.electronjs.org/Nw.jshttps://nwjs.io/Flutter for Desktophttps://flutter.dev/multi-platform/desktop"},{"title":"电子书/文档站点","path":"/wiki/sites/电子书.html","content":"Flutter实战·第二版https://book.flutterchina.club/Axioshttps://axios-http.com/Socket.IOhttps://socket.io/Rust 程序设计语言 中文版https://rustwiki.org/zh-CN/book/title-page.html语义化版本https://semver.org/lang/zh-CN/labuladong 的算法小抄https://github.com/labuladong/fucking-algorithmHTTPS的工作原理https://howhttps.works/zh/中医古籍http://www.mst1739.com/yidao/yuedu.php编程相关书籍https://github.com/justjavac/free-programming-books-zh_CN移动端开发啊https://github.com/hoosin/mobile-web-favorites程序员编程技艺https://github.com/julycoding/The-Art-Of-Programming-By-July-2nd腾讯前端代码编写规范http://alloyteam.github.io/CodeGuide/逐行剖析vuejs源码https://nlrx-wjc.github.io/Learn-Vue-Source-Code/算法通关手册（LeetCode）https://algo.itcharge.cn/"},{"title":"自媒体","path":"/wiki/sites/自媒体.html","content":"图片处理移除图片背景https://www.remove.bg/zh在线 pshttps://www.logosc.cn/online-ps免版权的高质量图库[unsplash]https://unsplash.com/矢量插画 unDrawhttps://undraw.co/illustrations头像生成https://ezshine.jnsii.com/cases/avatarbuilder/快速生成网站截图https://www.thum.io/ 颜色相关中国传统色http://zhongguose.com/色板materialuihttps://materialui.co/socialcolors/色板flatuicolorshttps://flatuicolors.com/palette/defo渐变色webgradientshttps://webgradients.com/渐变色webkulhttps://webkul.github.io/coolhue/colorhunthttps://colorhunt.co/颜色转换工具https://htmlcolorcodes.com/zh/colorbox色板https://colorbox.io/智能渐变工具https://mycolor.space/网页配色，可以直接预览效果https://palettemaker.com/ 设计相关dribbblehttps://dribbble.com/lordicon 动态iconhttps://lordicon.com/d.design 堆友https://d.design/yesicon快速查询ICON动态icon快速查询ICON配色生成https://randoma11y.com/ 音频相关日系音乐[魔王魂]https://maou.audio/category/bgm/freemusicarchivehttps://freemusicarchive.org/homesoundcloudhttps://soundcloud.com/lakeyinspired"},{"title":"站长工具","path":"/wiki/sites/站长工具.html","content":"百度统计网站访问次数统计谷歌统计谷歌网站统计"},{"title":"待办","path":"/wiki/sable/TODO.html","content":"O1 Sable Admin 1.0.0 正常 0% KR1 功能模块 新增功能内嵌其他网站设置界面全局Loading自定义权限指令，控制是否展示该元素标签页部分标签栏展示标签页内容缓存标签页动画标签页刷新等操作 正常 0% KR2 集成功能 ECharts示例权限管理代码提交校验，提交前检查 正常 0% KR3 monorepo 改造 正常 1% KR4 功能更改/优化 消息提示组件拖拽组件UnoCSS样式路由部分优化 正常 0%"},{"title":"快速开始","path":"/wiki/sable/index.html","content":"介绍运行环境配置 nodejs 版本需要在 14.x 以上 nodejs 是完全免费的，您不必为此支付任何资金 本项目使用 pnpm 作为包管理工具，建议使用 pnpm 进行依赖的安装及其他操作 前置知识 您需要了解 Vue3 的基础知识 ts 需要了解基础部分，您可以观看本站点的 TypeScript 基础 来对 ts 进行初步了解 需要会使用 git 进行代码拉取 如何加入 sable还在持续更新中，本项目欢迎您的参与。 本项目使用 MIT 开源协议，理论上您可以免费使用且不必担心版权问题。 代码获取与运行git clone git@github.com:Whbbit1999/sable.git 依赖安装 pnpm i 依赖安装后，可以使用以下命令启动项目 pnpm run dev 目录说明src 目录 srcapi 目录用来存放与后端交互的接口信息 srcassets 用来存放项目静态文件 srccomponents 目录放置自定义组件 srccomposables 放置 vue 可复用代码 srcenum 用来放置项目中的静态变量 srclayouts 用来放置项目布局文件 srcplugins 项目使用的插件的配置 srcrouter 路由及路由配置文件 srcstore pinia 公共数据 srcstyles 公共样式文件 srcutils 公共工具函数 srcviews 页面 其他目录 types 存放 ts 类型 vite 存放 vite 配置文件 public 项目公共静态资源 mock mock 数据接口"},{"title":"代码格式","path":"/wiki/sable/代码格式.html","content":"本项目集成了 eslint 、prettier 和 husky 对代码格式进行格式校验 代码校验使用 eslint 进行校验 pnpm run lint 代码格式化使用 prettier 自动格式化代码 pnpm run format 代码提交代码提交时需要按照commitlint来对提交信息进行格式化 type：commit 的类型； feat：新功能、新特性； fix: 修改 bug； perf：更改代码，以提高性能； refactor：代码重构（重构，在不影响代码内部行为、功能下的代码修改）； docs：文档修改； style：代码格式修改, 注意不是 css 修改（例如分号修改）； test：测试用例新增、修改； build：影响项目构建或依赖项修改； revert：恢复上一次提交； ci：持续集成相关文件修改； chore：其他修改（不在上述类型中的修改）； release：发布新版本； workflow：工作流相关文件修改。 # 示例1fix(global):修复checkbox不能复选的问题# 示例2 下面圆括号里的 common 为通用管理的名称fix(common): 修复字体过小的BUG，将通用管理下所有页面的默认字体大小修改为 14px# 示例3fix: value.length - values.length"},{"title":"代码精简","path":"/wiki/sable/代码精简.html","content":"我们可以删除一些不需要的内容来完成对本系统体积的精简，这里我对每个模块需要删除的部分都列出来 视频播放组件删除依赖包 pnpm uninstall artplayer 删除 /src/components/Custom/VideoPlayer.vue rm -rf /src/components/Custom/VideoPlayer.vue 删除 /src/views/customComponents/player.vue rm -rf /src/views/customComponents/player.vue 删除 /router/modules/customComponents.ts 中的 videoPlayer 部分 path: videoPlayer, name: components.videoPlayer, component: () = import(@/views/customComponents/player.vue), meta: auth: true, menu: title: 视频播放器 , markdown 编辑器删除依赖包 删除 富文本编辑器删除依赖包 二维码组建删除依赖包 拖拽组建删除依赖包"},{"title":"单元测试","path":"/wiki/sable/单元测试.html","content":"本项目集成了 vitest 进行单元测试 编写测试文件任何使用*.test.[ts,js]或*.spec.[ts,js]的文件都可以被 vitest 进行测试 这里测试一下 env 函数是否会自动将.env文件中的变量进行类型转换 env.test.tsimport test, expect from vitestimport envs from ../envtest(env, () = expect(envs.VITE_ROUTE_AUTOLOAD).toBeTypeOf(boolean) expect(envs.VITE_BASE_URL).toBeTypeOf(string)) 测试pnpm test 查看测试覆盖率pnpm coverage"},{"title":"布局设置","path":"/wiki/sable/布局设置.html","content":"布局文件在/src/layouts文件夹中，目前有 default 默认布局： SableAdmin 脚手架的主要布局，包含 左侧侧边栏、顶栏、底部 blank 空白布局：不需要左侧侧边栏的部分可以引入此布局 在路由配置文件中的使用一般一级路由为布局，下面是主布局和空白布局的示例 主布局 说明一般页面可以使用默认布局 import Layout from @/layouts/default/index.vueimport RouteRecordRaw from vue-routerexport default path: /editor, component: Layout, name: editor, meta: auth: true, menu: title: 编辑器, order: 2, showParentMenu: false, icon: ion:document, , type: layout, , children: [ path: base, name: editor.base, component: () = import(@/views/editor/base.vue), meta: menu: title: 富文本编辑器 , , path: markdown, name: editor.markdown, component: () = import(@/views/editor/markdown.vue), meta: permissions: [admin], menu: title: markdown编辑器 , , , ], as RouteRecordRaw 空白布局 说明错误页面或者不想使用主布局文件时使用 import BlankLayout from @/layouts/blank.vueimport RouteRecordRaw from vue-routerexport default path: /error, component: BlankLayout, name: error, meta: menu: show: true, title: 错误页面, order: 3, icon: ion:ios-close-circle, , type: layout, , children: [ path: 404, name: error.404, component: () = import(@/views/errors/404.vue), meta: menu: show: true, title: 404页面 , , path: 502, name: error.502, component: () = import(@/views/errors/502.vue), meta: menu: show: true, title: 502页面 , , ], as RouteRecordRaw"},{"title":"路由设置","path":"/wiki/sable/路由设置.html","content":"路由设置文件在 /src/router/models/ 路由 meta 说明路由 meta 可以书写一些路由的属性，ts 配置文件在 /types/typings.d.ts import vue-routerdeclare module vue-router interface RouteMeta // 访问权限 auth?: boolean // 登录用户可访问 guest?: boolean // 游客可访问 permissions: string[] // 可访问权限 type: layout | menuItem // 菜单类型 // 和菜单相关 menu?: showParentMenu: boolean // 是否显示一级菜单， default = true title: string // 页面标题 icon: string // icon show?: boolean // 是否在菜单中显示 为false或不设置不在菜单中显示 default = true key?: string // 菜单唯一标识 order?: number // 菜单排序 keepAlive?: boolean // 是否可以缓存 showTag?: boolean // 是否在历史菜单中显示 default = true 自动引入在 /src/router/models/ 文件夹中放置的路由配置文件会被自动加载，无需在在别处引入 注意目前只支持文件类型，对文件夹的支持还未完成 外链本项目支持在路由侧展示外链，具体写法如下 该路由是外链时，path 字段即为该网址。该路由不会在历史菜单中显示！ 说明这里引入 Blank 空白布局是为了避免浏览器控制台中报错，你也可以引入任何一个视图文件来规避这个问题。 import Blank from @/layouts/blank.vueimport RouteRecordRaw from vue-routerexport default path: , component: () = import(@/layouts/default/index.vue), name: links, meta: menu: title: 外链, order: 99, showParentMenu: false, icon: ion:link , type: layout, , children: [ name: whbit, path: https://whbbit.cn, component: Blank, meta: menu: title: whbbit主页 , , name: vue, path: https://cn.vuejs.org/, component: Blank, meta: menu: title: vue官网, icon: logos:vue , , ], as RouteRecordRaw 多级路由适配多级路由适配已完成，可以根据路由配置文件自动生成多级菜单 说明只有一个子菜单时，会平铺到父级菜单中"},{"title":"路由守卫","path":"/wiki/sable/路由守卫.html","content":"目前全局路由守卫在router/guards.ts文件中"},{"title":"使用 JSON 配置生成表格","path":"/wiki/sable/自定义表格.html","content":"基本用法 表格展示列默认为文本展示，可以设置为图片、标签、日期等展示方式。 可选值为： image | tags | date table.config.tsexport const UserTableField = makeColumn([ key: id, title: ID, width: 50 , key: name, title: 昵称, width: 100 , key: avatar, title: 头像, type: image, width: 100 , key: email, title: 邮箱 , key: tags, title: 标签, type: tags , key: created_at, title: 创建时间, type: date, width: 140 , key: updated_at, title: 更新时间, type: date, width: 140 ,] as RenderColumnType[]) 表格 action 操作列底层使用 h() 渲染 naive-ui 的按钮组件，可以自定义按钮的类型、大小、图标等属性。 其中 icon 可以使用安装好的 unocss 的 icon 组件，也可以使用 naive-ui 的 icon 组件。 使用 unocss icon 需使用 renderCustomIcon(系列名:图标名) 的形式，如 renderCustomIcon(carbon:edit) 系列名可参考 icones 使用 naive-ui icon 需要使用renderIcon(ICON组件)渲染，如 renderIcon(CashOutline)。 其余 props 可以参考 naive-ui 的按钮组件。 table.config.tsimport renderCustomIcon, renderIcon from @/utilsimport CashOutline from @vicons/ionicons5export const UserTableButton: TableButton[] = [ title: 编辑, command: edit, props: type: primary, quaternary: true, renderIcon: renderCustomIcon(carbon:edit), , , title: , command: disabled, props: type: warning, circle: true, quaternary: false, renderIcon: renderIcon(CashOutline), , , title: 删除, command: delete, props: type: error, quaternary: true, , ,] 默认配置pageSizesconfig/table.tsexport const pageSizes = [ label: 10 每页, value: 10 , label: 20 每页, value: 20 , label: 30 每页, value: 30 , label: 40 每页, value: 40 ,] props props 说明 类型 默认值 columns 表格列配置 RenderColumnType[] [] api 请求接口函数 () = Promiseany[] () = Promise.resolve([]) button 表格操作按钮配置 TableButton[] [] action 点击操作按钮触发的回调函数 (command: string, row: any) = void () = void 示例API 接口配置文件api/userApi.tsimport http from ../plugins/axiosexport async function userList(page = 1) return http.getIUserModel[]( url: `users?page=$page`, ) 表格配置文件config/table.tsimport renderCustomIcon, renderIcon from @/utilsimport CashOutline from @vicons/ionicons5export const UserTableField = makeColumn([ key: id, title: ID, width: 50 , key: name, title: 昵称, width: 100 , key: avatar, title: 头像, type: image, width: 100 , key: email, title: 邮箱 , key: tags, title: 标签, type: tags , key: created_at, title: 创建时间, type: date, width: 140 , key: updated_at, title: 更新时间, type: date, width: 140 ,] as RenderColumnType[])export const UserTableButton: TableButton[] = [ title: 编辑, command: edit, props: type: primary, quaternary: true, renderIcon: renderCustomIcon(carbon:edit), , , title: , command: disabled, props: type: warning, circle: true, quaternary: false, renderIcon: renderIcon(CashOutline), , , title: 删除, command: delete, props: type: error, quaternary: true, , ,] 主页面crud-table.vuescript setup lang=ts import userList from @/api/userApi import UserTableButton, UserTableField from @/config/table function handleActions(command: string, row: any) // TODO 点击操作后 if (command === edit) console.log(编辑, row) return if (command === delete) console.log(删除, row) return if (command === disabled) console.log(禁用, row) return /scripttemplate BasicTable :columns=UserTableField :api=userList :button=UserTableButton @action=handleActions //template 效果"},{"title":"辅助工具","path":"/wiki/sable/辅助工具.html","content":"本项目集成了 cli 工具，可以方便的创建对应的文件模块"},{"title":"参考系统","path":"/wiki/sable/项目优化.html","content":"Soybean Admin https://admin-docs.soybeanjs.cn/https://admin-docs.soybeanjs.cn/ 布局模式 左侧菜单模式 左侧菜单混合模式 顶部菜单模式 顶部菜单混合模式 系统主图颜色配置 菜单查询组件 图标选择器 Vben Admin https://doc.vvbin.cn/https://doc.vvbin.cn/ 系统锁屏 二维码组件 密码输入框 vue-element-plus-admin https://element-plus-admin-doc.cn/https://element-plus-admin-doc.cn/ JSON 编辑器 瀑布流"},{"title":"NuxtUI示例","path":"/wiki/video-point/NuxtUI示例.html","content":"NuxtUI 是 Nuxt 团队出品的一套 UI 组件库。 从今天开始让我们一起来学习一下这套组件库要怎么使用吧。 环境搭建 – Nuxt3 环境搭建我们要先创建一个 Nuxt 项目 pnpm dlx nuxi@latest init nuxt-ui-template 进入项目并安装依赖 cd nuxt-ui-template pnpm i 安装 NuxtUI pnpm add @nuxt/ui 配置nuxt.config.ts nuxt.config.tsexport default defineNuxtConfig( modules: [@nuxt/ui],) 在 app.vue 中搞一个 button 组建看看先 app.vuetemplate div UButtonbutton/UButton /div/template 启动项目 pnpm run dev 如果出现了这个按钮，就说明我们成功配置了 NuxtUI。我们先看看 Nuxt 官方的几个项目来看下这个组件库有多好看吧。 实例预览voltaNuxtLabs组件配置 – 配置项配置我们可以创建一个 app.config.ts 作为 NuxtUI 的配置文件。可以配置组件的一些基本行为，像是按钮的圆角、颜色等。 我们这里配置一个经典的橙黑配色 app.config.tsexport default defineAppConfig( ui: primary: orange, gray: neutral, button: rounded: rounded-sm, , ,) 具体组件使用实战 – 我的世界资源站点具体实战部分我们跳转到下一个系列，我的世界资源站点"},{"title":"项目配置","path":"/wiki/sable/项目配置.html","content":"项目配置文件在 config 文件夹中，目前只有 config.ts 一个文件 export default menu: showChildrenRouteIcon: true, // 是否显示子路由图标 defaultRouteIcon: ion:book, // 子路由默认图标 , historyMenuMax: 10, // 历史菜单最大显示数量"},{"title":"为什么要做技术视频","path":"/wiki/video-point/index.html","content":"为什么要做技术视频？ 巩固自己学到的知识 在准备视频时需要熟悉各种知识 名声 可以在网上获得一些赞许 更好的工作机会 增加曝光，可以获得更好的工作机会或者拿到一些项目 方向主要做 JavaScript 生态的一些内容，包括： 原生三件套：JS、HTML、CSS vue 生态：vue、nuxt、uniapp react 生态：react、next nodejs：nodejs、express、nest electron 主要方向是项目实战。后端使用 nodejs ，数据库使用 mongodbmysqlpgsql ，前端使用 vuereact 等进行项目复刻。"},{"title":"vscode基础使用指南","path":"/wiki/vscode/index.html","content":"https://code.visualstudio.com/https://code.visualstudio.com/ 为什么是 vscodevscode 是微软开源的免费的文本编辑器，被广泛地在前端工作中使用。它提供了丰富的插件供人们进行代码编写和文字工作。 可以满足我们平时的工作和学习，最吸引人的是它完全免费。 基础配置我们可以进行一些简单的配置来让 vscode 更加好用。在 settings.json 中可以做一些配置 editor.formatOnSave: true 上面这段配置表示在保存时进行代码格式化 editor.bracketPairColorization.enabled: true,editor.bracketPairColorization.independentColorPoolPerBracketType: true 上面这段配置表示开启括号对着色，可以让不同层级的括号展示不同的颜色。"},{"title":"Stellar主题搭建个人站点","path":"/wiki/video-point/使用Stellar主题搭建个人站点.html","content":"参考文章 hexo 官网 https://hexo.io/zh-cn/node 官网 https://nodejs.org/zh-cngit 官网 https://git-scm.com/download/winStellar 主题主题文档 https://xaoxuu.com/wiki/stellar/彩虹猫图标 https://slackmojis.com/categories/25-blob-cats-emojis 前置知识markdown 基础可以参考markdown 基础进行观看。 这一节我们进行了 markdown 基础语法的学习，下一节我们就开始安装依赖搭建 搭建站点依赖安装 安装 nodejs访问 nodejs 官网 进行对应系统的下载。 下载 LTS长期维护版 版本即可 安装成功后可以在终端中使用node --version 和 npm --version 查看是否下载成功 安装 gitwindow 用户可以访问git 官网 进行安装mac 用户可以使用 homebrew 进行安装 brew install git 安装 hexo-cli安装 nodejs 后可以使用 npm 指令进行安装。 全局安装即可，可以省去配置环境变量的过程，对新手更加友好 npm i -g hexo-cli 到这一步，我们的环境已经搭建成功，下一节我们开始开始搭建个人站点 项目搭建上一节我们把所有依赖的环境都安装成功了，这一节我们开始使用 hexo 搭建个人站点 这节视频中，我们使用 my-site 作为我们的站点目录进行演示： 初始化项目hexo init my-site 启动项目 我们可以使用 npm 指令进行项目启动，也可以使用 hexo 进行启动。npm 指令可以在 package.json 文件中 scripts 中查看。这里我们使用 npm 指令启动项目。 npm run server 主题安装这里我们可以访问 Stellar 主题主题文档进行查看详细说明。或者跟着我的步骤操作 安装主题 npm i hexo-theme-stellar 更改主题在_config.yml中找到并修改 theme: stellar 我们再次启动项目，可以发现已经是 Stellar 的样子了。下一节我们进行站点配置，来个性化的定制各种页面。 站点配置配置文件一览Stellar 主题的配置文件我们可以去node_modules里查看。我们找到hexo-theme-stellar/_config.yml文件。这里就是 Stellar 主题支持的所有配置了。 Stellar主题配置 ######## Stellar info ########stellar: version: 1.19.0 homepage: https://xaoxuu.com/wiki/stellar/ repo: https://github.com/xaoxuu/hexo-theme-stellar cdn_css: # Use cdn links instead of /css/main.css cdn_js: # Use cdn links instead of /js/main.js######## head tags ########open_graph: enable: true twitter_id: # for open_graph meta######## Sidebar ########sidebar: logo: avatar: [config.avatar](/about/) # you can set avatar link in _config.yml or [https://xxx.png](/about/) title: [config.title](/) # you can set html tag like: [img no-lazy height=32px src=xxx/](/) menu: # post: [btn.blog](/) # wiki: [btn.wiki](/wiki/) # friends: [友链](/friends/) # about: [关于](/about/) # Sidebar widgets widgets: #### 自动生成的页面 #### # 主页 home: search, recent, timeline # for home # 博客索引页 blog_index: search_blog, recent, timeline # for categories/tags/archives # 文档索引页 wiki_index: search_docs, recent, timeline # for wiki # 其它（404） others: search, recent, timeline # for 404 and ... #### 手动创建的页面 #### # 文章内页 post: search_blog, toc, ghrepo, ghissues # for pages using layout:post # 文档内页 wiki: search, ghrepo, toc, ghissues, related # for pages using layout:wiki # 其它 layout:page 的页面 page: toc, search # for custom pages using layout:page######## Index ########post-index:# 近期发布 分类 标签 归档 and ... # 朋友文章: /friends/rss/######## Main ########breadcrumb: home: home # config.title / config.author / home or custom content######## Article ########article: # 如果没有指定封面，是否根据 tags 作为关键词搜索封面图片？ auto_cover: false # search from https://source.unsplash.com/ # 如果没有指定横幅，是否根据 tags 作为关键词搜索横幅图片？ auto_banner: false # search from https://source.unsplash.com/ # 如果没有指定 excerpt 和 description，将自动取多长的内容作为文章摘要？ auto_excerpt: 200 # 分类颜色 category_color: 探索号: #f44336 # 文章许可协议 license: 本文采用 [署名-非商业性使用-相同方式共享 4.0 国际](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。 # 分享 share: # [wechat, weibo, email, link] # 相关文章，需要安装插件 (for layout: post) # npm i hexo-related-popular-posts related_posts: enable: false max_count: 5search: service: local_search # local_search, todo... local_search: # 在 front-matter 中设置 indexing:false 来避免被搜索索引 field: all # post, page, all path: /search.json # 搜索文件存放位置 content: true # 是否搜索内容######## Comments ########comments: service: # beaudar, utterances, giscus, twikoo, waline, artalk # beaudar # https://beaudar.lipk.org/ beaudar: repo: xxx/xxx issue-term: pathname issue-number: theme: preferred-color-scheme label: input-position: top # top/bottom 评论框位置 comment-order: desc # desc 排序 keep-theme: # true/false loading: false branch: main # utterances # https://utteranc.es/ utterances: repo: xxx/xxx issue-term: pathname issue-number: theme: preferred-color-scheme label: # giscus # https://giscus.app/zh-CN giscus: data-repo: xxx/xxx # [在此输入仓库] data-repo-id: # [在此输入仓库 ID] data-category: # [在此输入分类名] data-category-id: data-mapping: pathname data-strict: 0 data-reactions-enabled: 1 data-emit-metadata: 0 data-input-position: top # top, bottom data-theme: preferred_color_scheme data-lang: zh-CN data-loading: lazy crossorigin: anonymous # Twikoo # https://twikoo.js.org/ twikoo: js: https://gcore.jsdelivr.net/npm/twikoo@1.6.8/dist/twikoo.all.min.js # 建议锁定版本 envId: https://xxx # vercel函数 # Waline # https://waline.js.org/ waline: js: https://unpkg.com/@waline/client@2.14.1/dist/waline.js css: https://unpkg.com/@waline/client@2.14.1/dist/waline.css # Waline server address url, you should set this to your own link serverURL: # If false, comment count will only be displayed in post page, not in home page commentCount: true # Pageviews count, Note: You should not enable both `waline.pageview` and `leancloud_visitors`. pageview: false # Custom emoji # emoji: # - https://unpkg.com/@waline/emojis@1.1.0/weibo # - https://unpkg.com/@waline/emojis@1.1.0/alus # - https://unpkg.com/@waline/emojis@1.1.0/bilibili # - https://unpkg.com/@waline/emojis@1.1.0/qq # - https://unpkg.com/@waline/emojis@1.1.0/tieba # - https://unpkg.com/@waline/emojis@1.1.0/tw-emoji # - https://unpkg.com/@waline/emojis@1.1.0/bmoji # 设置自己的图床服务，替换默认的 Base 64 编码嵌入（有体积大小限制），在评论中上传图片更加方便 # imageUploader: # 适配了兰空图床V1、V2版本 # 以兰空图床V1为例，下列填写内容为： # fileName: file # tokenName: Authorization # api: https://xxxxxx/api/v1/upload # token: Bearer xxxxxxxxxxxxxx # resp: data.links.url # 以兰空图床V2为例，下列填写内容为： # fileName: image # tokenName: token # api: https://xxxxxx/api/upload # token: xxxxxxxxxxxxxx # resp: data.url # fileName: # 根据版本二选一 # tokenName: # 根据版本二选一 # api: # 图床 api 地址 # token: # 图床验证 # resp: # 图片地址返回值的字段 # Artalk # https://artalk.js.org/ artalk: css: https://unpkg.com/artalk@2.4.3/dist/Artalk.css js: https://unpkg.com/artalk@2.4.3/dist/Artalk.js server: # 后端服务地址 placeholder: darkMode: auto######## Footer ########footer: social: # github: # icon: img src=https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/08a41b181ce68.svg/ # url: / # music: # icon: img src=https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/3845874.svg/ # url: / # unsplash: # icon: img src=https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/3616429.svg/ # url: / # comments: # icon: img src=https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/social/942ebbf1a4b91.svg/ # url: /about/#comments sitemap: # 博客: # - [近期](/) # - [分类](/) # - [标签](/) # - [归档](/) # 项目: # - [开源库](/) # 社交: # - [友链](/) # - [留言板](/) # 更多: # - [关于本站](/) # - [GitHub](/) content: | # 支持 Markdown 格式 本站由 [@anonymity](/) 使用 [Stellar](https://github.com/xaoxuu/hexo-theme-stellar) 主题创建。 本博客所有文章除特别声明外，均采用 [CC BY-NC-SA 4.0](https://creativecommons.org/licenses/by-nc-sa/4.0/) 许可协议，转载请注明出处。 # 主题用户越多，开发者维护和更新的积极性就越高，如果您喜欢本主题，请在适当的位置显示主题信息和仓库链接以表支持。######## Tag Plugins ########tag_plugins: # % ablock % / % note % note: default_color: # light, dark, red, orange, yellow, green, cyan, blue, purple, warning, error border: true # true / false # % checkbox % checkbox: interactive: false # enable interactive for user # % quot % quot: default: # 可以自行配置多种图标方案 prefix: https://bu.dusays.com/2022/10/24/63567d3e092ff.png suffix: https://bu.dusays.com/2022/10/24/63567d3e0ab55.png hashtag: prefix: https://bu.dusays.com/2022/10/24/63567d3e07da3.png # % emoji % emoji: default: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/$name.gif twemoji: https://gcore.jsdelivr.net/gh/twitter/twemoji/assets/svg/$name.svg qq: https://gcore.jsdelivr.net/gh/cdn-x/emoji/qq/$name.gif aru: https://gcore.jsdelivr.net/gh/cdn-x/emoji/aru-l/$name.gif tieba: https://gcore.jsdelivr.net/gh/cdn-x/emoji/tieba/$name.png blobcat: https://gcore.jsdelivr.net/gh/norevi/waline-blobcatemojis@1.0/blobs/$name.png # % image % image: fancybox: false # true, false parse_markdown: true # 把 markdown 格式的图片解析成图片标签 # % timeline % timeline: max-height: 80vh # % mark % mark: default_color: dark # light, dark, red, orange, yellow, green, cyan, blue, purple, warning, error # % tag % tag: default_color: yellow # red, orange, yellow, green, cyan, blue, purple######## JS Plugins ########plugins: ## required plugins ## # jquery jquery: https://gcore.jsdelivr.net/npm/jquery@3.6.2/dist/jquery.min.js # stellar api stellar: sites: /js/plugins/sites.js friends: /js/plugins/friends.js ghinfo: /js/plugins/ghinfo.js timeline: /js/plugins/timeline.js linkcard: /js/plugins/linkcard.js fcircle: /js/plugins/fcircle.js weibo: /js/plugins/weibo.js marked: https://cdn.bootcdn.net/ajax/libs/marked/4.0.18/marked.min.js ## optional plugins ## # preload preload: enable: true service: flying_pages # instant_page, flying_pages instant_page: https://gcore.jsdelivr.net/gh/volantis-x/cdn-volantis@4.1.2/js/instant_page.js flying_pages: https://gcore.jsdelivr.net/gh/gijo-varghese/flying-pages@2.1.2/flying-pages.min.js # image lazyload # https://www.npmjs.com/package/vanilla-lazyload lazyload: enable: true # [hexo clean hexo s] is required after changing this value. js: https://gcore.jsdelivr.net/npm/vanilla-lazyload@17.8.3/dist/lazyload.min.js transition: blur # blur, fade # https://scrollrevealjs.org/api/reveal.html scrollreveal: enable: #true js: https://gcore.jsdelivr.net/npm/scrollreveal@4.0.9/dist/scrollreveal.min.js distance: 8px duration: 500 # ms interval: 100 # ms scale: 1 # 0.1~1 # https://fancyapps.com/docs/ui/fancybox/ # available for % image xxx % fancybox: enable: true js: https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.umd.js css: https://gcore.jsdelivr.net/npm/@fancyapps/ui@4.0/dist/fancybox.css # 可以处理评论区的图片（不支持 iframe 类评论系统）例如： # 使用twikoo评论可以写: .tk-content img:not([class*=emo]) # 使用waline评论可以写: #waline_container .vcontent img selector: .swiper-slide img # 多个选择器用英文逗号隔开 # swiper swiper: enable: true css: https://unpkg.com/swiper@8.4.5/swiper-bundle.min.css js: https://unpkg.com/swiper@8.4.5/swiper-bundle.min.js # 赫蹏 (Heti) - 专为中文网页内容设计的排版样式增强 # https://github.com/sivan/heti heti: enable: false # 此插件会和代码块冲突，仅适用于纯中文博主。 css: https://unpkg.com/heti@0.9.2/umd/heti.min.css js: https://unpkg.com/heti@0.9.2/umd/heti-addon.min.js # MathJax # 需在Markdown文件开头加入mathjax: true # 推荐使用Pandoc: npm uninstall hexo-renderer-marked --save npm install hexo-renderer-pandoc --save mathjax: enable: false cdn: https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.6/MathJax.js?config=TeX-AMS-MML_HTMLorMML # Katex - The fastest math typesetting library for the web # https://katex.org/docs/autorender.html # https://github.com/KaTeX/KaTeX # 使用 hexo-renderer-markdown-it-plus 作为公式渲染器：npm uninstall hexo-renderer-marked --save npm install hexo-renderer-markdown-it-plus --save katex: enable: false min_css: link rel=stylesheet href=https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css integrity=sha384-vKruj+a13U8yHIkAyGgK1J3ArTLzrFGBbBc0tDp4ad/EyewESeXE/Iv67Aj8gKZ0 crossorigin=anonymous min_js: script defer src=https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.js integrity=sha384-PwRUT/YqbnEjkZO0zZxNqcxACrXe+j766U2amXcgMg5457rve2Y7I6ZJSm2A0mS4 crossorigin=anonymous/script auto_render_min_js: script defer src=https://gcore.jsdelivr.net/npm/katex@0.16.4/dist/contrib/auto-render.min.js integrity=sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05 crossorigin=anonymousonload=renderMathInElement(document.body);/script # Mermaid - markdwon to flow chart, seq chart, class chart ... # 需要安装 npm install --save hexo-filter-mermaid-diagrams # 使用时 需要在Markdown文件开头加入 mermaid: true # 使用示例： # ```mermaid # graph LR # A(Section A) --|option 1| B(Section A) # B --|option 2| C(Section C) # ``` mermaid: enable: false # js: https://unpkg.com/mermaid@9.0.0/dist/mermaid.min.js js: https://cdn.jsdelivr.net/npm/mermaid@v9/dist/mermaid.min.js # Available themes: default | dark | forest | neutral # 推荐使用 dark 主题 在夜间模式下显示效果更好 theme: dark # 代码块复制按钮 copycode: enable: true js: /js/plugins/copycode.js default_text: Copy success_text: Copied # AI 摘要 # https://github.com/zhheo/Post-Abstract-AI tianli_gpt: enable: false field: post # all, post, wiki api: 5Q5mpqRK5DkwT1X9Gi5estyle: darkmode: auto # auto / always / false smooth_scroll: true # true / false font-size: root: 16px body: .9375rem # 15px code: 85% # 14px codeblock: 0.8125rem # 13px font-family: logo: system-ui, Microsoft Yahei, Segoe UI, -apple-system, Roboto, Ubuntu, Helvetica Neue, Arial, WenQuanYi Micro Hei, sans-serif body: system-ui, Microsoft Yahei, Segoe UI, -apple-system, Roboto, Ubuntu, Helvetica Neue, Arial, WenQuanYi Micro Hei, sans-serif code: Menlo, Monaco, Consolas, system-ui, Courier New, monospace, sans-serif codeblock: Menlo, Monaco, Consolas, system-ui, Courier New, monospace, sans-serif text-align: left border-radius: card: 12px block: 12px bar: 6px image: 6px color: # 动态颜色（会根据明暗主题重设明度值，只用关心色相和饱和度即可） background: hsl(212 16% 98%) # 浅色背景颜色 block: hsl(212 8% 95%) # 块背景颜色 code: hsl(14 100% 48%) # 行内代码颜色 text: hsl(0 0% 20%) # 文本颜色 # 主题色配置（不会根据明暗动态调整，请设置为通用的颜色） theme: hsl(192 98% 55%) # 主题色 accent: hsl(14 100% 57%) # 强调色 link: hsl(207 90% 54%) # 超链接颜色 button: hsl(192 98% 55%) # 按钮颜色 hover: hsl(14 100% 57%) # 按钮高亮颜色 animated_avatar: animate: auto # auto, always background: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/rainbow64@3x.webp codeblock: scrollbar: 4px highlightjs_theme: https://gcore.jsdelivr.net/gh/highlightjs/cdn-release@11.7.0/build/styles/atom-one-dark.min.css loading: loading: 正在加载 error: 加载失败，请稍后重试。 gradient: # https://webgradients.com/ start: linear-gradient(to right, hsl(215, 95%, 64%), hsl(195, 95%, 60%), hsl(165, 95%, 56%), hsl(165, 95%, 56%), hsl(195 95% 60%), hsl(215, 95%, 64%)) search: linear-gradient(to right, #04F3FF, #08FFC6, #DDF730, #FFBD19, #FF1FE0, #C418FF, #04F3FF)default: avatar: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/avatar/round/3442075.svg link: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/link/8f277b4ee0ecd.svg cover: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/cover/76b86c0226ffd.svg image: https://gcore.jsdelivr.net/gh/cdn-x/placeholder@1.0.4/image/2659360.svgapi_host: ghapi: https://api.github.com ghraw: https://raw.githubusercontent.com gist: https://gist.github.com 各配置项功能说明我们自己在项目根目录中创建一个_config.stellar.yml文件用于项目配置。一般我们只需要更改 sidebar 和 footer 部分即可 _config.stellar.yml 文件配置我们可以去 node_modules/hexo-theme-stellar/_config.yml 找到啊 stellar 项目的原始配置文件，复制到我们创建的_config.stellar.yml文件中。然后在此基础上进行改动 一般我们需要改动的只有sidebar部分和footer部分。 sidebar 部分我们需要配置网站的侧边栏 sidebar: menu: post: [btn.blog](/) wiki: [专栏](/wiki/) notes: [导航](/notes/) more: [关于](/about/) 我们也可以在 sidebar 部分配置每个页面需要出现的小部件。自定义的小部件需要我们在 widgets.yml 文件中声明 sidebar: widgets: #### 自动生成的页面 #### # 主页 home: search, welcome, recent, ad, tagcloud, timeline # for home # 博客索引页 blog_index: search_blog, recent, ad, timeline # for categories/tags/archives # 文档索引页 wiki_index: search_docs, recent, ad, timeline # for wiki # 其它（404） others: search, welcome, recent, timeline # for 404 and ... #### 手动创建的页面 #### # 文章内页 post: toc, ghrepo, search, ghissues, ad # for pages using layout:post # 文档内页 wiki: search, ghrepo, toc, ad, ghissues, related # for pages using layout:wiki # 其它 layout:page 的页面 page: welcome, toc, ad # for custom pages using layout:page 当我们需要添加一个底部站点导航时，我们需要在footer部分添加sitemap footer: sitemap: 博客: - [近期](/) - [分类](/categories/) - [标签](/tags/) - [归档](/archives/) 专栏: - [vscode基础配置](/wiki/vscode/index.html) - [typescript基础](/wiki/typescript/index.html) 更多: - [友链](/) - [关于本站](/about/) - [文档站点](http://doc.whbbit.cn) - [GitHub](https://github.com/Whbbit1999) 自定义小部件在widgets.yml文件中，我们可以定义一些小组件。官方定义的我们直接粘贴就行。这里我说一下自定义小组件 ad: layout: markdown title: 可能是广告位吧🤨 content: | [![sable-admin-ad.jpg](/assets/sable-admin-ad.jpg)](https://github.com/Whbbit1999/sable) 创建独立页面在 widgets.yml 中创建对应的 widgets Notes: name: 笔记 title: 笔记 description: 一个隐藏项目：笔记 index: false # sidebar: [toc] tags: 知识库 sections: 日常问题解决方案: [100, 199] 移动端开发笔记: [200, 299] 前端学习笔记: [300, 399] 在线工具: [400, 499] 添加后，可以在_config.stellar.yml中添加对应的 sidebar sidebar: ... menu: ... notes: [笔记](/notes/) 创建对应的文件夹（文件夹名需要对应路径），这里需要创建对应的 notes 文件夹 如果你有 wiki 页面并且不想让它出现在 wiki 页面中时，可以在projects.yml中添加 Notes: index: false 接下来你就可以在对应的目录下书写对应的内容了。 添加友链需要注意将 actions 的权限更改为可以写入内容 高级功能自定义 js 脚本这里我们实现一个谷歌统计和百度统计脚本 use strict// 百度统计和google 统计hexo.extend.injector.register(body_end, function () return `script var _hmt = _hmt || []; (function() var hm = document.createElement(script); hm.src = https://hm.baidu.com/hm.js?31181a38d70c8faf2c5bed0d93cab07b; var s = document.getElementsByTagName(script)[0]; s.parentNode.insertBefore(hm, s); )(); /script script async=async src=https://www.googletagmanager.com/gtag/js?id=G-FTR5YKFFCM/script script window.dataLayer = window.dataLayer || []; function gtag()dataLayer.push(arguments); gtag(js, new Date()); gtag(config, G-FTR5YKFFCM); /script `) 使用 GitHub pages 部署博客使用 GitHub + vercel 部署使用 GitHub + GitHub Actions + 服务器进行本地化部署"},{"title":"我的世界资源站点实战","path":"/wiki/video-point/我的世界资源站点.html","content":"技术选型 前端前端使用 Nuxt3 进行项目开发 后端后端使用 nestjs 进行项目开发，数据库管理使用 Prisma 数据库数据库使用 postgresql 前端开发环境搭建后端开发环境搭建"},{"title":"工具网站","path":"/wiki/vscode/工具网站.html","content":"vscode 代码片段生成 https://snippet-generator.app/?description=&tabtrigger=&snippet=&mode=vscodehttps://snippet-generator.app/?description=&tabtrigger=&snippet=&mode=vscode 二维码生成库https://qr-x.devtrice.dev/"},{"title":"编辑器美化","path":"/wiki/vscode/美化.html","content":"主题Vitesse Theme这个是 vue 团队成员 Anthony Fu 出品的主题，包含亮色和暗色两种主题。 https://marketplace.visualstudio.com/items?itemName=antfu.theme-vitessehttps://marketplace.visualstudio.com/items?itemName=antfu.theme-vitesse 下面是对应的图片预览 DevPro - High Contrast这个主题是高对比度中比较符合我心意的一款 https://marketplace.visualstudio.com/items?itemName=koprodev.theme-devpro-hchttps://marketplace.visualstudio.com/items?itemName=koprodev.theme-devpro-hc 文件图标file-iconshttps://marketplace.visualstudio.com/items?itemName=file-icons.file-iconshttps://marketplace.visualstudio.com/items?itemName=file-icons.file-icons Carbon Product Iconshttps://marketplace.visualstudio.com/items?itemName=antfu.icons-carbonhttps://marketplace.visualstudio.com/items?itemName=antfu.icons-carbon Catppuccin Icons for VSCode非常可爱的一款图标主题 https://marketplace.visualstudio.com/items?itemName=Catppuccin.catppuccin-vsc-iconshttps://marketplace.visualstudio.com/items?itemName=Catppuccin.catppuccin-vsc-icons"},{"title":"配置项","path":"/wiki/vscode/配置.html","content":"保存时自动整理 importsettings.json 中加入配置项： “editor.codeActionsOnSave”: { “source.organizeImports”: true }, settings.json editor.codeActionsOnSave: source.organizeImports: true 可实现保存代码时（ctrl+s）自动整理页面所有 import 引用，包括删除未使用到的 import、多 import 归类整理、排序等。很好用。 使用连体字符我们平时在网上看别人视频时候会出现 = 连起来的样子，我们可以这样设置 settings.json editor.fontLigatures: true 必须配合支持连字效果的字体，这里推荐Fira code。 下面是配置好后的样式示例"},{"title":"插件扩展","path":"/wiki/vscode/插件扩展.html","content":"这里包含了所有我使用的插件 通用插件WakaTime记录编码时间，可以比较准确地知道你一天都在哪些项目中工作了多长时间。 https://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatimehttps://marketplace.visualstudio.com/items?itemName=WakaTime.vscode-wakatime Error Lens在编辑器中显示当前行的错误信息 https://marketplace.visualstudio.com/items?itemName=usernamehw.errorlenshttps://marketplace.visualstudio.com/items?itemName=usernamehw.errorlens Better Comments提供 TODO 注释的高亮，支持自定义配置 https://marketplace.visualstudio.com/items?itemName=aaron-bond.better-commentshttps://marketplace.visualstudio.com/items?itemName=aaron-bond.better-comments Code Runner提供多种编程语言的快速启动功能 https://marketplace.visualstudio.com/items?itemName=formulahendry.code-runnerhttps://marketplace.visualstudio.com/items?itemName=formulahendry.code-runner Docker提供 docker 语法提示和构建功能 https://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-dockerhttps://marketplace.visualstudio.com/items?itemName=ms-azuretools.vscode-docker Dyno File Utils快速创建文件 https://marketplace.visualstudio.com/items?itemName=dyno-nguyen.vscode-dynofileutilshttps://marketplace.visualstudio.com/items?itemName=dyno-nguyen.vscode-dynofileutils Git History可视化 git 时间线工具 https://marketplace.visualstudio.com/items?itemName=donjayamanne.githistoryhttps://marketplace.visualstudio.com/items?itemName=donjayamanne.githistory GitLens — Git superchargedvscode 中最好的 git 插件 https://marketplace.visualstudio.com/items?itemName=eamodio.gitlenshttps://marketplace.visualstudio.com/items?itemName=eamodio.gitlens Project Manager提供项目管理功能 https://marketplace.visualstudio.com/items?itemName=alefragnani.project-managerhttps://marketplace.visualstudio.com/items?itemName=alefragnani.project-manager REST Client提供 restful 接口测试功能 https://marketplace.visualstudio.com/items?itemName=humao.rest-clienthttps://marketplace.visualstudio.com/items?itemName=humao.rest-client Tabnine AI Autocomplete for Javascript, Python, Typescript, PHP, Go, Java, Ruby more智能代码提示 https://marketplace.visualstudio.com/items?itemName=TabNine.tabnine-vscodehttps://marketplace.visualstudio.com/items?itemName=TabNine.tabnine-vscode 前端开发Live Server快速启动一个服务预览 html https://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServerhttps://marketplace.visualstudio.com/items?itemName=ritwickdey.LiveServer Auto Rename Tag提供同步修改对应标签的功能 https://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-taghttps://marketplace.visualstudio.com/items?itemName=formulahendry.auto-rename-tag DotENV.env 文件高亮 https://marketplace.visualstudio.com/items?itemName=mikestead.dotenvhttps://marketplace.visualstudio.com/items?itemName=mikestead.dotenv Element UI SnippetsElement UI 代码片段 https://marketplace.visualstudio.com/items?itemName=SS.element-ui-snippetshttps://marketplace.visualstudio.com/items?itemName=SS.element-ui-snippetshttps://marketplace.visualstudio.com/items?itemName=SS.element-ui-snippetshttps://marketplace.visualstudio.com/items?itemName=SS.element-ui-snippets ESLinthttps://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslinthttps://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint Prettier - Code formatterhttps://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscodehttps://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode Tailwind CSS IntelliSense提供 Tailwind CSS 的代码提示 https://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcsshttps://marketplace.visualstudio.com/items?itemName=bradlc.vscode-tailwindcss vue2 插件开发 vue2 时，需要 Vetur 提供语法高亮和代码提示 https://marketplace.visualstudio.com/items?itemName=octref.veturhttps://marketplace.visualstudio.com/items?itemName=octref.vetur vue3 插件在使用 vue3 时，需要安装 volar 提供对 script setup 的语法高亮和代码提示 对应的插件有： 基础包 Vue Language Features (Volar) https://marketplace.visualstudio.com/items?itemName=Vue.volarhttps://marketplace.visualstudio.com/items?itemName=Vue.volar 对 ts 的扩展 TypeScript Vue Plugin (Volar) https://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-pluginhttps://marketplace.visualstudio.com/items?itemName=Vue.vscode-typescript-vue-plugin React 插件ES7+ React/Redux/React-Native snippets 提供 react 代码片段 https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippetshttps://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets JavaScript (ES6) code snippets可以根据对应的简写方式快速生成 es6 代码片段 https://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippetshttps://marketplace.visualstudio.com/items?itemName=xabikos.JavaScriptSnippets vscode-styled-components提供 styled-components 语法高亮和提示 https://marketplace.visualstudio.com/items?itemName=styled-components.vscode-styled-componentshttps://marketplace.visualstudio.com/items?itemName=styled-components.vscode-styled-components svg提供 svg 预览和编辑功能 https://marketplace.visualstudio.com/items?itemName=jock.svghttps://marketplace.visualstudio.com/items?itemName=jock.svg Image preview在侧边栏预览当前引入的图片 https://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-gutter-previewhttps://marketplace.visualstudio.com/items?itemName=kisstkondoros.vscode-gutter-preview Import Cost查看当前引入 npm 包的大小 https://marketplace.visualstudio.com/items?itemName=wix.vscode-import-costhttps://marketplace.visualstudio.com/items?itemName=wix.vscode-import-cost i18n Ally提供对 i18 的预览 https://marketplace.visualstudio.com/items?itemName=Lokalise.i18n-allyhttps://marketplace.visualstudio.com/items?itemName=Lokalise.i18n-ally Turbo Console Log使用快捷键ctrl options ls打印选中的值 服务器扩展有时我们需要连接服务器进行一些操作。我们可以下载对应的插件来直接操作服务器资源。下面的插件包含了 ftp 和 ssh 功能，可以直接连接服务器进行连接和文件上传。 Remote - SSHhttps://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-sshhttps://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh Remote - SSH: Editing Configuration Fileshttps://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh-edithttps://marketplace.visualstudio.com/items?itemName=ms-vscode-remote.remote-ssh-edit Remote Explorerhttps://marketplace.visualstudio.com/items?itemName=ms-vscode.remote-explorerhttps://marketplace.visualstudio.com/items?itemName=ms-vscode.remote-explorer SFTPhttps://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftphttps://marketplace.visualstudio.com/items?itemName=Natizyskunk.sftp"}]